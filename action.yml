name: "Setup EDAMAME Posture"
description: "Download and control EDAMAME Posture"
inputs:
  edamame_user:
    description: "EDAMAME user (required to start the process in the background)"
    required: false
  edamame_domain:
    description: "EDAMAME domain (required to start the process in the background)"
    required: false
  edamame_pin:
    description: "EDAMAME PIN (required to start the process in the background)"
    required: false
  edamame_id:
    description: "EDAMAME identifier suffix (required to start the process in the background)"
    required: false
  edamame_policy:
    description: "EDAMAME policy name that the device must comply with (the action will fail if the device does not comply)"
    required: false
  edamame_minimum_score:
    description: "Minimum score that the device must achieve (the action will fail if the device does not achieve the minimum score)"
    required: false
  edamame_mandatory_threats:
    description: "Comma separated list of mandatory threats that the device must not exhibit (the action will fail if the device does not detect the threats)"
    required: false
  edamame_mandatory_prefixes:
    description: "Comma separated list of mandatory tag prefixes covering threats that the device must not exhibit (the action will fail if the device does not have the prefixes)"
    required: false
  auto_remediate:
    description: "Automatically remediate posture issues"
    required: false
    default: "false"
  skip_remediations:
    description: "Remediations to skip when performing auto-remediations (comma separated)"
    required: false
  network_scan:
    description: "Scan network for critical devices (only applicable if the background process is started)"
    required: false
    default: "false"
  packet_capture:
    description: "Capture network traffic (auto = follow network_scan)"
    required: false
    default: "auto"
  check_whitelist:
    description: "Report and enforce whitelist exceptions when capturing network traffic (requires a whitelist name)"
    required: false
    default: "false"
  check_blacklist:
    description: "Report and enforce blacklist matches during network capture"
    required: false
    default: "true"
  check_anomalous:
    description: "Report and enforce anomalous session detection during network capture"
    required: false
    default: "true"
  cancel_on_violation:
    description: "Attempt to cancel the current CI pipeline when violations are detected"
    required: false
    default: "false"
  disconnected_mode:
    description: "Start EDAMAME Posture in disconnected mode without requiring domain authentication"
    required: false
    default: "false"
  dump_sessions_log:
    description: "Dump sessions log (requires background process with packet capture enabled)"
    required: false
    default: "false"
  checkout:
    description: "Checkout the repo through the git CLI (retry if access is not granted)"
    required: false
    default: "false"
  checkout_submodules:
    description: "Checkout submodules"
    required: false
    default: "false"
  wait_for_https:
    description: "Wait for https access to the repo be granted"
    required: false
    default: "false"
  wait:
    description: "Wait for a while for access to be granted"
    required: false
    default: "false"
  wait_for_api:
    description: "Wait for API access to be granted"
    required: false
    default: "false"
  token:
    description: "GitHub token to checkout the repo"
    required: false
    default: ${{ github.token }}
  whitelist:
    description: "Whitelist to use for the network scan (only applicable if the background process is started)"
    required: false
    default: ""
  exit_on_whitelist_exceptions:
    description: "Exit with error when whitelist exceptions are detected (directly passed to get-sessions)"
    required: false
    default: "true"
  exit_on_blacklisted_sessions:
    description: "Exit with error when blacklisted sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  exit_on_anomalous_sessions:
    description: "Exit with error when anomalous sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  report_email:
    description: "Report email address"
    required: false
    default: ""
  create_custom_whitelists:
    description: "Create custom whitelists from captured network sessions and save it to the specified path"
    required: false
    default: "false"
  custom_whitelists_path:
    description: "Path to save or load custom whitelists JSON (used with create_custom_whitelists or to provide a whitelist file to apply)"
    required: false
    default: ""
  set_custom_whitelists:
    description: "Apply custom whitelists from a file specified in custom_whitelists_path"
    required: false
    default: "false"
  augment_custom_whitelists:
    description: "Augment the existing custom whitelists using current network sessions and merge the result back into the file specified by custom_whitelists_path. Requires network_scan=true."
    required: false
    default: "false"
  auto_whitelist:
    description: "Enable auto-whitelist mode: first run is listen-only, subsequent runs refine whitelist until stable. Requires disconnected_mode=true, network_scan=true, packet_capture=true."
    required: false
    default: "false"
  auto_whitelist_artifact_name:
    description: "Name for the GitHub artifact to store auto-whitelist state (default: edamame-auto-whitelist)"
    required: false
    default: "edamame-auto-whitelist"
  auto_whitelist_stability_threshold:
    description: "Percentage threshold for whitelist stability (default: 0% - no new endpoints)"
    required: false
    default: "0"
  auto_whitelist_stability_consecutive_runs:
    description: "Number of consecutive runs with no changes required for stability (default: 3)"
    required: false
    default: "3"
  auto_whitelist_max_iterations:
    description: "Maximum number of auto-whitelist iterations before declaring stable (default: 10)"
    required: false
    default: "20"
  include_local_traffic:
    description: "Include local traffic in network capture and session logs"
    required: false
    default: "false"
  agentic_mode:
    description: "AI assistant mode for automated security todo processing: auto (execute), analyze (recommendations only), or disabled"
    required: false
    default: "disabled"
  agentic_provider:
    description: "LLM provider for AI assistant: claude, openai, ollama, or none (requires EDAMAME_LLM_API_KEY environment variable)"
    required: false
    default: ""
  agentic_interval:
    description: "Interval in seconds for automated AI assistant todo processing"
    required: false
    default: "3600"
  stop:
    description: "Stop the EDAMAME Posture process"
    required: false
    default: "false"
  display_logs:
    description: "Display logs"
    required: false
    default: "false"
  debug:
    description: "Debug mode"
    required: false
    default: "false"

runs:
  using: "composite"

  steps:
    - name: Dependencies
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          cd
          # Install gh, wget, curl, jq using Chocolatey if not already installed
          if ! choco list | grep -E '^gh[[:space:]]'; then
            echo "Installing gh..."
            choco install gh -y
          fi

          if ! choco list | grep -E '^wget[[:space:]]'; then
            echo "Installing wget..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install wget -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^curl[[:space:]]'; then
            echo "Installing curl..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install curl -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^jq[[:space:]]'; then
            echo "Installing jq..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install jq -y | grep -v "Progress:"
          fi

          # Install node if not installed
          if ! choco list | grep -q '^nodejs[[:space:]]'; then
            echo "Installing nodejs..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install nodejs -y | grep -v "Progress:"
          fi

          # Install vcredist2015 if not installed
          if ! choco list | grep -q '^vcredist2015[[:space:]]'; then
            echo "Installing vcredist2015..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install vcredist2015 --package-parameters "/install /quiet /norestart" -y | grep -v "Progress:"
          fi
        elif [[ "$RUNNER_OS" == "Linux" ]]; then
          # Define function to wait for apt/dpkg locks
          wait_for_apt_locks() {
            echo "Checking for apt/dpkg locks..."
            TIMEOUT=300
            TIME_PASSED=0
            # Check common lock files
            LOCK_FILES=(
              "/var/lib/apt/lists/lock"
              "/var/lib/dpkg/lock-frontend"
              "/var/lib/dpkg/lock"
            )
            while sudo fuser "${LOCK_FILES[@]}" >/dev/null 2>&1; do
              echo "Waiting for apt/dpkg locks to be released..."
              sleep 5
              TIME_PASSED=$((TIME_PASSED + 5))
              if [ $TIME_PASSED -ge $TIMEOUT ]; then
                echo "Timed out waiting for apt/dpkg locks after $TIMEOUT seconds."
                exit 1
              fi
            done
            echo "No apt/dpkg locks held, proceeding..."
          }
          
          # Avoid prompts during apt-get install
          export DEBIAN_FRONTEND=noninteractive
          
          # Install sudo if needed
          if ! command -v sudo &> /dev/null; then
            echo "Installing sudo..."
            # Wait for apt lock before any operations
            wait_for_apt_locks
            apt-get update -y
            wait_for_apt_locks
            apt-get install -y --no-install-recommends sudo
            
            # Wait again after installing sudo
            wait_for_apt_locks
          fi          
          # Update package lists
          echo "Updating package lists..."
          wait_for_apt_locks
          sudo -E apt-get update

          # Check/install git
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            wait_for_apt_locks
            sudo -E apt-get install -y git
          fi

          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            wait_for_apt_locks
            (type -p wget >/dev/null || (wait_for_apt_locks; sudo -E apt-get update -y && wait_for_apt_locks && sudo -E apt-get install -y wget)) \
              && sudo mkdir -p -m 755 /etc/apt/keyrings \
                    && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \
                    && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null \
              && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && wait_for_apt_locks \
              && sudo -E apt-get update -y \
              && wait_for_apt_locks \
              && sudo -E apt-get install -y gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            wait_for_apt_locks
            sudo -E apt-get install -y wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            wait_for_apt_locks
            sudo -E apt-get install -y curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            wait_for_apt_locks
            sudo -E apt-get install -y jq
          fi

          # Check/install bc (needed for auto-whitelist floating-point comparisons)
          if ! command -v bc &> /dev/null; then
            echo "Installing bc..."
            wait_for_apt_locks
            sudo -E apt-get install -y bc
          fi

          # Check/install libpcap0.8t64
          if ! dpkg -s libpcap0.8t64 &> /dev/null; then
            echo "Installing libpcap0.8t64..."
            wait_for_apt_locks
            # Install libpcap0.8t64 if available, otherwise install libpcap0.8
            if ! sudo -E apt-get install -y libpcap0.8t64  &> /dev/null; then
              echo "Failed to install libpcap0.8t64, using libpcap0.8 instead"
              if ! dpkg -s libpcap0.8 &> /dev/null; then
                echo "Installing libpcap0.8..."
                wait_for_apt_locks
                sudo -E apt-get install -y libpcap0.8
              fi
            fi
          fi

          # Check/install build-essential
          if ! dpkg -s build-essential &> /dev/null; then
            echo "Installing build-essential..."
            wait_for_apt_locks
            sudo -E apt-get install -y build-essential
          fi

          # Check/install node + npm
          if ! command -v node &> /dev/null; then
            echo "Installing node + npm..."
            wait_for_apt_locks
            sudo -E apt-get install -y nodejs npm
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            brew install gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            brew install wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            brew install curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            brew install jq
          fi

          # Check/install node
          if ! command -v node &> /dev/null; then
            echo "Installing node..."
            brew install node
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi
      shell: bash

    - name: Download EDAMAME Posture binary
      id: download_binary
      run: |
        JQ=jq
        echo "jq version: $($JQ --version)"

        # --- Determine Latest Version via Redirect ---
        LATEST_VERSION=""
        echo "Attempting to get latest version via redirect..."
        REDIRECT_OUTPUT=$(curl -s -L -I -o /dev/null -w '%{url_effective}:%{http_code}' https://github.com/edamametechnologies/edamame_posture_cli/releases/latest)

        # Extract status code (part after the last colon) using bash parameter expansion
        HTTP_STATUS="${REDIRECT_OUTPUT##*:}"
        # Extract URL (part before the last colon and the status code) using bash parameter expansion
        LATEST_RELEASE_URL="${REDIRECT_OUTPUT%:$HTTP_STATUS}"

        echo "Redirect URL: $LATEST_RELEASE_URL"
        echo "HTTP Status: $HTTP_STATUS"

        if [[ "$HTTP_STATUS" == "200" && "$LATEST_RELEASE_URL" == *"/releases/tag/"* ]]; then
          LATEST_VERSION=$(basename "$LATEST_RELEASE_URL")
          LATEST_VERSION=${LATEST_VERSION#v} # Remove v prefix
          echo "Latest version found via redirect: $LATEST_VERSION"
        else
          echo "Failed to get latest version via redirect (Status: $HTTP_STATUS, URL: $LATEST_RELEASE_URL). Will try API fallback."
        fi

        # --- Determine Fallback Version via API ---
        API_FALLBACK_VERSION=""
        HARDCODED_FALLBACK_VERSION="0.9.60" # Define hardcoded fallback
        echo "Attempting to get fallback version via API..."
        WAIT_TIME=5
        for i in {1..3}; do # Limit retries
          FALLBACK_API_RESPONSE=$(curl -s https://api.github.com/repos/edamametechnologies/edamame_posture_cli/releases)
          
          # Check for rate limit first
          if echo "$FALLBACK_API_RESPONSE" | grep -qi "API rate limit exceeded"; then
            WAIT_TIME=$((WAIT_TIME * 2))
            if [[ $WAIT_TIME -gt 60 ]]; then WAIT_TIME=60; fi # Cap wait time
            echo "API rate limit exceeded for fallback, sleeping for $WAIT_TIME seconds (Attempt $i)"
            sleep $WAIT_TIME
          # If not rate limited, check if response is valid and has enough data
          elif echo "$FALLBACK_API_RESPONSE" | $JQ -e '. | length > 1' > /dev/null; then
            # Get the tag name of the second non-draft, non-prerelease release
            API_FALLBACK_VERSION=$($JQ -r '[.[] | select(.draft==false and .prerelease==false)][1].tag_name' <<< "$FALLBACK_API_RESPONSE")
            if [[ -n "$API_FALLBACK_VERSION" && "$API_FALLBACK_VERSION" != "null" ]]; then
                API_FALLBACK_VERSION=${API_FALLBACK_VERSION#v} # Remove v prefix
                echo "Fallback version found via API: $API_FALLBACK_VERSION"
                break # Success, exit loop
            else
                echo "Could not extract a valid second latest tag from API response (Attempt $i). JQ filter returned null or empty."
                # Log beginning of response for debugging
                echo "API Response (start): $(echo "$FALLBACK_API_RESPONSE" | head -c 100)..."
                API_FALLBACK_VERSION=""
                sleep 5 # Short sleep before retry on parsing error
            fi
          # If not rate limited and response is not valid/sufficient
          else 
            echo "Invalid API response for fallback (Attempt $i). Not rate limit, and not valid JSON or insufficient releases."
            # Log beginning of response for debugging
            echo "API Response (start): $(echo "$FALLBACK_API_RESPONSE" | head -c 100)..."
            API_FALLBACK_VERSION=""
            sleep 5 # Short sleep before retry on other errors
          fi
        done

        if [[ -z "$API_FALLBACK_VERSION" ]]; then
          echo "Failed to get fallback version from API after retries."
        fi

        # --- Set POSTURE_VERSION and POSTURE_FALLBACK_VERSION for Download ---
        if [[ -n "$LATEST_VERSION" ]]; then
          POSTURE_VERSION="$LATEST_VERSION"
          if [[ -n "$API_FALLBACK_VERSION" ]]; then
            POSTURE_FALLBACK_VERSION="$API_FALLBACK_VERSION"
          else
            echo "Using hardcoded fallback version as API fallback failed."
            POSTURE_FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          fi
        else
          # Latest version via redirect failed
          if [[ -n "$API_FALLBACK_VERSION" ]]; then
            echo "Using API fallback version as primary version."
            POSTURE_VERSION="$API_FALLBACK_VERSION"
            POSTURE_FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          else
            echo "Both redirect and API failed. Using hardcoded versions."
            POSTURE_VERSION="$HARDCODED_FALLBACK_VERSION"
            POSTURE_FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          fi
        fi

        echo "VERSION to download: $POSTURE_VERSION"
        echo "FALLBACK_VERSION to download: $POSTURE_FALLBACK_VERSION"

        # We only support edamame_posture installed in the current directory on Windows and macOS
        # Navigate to the home directory
        cd
        binary_present=false

        # If debug is true, we will not download the binary
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "Debug mode is enabled, using debug version of the binary"
          BIN_POSTFIX="-debug"
        else
          echo "Debug mode is disabled, using latest version of the binary"
          BIN_POSTFIX=""
        fi

        # On Linux we also provide a deb package to have it installed in /usr/bin
        if [[ "$RUNNER_OS" == "Linux" ]]; then
          if [[ -f edamame_posture || -f /usr/bin/edamame_posture ]]; then
            echo "Binary already present"
            binary_present=true
          else
            ARCH=$(uname -m)
            if [[ -f /etc/os-release ]]; then
              source /etc/os-release
            else
              echo "/etc/os-release not found. Cannot determine distribution."
              exit 1
            fi
            case "$ID" in
              "alpine")
                # Alpine Linux
                if [[ "$ARCH" == "x86_64" ]]; then
                  echo "Downloading Alpine Linux binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                else
                  echo "Downloading Alpine Linux ARM binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                fi
                ;;
              *)
                # Everything else (Amazon, Ubuntu, Debian, or any unknown distro)
                if [[ "$ARCH" == "x86_64" ]]; then
                  MIN_GLIBC_VERSION="2.29"
                  echo "Minimum required GLIBC version: $MIN_GLIBC_VERSION"
                  if command -v getconf >/dev/null 2>&1; then
                    echo "Using getconf to determine GLIBC version"
                    GLIBC_VERSION=$(getconf GNU_LIBC_VERSION | awk '{print $2}')
                    echo "Detected GLIBC version: $GLIBC_VERSION"
                    # Compare versions using sort
                    if printf '%s\n%s\n' "$MIN_GLIBC_VERSION" "$GLIBC_VERSION" | sort -V | head -n 1 | grep -q "$MIN_GLIBC_VERSION"; then
                      echo "GLIBC version $GLIBC_VERSION is sufficient (minimum required: $MIN_GLIBC_VERSION)"
                      echo "Downloading x86_64-unknown-linux-gnu version of EDAMAME Posture binary for Linux..."
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                    else
                      echo "Warning: GLIBC version $GLIBC_VERSION is older than minimum required version $MIN_GLIBC_VERSION"
                      echo "Fallback to using x86_64-unknown-linux-musl version of the binary"
                      echo "Downloading x86_64-unknown-linux-musl version of EDAMAME Posture binary for Linux..."
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                    fi
                  else
                    echo "Unable to detect GLIBC version, getconf command not found"
                    exit 1
                  fi
                  # echo "Downloading Gnu Linux binary..."
                elif [[ "$ARCH" == "i686" ]]; then
                  echo "Downloading Gnu Linux i686 binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                elif [[ "$ARCH" == "aarch64" ]]; then
                  echo "Downloading Gnu Linux ARM binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                elif [[ "$ARCH" == "armhf" ]]; then
                  echo "Downloading Gnu Linux ARM binary..."
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture || \
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture || \
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture
                else
                  echo "Unsupported architecture: $ARCH"
                  exit 1
                fi
            esac
            chmod u+x edamame_posture
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          if [[ -f edamame_posture ]]; then
            echo "Binary already present"
            binary_present=true
          else
            echo "Downloading EDAMAME Posture binary for macOS..."
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture
            chmod u+x edamame_posture
          fi
        elif [[ "$RUNNER_OS" == "Windows" ]]; then
          if [[ -f edamame_posture.exe ]]; then
            echo "Binary already present"
            binary_present=true
          else
            echo "Downloading EDAMAME Posture binary for Windows..."
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi

        # Set the output based on whether the binary was already present
        echo "binary_already_present=$binary_present" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set EDAMAME_POSTURE_CMD variable
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          EDAMAME_POSTURE_CMD="./edamame_posture.exe"
          echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
        else
          if command -v edamame_posture >/dev/null 2>&1; then
            EDAMAME_POSTURE_CMD="sudo edamame_posture"
            echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
          else
            EDAMAME_POSTURE_CMD="sudo ./edamame_posture"
            echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
          fi
        fi

        # Set log level to debug if debug mode is enabled
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "EDAMAME_LOG_LEVEL=debug" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Show initial posture
      run: |
        cd
        $EDAMAME_POSTURE_CMD score
      shell: bash

    - name: Auto remediate/harden posture issues if requested and if we are not running in a self-hosted runner (the binary is already present)
      run: |
        cd
        if [[ "${{ inputs.auto_remediate }}" == "true" && "${{ steps.download_binary.outputs.binary_already_present }}" == "false" ]]; then
          if [[ "${{ inputs.skip_remediations }}" == "" ]]; then
            echo "No remediations to skip"
            $EDAMAME_POSTURE_CMD remediate
          else
            echo "Skipping remediations: ${{ inputs.skip_remediations }}"
            $EDAMAME_POSTURE_CMD remediate "${{ inputs.skip_remediations }}"
          fi
        fi
      shell: bash

    - name: Report email
      run: |
        cd
        if [[ "${{ inputs.report_email }}" != "" ]]; then
          signature=$($EDAMAME_POSTURE_CMD request-signature | grep Signature | awk '{print $2}')
          echo "Signature: $signature"
          echo "Sending compliance report to email: ${{ inputs.report_email }}"
          $EDAMAME_POSTURE_CMD request-report "${{ inputs.report_email }}" "$signature"
        fi
      shell: bash

    - name: Check local policy compliance
      run: |
        cd
        # Check if minimum score and mandatory threats are provided. Mandatory prefixes are optional.
        if [[ -n "${{ inputs.edamame_minimum_score }}" ]]; then
          echo "Checking policy compliance with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
          
          # Capture the policy check output, also use prefix to check for mandatory threats
          policy_output=$($EDAMAME_POSTURE_CMD check-policy "${{ inputs.edamame_minimum_score }}" "${{ inputs.edamame_mandatory_threats }}" "${{ inputs.edamame_mandatory_prefixes }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
        fi
      shell: bash

    - name: Check domain policy compliance
      run: |
        cd
        # Check if both domain and policy are provided
        if [[ -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_policy }}" ]]; then
          echo "Checking policy compliance with domain: ${{ inputs.edamame_domain }} and policy: ${{ inputs.edamame_policy }}"
          
          # Capture the policy check output
          policy_output=$($EDAMAME_POSTURE_CMD check-policy-for-domain "${{ inputs.edamame_domain }}" "${{ inputs.edamame_policy }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy: ${{ inputs.edamame_policy }} and domain: ${{ inputs.edamame_domain }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy: ${{ inputs.edamame_policy }} and domain: ${{ inputs.edamame_domain }}"
        fi
      shell: bash

    - name: Wait for a while if requested
      run: |
        if [[ "${{ inputs.wait }}" == "true" ]]; then
          sleep 180
        fi
      shell: bash

    - name: Start EDAMAME Posture process and wait for connection if all arguments are provided, skip otherwise
      run: |
        cd
        # Check if all arguments are provided
        if [[ -n "${{ inputs.edamame_user }}" && -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_pin }}" && -n "${{ inputs.edamame_id }}" ]]; then
          if [[ "${{ steps.download_binary.outputs.binary_already_present }}" == "true" ]]; then
            echo "EDAMAME Posture binary is already present. Checking status..."
            # Continue even if there are errors; capture both stdout and stderr
            $EDAMAME_POSTURE_CMD status > posture_status.txt 2>&1 || true

            # Check if the output indicates Error getting connection status: transport error
            if grep -q "Error getting connection status: transport error" posture_status.txt; then
              echo "edamame_posture is installed but isn't connected"
            else
              connected="$({ grep -i 'connected:' posture_status.txt | awk -F': ' '{print $2}'; } || true)"
              connected="${connected:-false}"
              echo "edamame_posture is connected: $connected"
            fi

            # Compare with inputs
            if [[ "$connected" == "true" ]]; then
              echo "EDAMAME Posture is already running with the specified user and domain. Skipping start process."
              # Instead of exiting, use a variable to control the flow
              SKIP_START=true
            else
              # Linux 
              if [[ "$RUNNER_OS" == "Linux" ]]; then
                # We assume the edamame_posture service is installed
                echo "edamame_posture service is installed but isn't connected, please configure it properly in order to use this runner"
                exit 1
              elif [[ "$RUNNER_OS" == "macOS" ]]; then
                # There are no macOS edamame_posture service package yet, so we have to start the process in the background
                echo "edamame_posture service is installed but isn't connected, it will be automatically started in the background"
              elif [[ "$RUNNER_OS" == "Windows" ]]; then
                # There are no Windows edamame_posture service package yet, so we have to start the process in the background
                echo "edamame_posture service is installed but isn't connected, it will be automatically started in the background"
              fi
            fi
          fi

          # Only continue with the start process if we're not skipping it
          if [[ "$SKIP_START" != "true" ]]; then
            # Add a unique suffix to the edamame_id to avoid conflicts using matrix jobs
            # ms since epoch
            IDSUFFIX=$(node -e "console.log(Date.now())")

            START_ARGS=(
              start
              --user "${{ inputs.edamame_user }}"
              --domain "${{ inputs.edamame_domain }}"
              --pin "${{ inputs.edamame_pin }}"
              --device-id "${{ inputs.edamame_id }}_$IDSUFFIX"
            )

            if [[ "${{ inputs.network_scan }}" == "true" ]]; then
              START_ARGS+=(--network-scan)
            fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

            if [[ "${{ inputs.whitelist }}" != "" ]]; then
              START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
            fi

            if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
              START_ARGS+=(--fail-on-whitelist)
            fi

            if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
              START_ARGS+=(--fail-on-blacklist)
            fi

            if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
              START_ARGS+=(--fail-on-anomalous)
            fi

            if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
              START_ARGS+=(--cancel-on-violation)
            fi

            if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
              START_ARGS+=(--include-local-traffic)
            fi

            if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
              START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
            fi

            if [[ "${{ inputs.agentic_provider }}" != "" ]]; then
              START_ARGS+=(--agentic-provider "${{ inputs.agentic_provider }}")
            fi

            if [[ "${{ inputs.agentic_interval }}" != "" && "${{ inputs.agentic_interval }}" != "3600" ]]; then
              START_ARGS+=(--agentic-interval "${{ inputs.agentic_interval }}")
            fi

            echo "Starting EDAMAME Posture..."
            $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
            echo "Waiting for connection..."
            $EDAMAME_POSTURE_CMD wait-for-connection || { cd; find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"; exit 1; }
          fi
        elif [[ "${{ inputs.disconnected_mode }}" == "true" ]]; then
          echo "Starting EDAMAME Posture in disconnected mode..."
          
          # Stop any existing posture process before starting in disconnected mode
          # background-start-disconnected will fail with "Core services are already running" if posture is running
          echo "Stopping any existing EDAMAME Posture process before starting in disconnected mode..."
          $EDAMAME_POSTURE_CMD stop > /dev/null 2>&1 || echo "No existing posture process to stop (or stop failed, continuing anyway)..."
          # Give it a moment to fully stop
          sleep 2

          START_ARGS=(background-start-disconnected)

          if [[ "${{ inputs.network_scan }}" == "true" ]]; then
            START_ARGS+=(--network-scan)
          fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

          if [[ "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
          fi

          if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--fail-on-whitelist)
          fi

          if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
            START_ARGS+=(--fail-on-blacklist)
          fi

          if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
            START_ARGS+=(--fail-on-anomalous)
          fi

          if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
            START_ARGS+=(--cancel-on-violation)
          fi

          if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
            START_ARGS+=(--include-local-traffic)
          fi

          if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
            START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
          fi

          $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' }}
      run: |
        cd
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Use gh CLI to download artifact from previous workflow run
        # Note: This only works for artifacts from previous workflow runs, not from previous jobs in the same workflow
        gh run download --repo ${{ github.repository }} --name "${{ inputs.auto_whitelist_artifact_name }}" 2>/dev/null || echo "No artifact found from previous workflow run (this may be expected in same-workflow scenarios)"
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        if [[ -f "auto_whitelist.json" ]]; then
          echo "Whitelist file found"
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
        else
          echo "No whitelist file found, treating as first run (listen-only mode)"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Apply custom whitelists if provided
      run: |
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "⚠️ Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "⚠️ Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          cd
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            # Check if auto-whitelist has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Auto-whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "⚠️ Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            fi
            
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "auto_whitelist.json"
            echo "Auto-whitelist applied successfully"
          else
            echo "Auto-whitelist mode: First run (listen-only), no whitelist to apply yet"
          fi
        fi
      shell: bash

    - name: Augment existing custom whitelists if requested
      if: ${{ inputs.augment_custom_whitelists == 'true' }}
      run: |
        cd
        # Ensure a path is provided
        if [[ -z "${{ inputs.custom_whitelists_path }}" ]]; then
          echo "Error: augment_custom_whitelists requires custom_whitelists_path to be set."
          exit 1
        fi

        echo "Generating augmented whitelist from current sessions..."
        AUG_JSON=$($EDAMAME_POSTURE_CMD augment-custom-whitelists)

        if [[ -z "$AUG_JSON" ]]; then
          echo "Error: augment-custom-whitelists returned empty output"
          exit 1
        fi

        # Check if augmented whitelist has endpoints
        if command -v jq &> /dev/null; then
          ENDPOINT_COUNT=$(echo "$AUG_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
          echo "Augmented whitelist contains $ENDPOINT_COUNT endpoints"
          
          if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
            echo "⚠️ Warning: Augmented whitelist is empty (no endpoints)"
            echo "This can happen if:"
            echo "  - No baseline whitelist was loaded before augmentation (use set_custom_whitelists: true first)"
            echo "  - No network sessions were captured yet"
            echo "  - No whitelist exceptions (non-conforming sessions) exist to add"
            echo ""
            echo "Augmentation requires:"
            echo "  1. A baseline whitelist loaded into the system (via set_custom_whitelists)"
            echo "  2. Network sessions captured"
            echo "  3. Some non-conforming sessions to add as exceptions"
            exit 1
          fi
        fi

        echo "$AUG_JSON" > "${{ inputs.custom_whitelists_path }}"
        echo "Augmented whitelist saved to: ${{ inputs.custom_whitelists_path }}"
      shell: bash

    - name: Checkout the repo through the git CLI if requested
      run: |
        if [[ "${{ inputs.checkout }}" == "true" ]]; then
          timeout=true

          # Initialize the repo if it doesn't exist
          git init || true

          # Add the remote if it doesn't exist
          if git remote | grep -q '^origin$'; then
            git remote set-url origin https://x-access-token:${{ inputs.token }}@github.com/${{ github.repository }}.git || true
          else
            git remote add origin https://x-access-token:${{ inputs.token }}@github.com/${{ github.repository }}.git || true
          fi
          for i in {1..10}; do
            echo "Attempt $i: Checking out the repo through the git CLI..."
            if git fetch --depth=1 origin ${{ github.ref }}; then
              branch_name=$(echo "${{ github.ref }}" | sed -e "s/^refs\/heads\///")
              if git checkout -B "$branch_name" FETCH_HEAD; then
                if [[ "${{ inputs.checkout_submodules }}" == "true" ]]; then
                  git submodule update --init --recursive
                fi
                timeout=false
                break
              fi
            else
              echo "Checkout of the repo through the git CLI failed. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((i * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for access to the repo through the git CLI."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Checkout of the repo through the git CLI succeeded."
            echo "Time taken to checkout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."

            # Verify the checked out commit and branch
            echo "Checked out branch: $(git rev-parse --abbrev-ref HEAD)"
            echo "Checked out commit: $(git rev-parse HEAD)"
            if [ "$(git rev-parse HEAD)" != "${{ github.sha }}" ]; then
              echo "Warning: The checked out commit does not match the expected SHA."
              echo "Expected: ${{ github.sha }}"
              echo "Actual: $(git rev-parse HEAD)"
            fi
          fi
        fi
      shell: bash

    - name: Wait for API access to be granted if requested
      run: |
        if [[ "${{ inputs.wait_for_api }}" == "true" ]]; then
          attempts=0
          timeout=true
          for i in {1..10}; do
            attempts=$((attempts + 1))
            # We use the GitHub token to access the API using gh release list that requires authentication limited to the scope of the token
            if gh release list --repo ${{ github.repository }}; then
              timeout=false
              break
            else
              sleep 60
            fi
          done

          elapsed_time=$((attempts * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for API access."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "API access granted."
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Wait for https access to the repo be granted if requested
      run: |
        if [[ "${{ inputs.wait_for_https }}" == "true" ]]; then
          attempts=0
          timeout=true
          repo_url="https://github.com/${{ github.repository }}.git"

          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Checking https access to the repo..."
            status_code=$(curl -o /dev/null -s -w "%{http_code}" -H "Authorization: token ${{ inputs.token }}" $repo_url)

            if [[ "$status_code" == "301" || "$status_code" == "200" ]]; then
              timeout=false
              break
            else
              echo "https access to the repo not yet granted. Curl Status Code: $status_code. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((attempts * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for https access to the repo."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "https access to the repo granted."
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash

    - name: Create custom whitelists from network sessions if requested
      run: |
        if [[ "${{ inputs.create_custom_whitelists }}" == "true" ]]; then
          cd
          echo "Creating custom whitelists from active network sessions..."
          if [[ -n "${{ inputs.custom_whitelists_path }}" ]]; then
            # Save to the specified file
            $EDAMAME_POSTURE_CMD create-custom-whitelists > "${{ inputs.custom_whitelists_path }}"
            
            # Check if the created whitelist has endpoints
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Created whitelist contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "⚠️ Warning: Created whitelist is empty (no endpoints)"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet (wait longer before creating whitelist)"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - All sessions were filtered out"
                echo "The whitelist file was created but will not be loaded automatically if empty"
              fi
            fi
            
            echo "Custom whitelists saved to: ${{ inputs.custom_whitelists_path }}"
          else
            # Just display the whitelist JSON
            $EDAMAME_POSTURE_CMD create-custom-whitelists
          fi
        fi
      shell: bash

    - name: Dump sessions log if requested
      run: |
        cd
        
        # Handle auto-whitelist mode
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "=== Auto-whitelist Mode: Processing Iteration $AUTO_WHITELIST_ITERATION ==="
          
          # For subsequent runs, force session update before augmentation to ensure exceptions are populated
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" ]]; then
            echo "Forcing session update before augmentation..."
            $EDAMAME_POSTURE_CMD get-sessions > /dev/null 2>&1 || true
            echo "Session update completed"
          fi
          
          # Create/augment whitelist from current sessions
          if [[ "$AUTO_WHITELIST_EXISTS" == "false" ]]; then
            # First run: create initial whitelist
            echo "First run: Creating initial whitelist from captured traffic..."
            $EDAMAME_POSTURE_CMD create-custom-whitelists > auto_whitelist_new.json
            
            # Save iteration count
            echo "1" > auto_whitelist_iteration.txt
            mv auto_whitelist_new.json auto_whitelist.json
            
            # Count endpoints with error handling
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' auto_whitelist.json 2>/dev/null || echo "0")
            echo "Initial whitelist created with $ENDPOINT_COUNT endpoints"
            
            if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
              echo "⚠️ Warning: Initial auto-whitelist is empty (no endpoints)"
              echo "This can happen if no network sessions were captured yet"
              echo "The whitelist will not be loaded automatically if empty"
            fi
            
            echo "AUTO_WHITELIST_STATUS=created" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
          else
            # Subsequent run: augment and check stability
            echo "Iteration $AUTO_WHITELIST_ITERATION: Augmenting whitelist..."
            $EDAMAME_POSTURE_CMD augment-custom-whitelists > auto_whitelist_new.json
            
            # Compare old and new whitelists
            DIFF_PERCENT=$($EDAMAME_POSTURE_CMD compare-custom-whitelists-from-files auto_whitelist.json auto_whitelist_new.json | sed 's/%//' || echo "100")
            echo "Whitelist difference: ${DIFF_PERCENT}%"
            echo "AUTO_WHITELIST_DIFF=$DIFF_PERCENT" >> $GITHUB_ENV
            
            # Check if this iteration is stable (below threshold)
            # Use bc for floating-point comparison if available, otherwise use integer comparison
            if command -v bc &> /dev/null; then
              IS_STABLE=$(echo "$DIFF_PERCENT <= ${{ inputs.auto_whitelist_stability_threshold }}" | bc -l)
            else
              # Fallback to integer comparison (convert to int)
              DIFF_INT=${DIFF_PERCENT%.*}
              THRESHOLD_INT=${{ inputs.auto_whitelist_stability_threshold }}
              THRESHOLD_INT=${THRESHOLD_INT%.*}
              [[ $DIFF_INT -le $THRESHOLD_INT ]] && IS_STABLE=1 || IS_STABLE=0
            fi
            
            if [[ "$IS_STABLE" == "1" ]]; then
              # Increment consecutive stable runs count
              STABLE_COUNT=$((AUTO_WHITELIST_STABLE_COUNT + 1))
              echo "$STABLE_COUNT" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
              
              echo "✅ Whitelist is STABLE for this run (diff: ${DIFF_PERCENT}% <= threshold: ${{ inputs.auto_whitelist_stability_threshold }}%)"
              echo "   Consecutive stable runs: $STABLE_COUNT / ${{ inputs.auto_whitelist_stability_consecutive_runs }} required"
              
              # Check if we have enough consecutive stable runs
              if [[ $STABLE_COUNT -ge ${{ inputs.auto_whitelist_stability_consecutive_runs }} ]]; then
                echo "🎉 Whitelist is FULLY STABLE ($STABLE_COUNT consecutive runs with no changes)"
                # Update iteration and whitelist even when fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                echo "AUTO_WHITELIST_STATUS=stable" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "🔄 Whitelist is stable for this run, but need more consecutive confirmations"
                # Update iteration and whitelist when stable but not fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                echo "AUTO_WHITELIST_STATUS=confirming_stability" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            else
              # Whitelist changed - reset consecutive stable count
              echo "🔄 Whitelist is EVOLVING (diff: ${DIFF_PERCENT}% > threshold: ${{ inputs.auto_whitelist_stability_threshold }}%)"
              echo "0" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
              
              NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
              echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
              mv auto_whitelist_new.json auto_whitelist.json
              
              # Check if max iterations reached
              if [[ $NEXT_ITERATION -ge ${{ inputs.auto_whitelist_max_iterations }} ]]; then
                echo "⚠️  Maximum iterations reached (${{ inputs.auto_whitelist_max_iterations }}), declaring stable"
                echo "AUTO_WHITELIST_STATUS=max_iterations" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "AUTO_WHITELIST_STATUS=evolving" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            fi
          fi
        fi
        
        # Regular dump sessions log
        if [[ "${{ inputs.dump_sessions_log }}" == "true" ]]; then
          ARGS=(get-sessions)

          if [[ "${{ inputs.exit_on_whitelist_exceptions }}" == "true" ]]; then
            ARGS+=(--fail-on-whitelist)
          fi

          if [[ "${{ inputs.exit_on_blacklisted_sessions }}" == "true" ]]; then
            ARGS+=(--fail-on-blacklist)
          fi

          if [[ "${{ inputs.exit_on_anomalous_sessions }}" == "true" ]]; then
            ARGS+=(--fail-on-anomalous)
          fi

          # In auto-whitelist mode with stable whitelist, enforce violations
          if [[ "${{ inputs.auto_whitelist }}" == "true" && "$AUTO_WHITELIST_STABLE" == "true" ]]; then
            echo "Auto-whitelist is stable, enforcing whitelist violations"
            ARGS+=(--fail-on-whitelist)
          fi

          $EDAMAME_POSTURE_CMD "${ARGS[@]}"
        fi
      shell: bash

    - name: Display logs if requested
      run: |
        if [[ "${{ inputs.display_logs }}" == "true" ]]; then
          # Rather scan the home directory for logs in case the dameon has been killed
          cd
          #$EDAMAME_POSTURE_CMD logs
          find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
        fi
      shell: bash

    - name: Upload auto-whitelist artifact
      if: ${{ inputs.auto_whitelist == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.auto_whitelist_artifact_name }}
        path: |
          ~/auto_whitelist.json
          ~/auto_whitelist_iteration.txt
          ~/auto_whitelist_stable_count.txt
        retention-days: 90
        overwrite: true
        if-no-files-found: warn

    - name: Display auto-whitelist status
      if: ${{ inputs.auto_whitelist == 'true' }}
      run: |
        cd
        echo ""
        echo "=== Auto-whitelist Status ==="
        echo "Iteration: $AUTO_WHITELIST_ITERATION"
        echo "Status: $AUTO_WHITELIST_STATUS"
        echo "Stable: $AUTO_WHITELIST_STABLE"
        if [[ -n "$AUTO_WHITELIST_DIFF" ]]; then
          echo "Difference: ${AUTO_WHITELIST_DIFF}%"
        fi
        if [[ -n "$AUTO_WHITELIST_STABLE_COUNT" ]]; then
          echo "Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / ${{ inputs.auto_whitelist_stability_consecutive_runs }}"
        fi
        
        # Display summary
        if [[ "$AUTO_WHITELIST_STATUS" == "created" ]]; then
          echo ""
          echo "ℹ️  This was the first run in listen-only mode."
          echo "   Re-run the workflow to start refining the whitelist."
        elif [[ "$AUTO_WHITELIST_STATUS" == "evolving" ]]; then
          echo ""
          echo "🔄 Whitelist is still evolving (${AUTO_WHITELIST_DIFF}% change)."
          echo "   Consecutive stable runs reset to 0."
          echo "   Re-run the workflow to continue refinement."
        elif [[ "$AUTO_WHITELIST_STATUS" == "confirming_stability" ]]; then
          echo ""
          echo "🔄 Whitelist had no changes this run (${AUTO_WHITELIST_DIFF}%)."
          echo "   Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / ${{ inputs.auto_whitelist_stability_consecutive_runs }}"
          echo "   Re-run the workflow to confirm stability."
        elif [[ "$AUTO_WHITELIST_STATUS" == "stable" ]]; then
          echo ""
          echo "✅ Whitelist has stabilized!"
          echo "   Achieved $AUTO_WHITELIST_STABLE_COUNT consecutive runs with no changes."
          echo "   Future runs will enforce this whitelist and fail on violations."
        elif [[ "$AUTO_WHITELIST_STATUS" == "max_iterations" ]]; then
          echo ""
          echo "⚠️  Maximum iterations reached."
          echo "   Whitelist declared stable. Future runs will enforce this whitelist."
        fi
      shell: bash

    - name: Stop EDAMAME Posture process if requested
      run: |
        if [[ "${{ inputs.stop }}" == "true" ]]; then
          cd
          echo "Stopping EDAMAME Posture process..."
          $EDAMAME_POSTURE_CMD stop
          echo "EDAMAME Posture process stopped."
        fi
      shell: bash

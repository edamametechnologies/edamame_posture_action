name: "Setup EDAMAME Posture"
description: "Download and control EDAMAME Posture"
inputs:
  edamame_user:
    description: "EDAMAME user (required to start the process in the background)"
    required: false
  edamame_domain:
    description: "EDAMAME domain (required to start the process in the background)"
    required: false
  edamame_pin:
    description: "EDAMAME PIN (required to start the process in the background)"
    required: false
  edamame_id:
    description: "EDAMAME identifier suffix (required to start the process in the background)"
    required: false
  edamame_policy:
    description: "EDAMAME policy name that the device must comply with (the action will fail if the device does not comply)"
    required: false
  edamame_minimum_score:
    description: "Minimum score that the device must achieve (the action will fail if the device does not achieve the minimum score)"
    required: false
  edamame_mandatory_threats:
    description: "Comma separated list of mandatory threats that the device must not exhibit (the action will fail if the device does not detect the threats)"
    required: false
  edamame_mandatory_prefixes:
    description: "Comma separated list of mandatory tag prefixes covering threats that the device must not exhibit (the action will fail if the device does not have the prefixes)"
    required: false
  auto_remediate:
    description: "Automatically remediate posture issues"
    required: false
    default: "false"
  skip_remediations:
    description: "Remediations to skip when performing auto-remediations (comma separated)"
    required: false
  network_scan:
    description: "Scan network for critical devices (only applicable if the background process is started)"
    required: false
    default: "false"
  packet_capture:
    description: "Capture network traffic (auto = follow network_scan)"
    required: false
    default: "auto"
  check_whitelist:
    description: "Report and enforce whitelist exceptions when capturing network traffic (requires a whitelist name)"
    required: false
    default: "false"
  check_blacklist:
    description: "Report and enforce blacklist matches during network capture"
    required: false
    default: "true"
  check_anomalous:
    description: "Report and enforce anomalous session detection during network capture"
    required: false
    default: "true"
  cancel_on_violation:
    description: "Attempt to cancel the current CI pipeline when violations are detected"
    required: false
    default: "false"
  disconnected_mode:
    description: "Start EDAMAME Posture in disconnected mode without requiring domain authentication"
    required: false
    default: "false"
  dump_sessions_log:
    description: "Dump sessions log (requires background process with packet capture enabled)"
    required: false
    default: "false"
  checkout:
    description: "Checkout the repo through the git CLI (retry if access is not granted)"
    required: false
    default: "false"
  checkout_submodules:
    description: "Checkout submodules"
    required: false
    default: "false"
  wait_for_https:
    description: "Wait for https access to the repo be granted"
    required: false
    default: "false"
  wait:
    description: "Wait for a while for access to be granted"
    required: false
    default: "false"
  wait_for_api:
    description: "Wait for API access to be granted"
    required: false
    default: "false"
  token:
    description: "GitHub token to checkout the repo"
    required: false
    default: ${{ github.token }}
  whitelist:
    description: "Whitelist to use for the network scan (only applicable if the background process is started)"
    required: false
    default: ""
  exit_on_whitelist_exceptions:
    description: "Exit with error when whitelist exceptions are detected (directly passed to get-sessions)"
    required: false
    default: "true"
  exit_on_blacklisted_sessions:
    description: "Exit with error when blacklisted sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  exit_on_anomalous_sessions:
    description: "Exit with error when anomalous sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  report_email:
    description: "Report email address"
    required: false
    default: ""
  create_custom_whitelists:
    description: "Create custom whitelists from captured network sessions and save it to the specified path"
    required: false
    default: "false"
  custom_whitelists_path:
    description: "Path to save or load custom whitelists JSON (used with create_custom_whitelists or to provide a whitelist file to apply)"
    required: false
    default: ""
  set_custom_whitelists:
    description: "Apply custom whitelists from a file specified in custom_whitelists_path"
    required: false
    default: "false"
  augment_custom_whitelists:
    description: "Augment the existing custom whitelists using current network sessions and merge the result back into the file specified by custom_whitelists_path. Requires network_scan=true."
    required: false
    default: "false"
  auto_whitelist:
    description: |
      Enable auto-whitelist mode: first run is listen-only, subsequent runs refine whitelist until stable.
      Requires disconnected_mode=true, network_scan=true, packet_capture=true.
      
      Usage pattern (two-invocation):
      1. First invocation: Setup with auto_whitelist=true (starts daemon, applies whitelist)
      2. Do work: Generate traffic (daemon captures in background)
      3. Second invocation: dump_sessions_log=true (augments whitelist, uploads artifact)
      
      The action automatically handles both phases when called twice in the same job.
    required: false
    default: "false"
  auto_whitelist_artifact_name:
    description: "Name for the GitHub artifact to store auto-whitelist state (default: edamame-auto-whitelist)"
    required: false
    default: "edamame-auto-whitelist"
  auto_whitelist_stability_threshold:
    description: "Percentage threshold for whitelist stability (default: 0% - no new endpoints)"
    required: false
    default: "0"
  auto_whitelist_stability_consecutive_runs:
    description: "Number of consecutive runs with no changes required for stability (default: 3)"
    required: false
    default: "3"
  auto_whitelist_max_iterations:
    description: "Maximum number of auto-whitelist iterations before declaring stable (default: 10)"
    required: false
    default: "20"
  include_local_traffic:
    description: "Include local traffic in network capture and session logs"
    required: false
    default: "false"
  agentic_mode:
    description: "AI assistant mode for automated security todo processing: auto (execute), analyze (recommendations only), or disabled"
    required: false
    default: "disabled"
  agentic_provider:
    description: "LLM provider for AI assistant: claude, openai, ollama, or none (requires EDAMAME_LLM_API_KEY environment variable)"
    required: false
    default: ""
  agentic_interval:
    description: "Interval in seconds for automated AI assistant todo processing"
    required: false
    default: "3600"
  stop:
    description: "Stop the EDAMAME Posture process"
    required: false
    default: "false"
  display_logs:
    description: "Display logs"
    required: false
    default: "false"
  debug:
    description: "Debug mode"
    required: false
    default: "false"

runs:
  using: "composite"

  steps:
    - name: Dependencies
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          cd
          # Install gh, wget, curl, jq using Chocolatey if not already installed
          if ! choco list | grep -E '^gh[[:space:]]'; then
            echo "Installing gh..."
            choco install gh -y
          fi

          if ! choco list | grep -E '^wget[[:space:]]'; then
            echo "Installing wget..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install wget -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^curl[[:space:]]'; then
            echo "Installing curl..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install curl -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^jq[[:space:]]'; then
            echo "Installing jq..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install jq -y | grep -v "Progress:"
          fi

          # Install node if not installed
          if ! choco list | grep -q '^nodejs[[:space:]]'; then
            echo "Installing nodejs..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install nodejs -y | grep -v "Progress:"
          fi

          # Install vcredist2015 if not installed
          if ! choco list | grep -q '^vcredist2015[[:space:]]'; then
            echo "Installing vcredist2015..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install vcredist2015 --package-parameters "/install /quiet /norestart" -y | grep -v "Progress:"
          fi
        elif [[ "$RUNNER_OS" == "Linux" ]]; then
          # Define function to wait for apt/dpkg locks
          wait_for_apt_locks() {
            echo "Checking for apt/dpkg locks..."
            TIMEOUT=300
            TIME_PASSED=0
            # Check common lock files
            LOCK_FILES=(
              "/var/lib/apt/lists/lock"
              "/var/lib/dpkg/lock-frontend"
              "/var/lib/dpkg/lock"
            )
            while sudo fuser "${LOCK_FILES[@]}" >/dev/null 2>&1; do
              echo "Waiting for apt/dpkg locks to be released..."
              sleep 5
              TIME_PASSED=$((TIME_PASSED + 5))
              if [ $TIME_PASSED -ge $TIMEOUT ]; then
                echo "Timed out waiting for apt/dpkg locks after $TIMEOUT seconds."
                exit 1
              fi
            done
            echo "No apt/dpkg locks held, proceeding..."
          }
          
          # Avoid prompts during apt-get install
          export DEBIAN_FRONTEND=noninteractive
          
          # Install sudo if needed
          if ! command -v sudo &> /dev/null; then
            echo "Installing sudo..."
            # Wait for apt lock before any operations
            wait_for_apt_locks
            apt-get update -y
            wait_for_apt_locks
            apt-get install -y --no-install-recommends sudo
            
            # Wait again after installing sudo
            wait_for_apt_locks
          fi          
          # Update package lists
          echo "Updating package lists..."
          wait_for_apt_locks
          sudo -E apt-get update

          # Check/install git
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            wait_for_apt_locks
            sudo -E apt-get install -y git
          fi

          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            wait_for_apt_locks
            (type -p wget >/dev/null || (wait_for_apt_locks; sudo -E apt-get update -y && wait_for_apt_locks && sudo -E apt-get install -y wget)) \
              && sudo mkdir -p -m 755 /etc/apt/keyrings \
                    && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \
                    && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null \
              && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && wait_for_apt_locks \
              && sudo -E apt-get update -y \
              && wait_for_apt_locks \
              && sudo -E apt-get install -y gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            wait_for_apt_locks
            sudo -E apt-get install -y wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            wait_for_apt_locks
            sudo -E apt-get install -y curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            wait_for_apt_locks
            sudo -E apt-get install -y jq
          fi

          # Check/install bc (needed for auto-whitelist floating-point comparisons)
          if ! command -v bc &> /dev/null; then
            echo "Installing bc..."
            wait_for_apt_locks
            sudo -E apt-get install -y bc
          fi

          # Check/install libpcap0.8t64
          if ! dpkg -s libpcap0.8t64 &> /dev/null; then
            echo "Installing libpcap0.8t64..."
            wait_for_apt_locks
            # Install libpcap0.8t64 if available, otherwise install libpcap0.8
            if ! sudo -E apt-get install -y libpcap0.8t64  &> /dev/null; then
              echo "Failed to install libpcap0.8t64, using libpcap0.8 instead"
              if ! dpkg -s libpcap0.8 &> /dev/null; then
                echo "Installing libpcap0.8..."
                wait_for_apt_locks
                sudo -E apt-get install -y libpcap0.8
              fi
            fi
          fi

          # Check/install build-essential
          if ! dpkg -s build-essential &> /dev/null; then
            echo "Installing build-essential..."
            wait_for_apt_locks
            sudo -E apt-get install -y build-essential
          fi

          # Check/install node + npm
          if ! command -v node &> /dev/null; then
            echo "Installing node + npm..."
            wait_for_apt_locks
            sudo -E apt-get install -y nodejs npm
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            brew install gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            brew install wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            brew install curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            brew install jq
          fi

          # Check/install node
          if ! command -v node &> /dev/null; then
            echo "Installing node..."
            brew install node
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi
      shell: bash

    - name: Download EDAMAME Posture binary
      id: download_binary
      run: |
        JQ=jq
        echo "jq version: $($JQ --version)"

        # --- Determine Latest Version via Redirect ---
        LATEST_VERSION=""
        echo "Attempting to get latest version via redirect..."
        REDIRECT_OUTPUT=$(curl -s -L -I -o /dev/null -w '%{url_effective}:%{http_code}' https://github.com/edamametechnologies/edamame_posture_cli/releases/latest)

        # Extract status code (part after the last colon) using bash parameter expansion
        HTTP_STATUS="${REDIRECT_OUTPUT##*:}"
        # Extract URL (part before the last colon and the status code) using bash parameter expansion
        LATEST_RELEASE_URL="${REDIRECT_OUTPUT%:$HTTP_STATUS}"

        echo "Redirect URL: $LATEST_RELEASE_URL"
        echo "HTTP Status: $HTTP_STATUS"

        if [[ "$HTTP_STATUS" == "200" && "$LATEST_RELEASE_URL" == *"/releases/tag/"* ]]; then
          LATEST_VERSION=$(basename "$LATEST_RELEASE_URL")
          LATEST_VERSION=${LATEST_VERSION#v} # Remove v prefix
          echo "Latest version found via redirect: $LATEST_VERSION"
        else
          echo "Failed to get latest version via redirect (Status: $HTTP_STATUS, URL: $LATEST_RELEASE_URL). Will try API fallback."
        fi

        # --- Determine Fallback Version via API ---
        API_FALLBACK_VERSION=""
        HARDCODED_FALLBACK_VERSION="0.9.60" # Define hardcoded fallback
        echo "Attempting to get fallback version via API..."
        WAIT_TIME=5
        for i in {1..3}; do # Limit retries
          FALLBACK_API_RESPONSE=$(curl -s https://api.github.com/repos/edamametechnologies/edamame_posture_cli/releases)
          
          # Check for rate limit first
          if echo "$FALLBACK_API_RESPONSE" | grep -qi "API rate limit exceeded"; then
            WAIT_TIME=$((WAIT_TIME * 2))
            if [[ $WAIT_TIME -gt 60 ]]; then WAIT_TIME=60; fi # Cap wait time
            echo "API rate limit exceeded for fallback, sleeping for $WAIT_TIME seconds (Attempt $i)"
            sleep $WAIT_TIME
          # If not rate limited, check if response is valid and has enough data
          elif echo "$FALLBACK_API_RESPONSE" | $JQ -e '. | length > 1' > /dev/null; then
            # Get the tag name of the second non-draft, non-prerelease release
            API_FALLBACK_VERSION=$($JQ -r '[.[] | select(.draft==false and .prerelease==false)][1].tag_name' <<< "$FALLBACK_API_RESPONSE")
            if [[ -n "$API_FALLBACK_VERSION" && "$API_FALLBACK_VERSION" != "null" ]]; then
                API_FALLBACK_VERSION=${API_FALLBACK_VERSION#v} # Remove v prefix
                echo "Fallback version found via API: $API_FALLBACK_VERSION"
                break # Success, exit loop
            else
                echo "Could not extract a valid second latest tag from API response (Attempt $i). JQ filter returned null or empty."
                # Log beginning of response for debugging
                echo "API Response (start): $(echo "$FALLBACK_API_RESPONSE" | head -c 100)..."
                API_FALLBACK_VERSION=""
                sleep 5 # Short sleep before retry on parsing error
            fi
          # If not rate limited and response is not valid/sufficient
          else 
            echo "Invalid API response for fallback (Attempt $i). Not rate limit, and not valid JSON or insufficient releases."
            # Log beginning of response for debugging
            echo "API Response (start): $(echo "$FALLBACK_API_RESPONSE" | head -c 100)..."
            API_FALLBACK_VERSION=""
            sleep 5 # Short sleep before retry on other errors
          fi
        done

        if [[ -z "$API_FALLBACK_VERSION" ]]; then
          echo "Failed to get fallback version from API after retries."
        fi

        # --- Set POSTURE_VERSION and POSTURE_FALLBACK_VERSION for Download ---
        if [[ -n "$LATEST_VERSION" ]]; then
          POSTURE_VERSION="$LATEST_VERSION"
          if [[ -n "$API_FALLBACK_VERSION" ]]; then
            POSTURE_FALLBACK_VERSION="$API_FALLBACK_VERSION"
          else
            echo "Using hardcoded fallback version as API fallback failed."
            POSTURE_FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          fi
        else
          # Latest version via redirect failed
          if [[ -n "$API_FALLBACK_VERSION" ]]; then
            echo "Using API fallback version as primary version."
            POSTURE_VERSION="$API_FALLBACK_VERSION"
            POSTURE_FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          else
            echo "Both redirect and API failed. Using hardcoded versions."
            POSTURE_VERSION="$HARDCODED_FALLBACK_VERSION"
            POSTURE_FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          fi
        fi

        echo "VERSION to download: $POSTURE_VERSION"
        echo "FALLBACK_VERSION to download: $POSTURE_FALLBACK_VERSION"

        # We only support edamame_posture installed in the current directory on Windows and macOS
        # Navigate to the home directory
        cd
        binary_present=false

        # If debug is true, we will not download the binary
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "Debug mode is enabled, using debug version of the binary"
          BIN_POSTFIX="-debug"
        else
          echo "Debug mode is disabled, using latest version of the binary"
          BIN_POSTFIX=""
        fi

        # On Linux we also provide a deb package to have it installed in /usr/bin
        if [[ "$RUNNER_OS" == "Linux" ]]; then
          if [[ -f edamame_posture || -f /usr/bin/edamame_posture ]]; then
            echo "Binary already present"
            binary_present=true
          else
            ARCH=$(uname -m)
            if [[ -f /etc/os-release ]]; then
              source /etc/os-release
            else
              echo "/etc/os-release not found. Cannot determine distribution."
              exit 1
            fi
            case "$ID" in
              "alpine")
                # Alpine Linux
                if [[ "$ARCH" == "x86_64" ]]; then
                  echo "Downloading Alpine Linux binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                else
                  echo "Downloading Alpine Linux ARM binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                fi
                ;;
              *)
                # Everything else (Amazon, Ubuntu, Debian, or any unknown distro)
                if [[ "$ARCH" == "x86_64" ]]; then
                  MIN_GLIBC_VERSION="2.29"
                  echo "Minimum required GLIBC version: $MIN_GLIBC_VERSION"
                  if command -v getconf >/dev/null 2>&1; then
                    echo "Using getconf to determine GLIBC version"
                    GLIBC_VERSION=$(getconf GNU_LIBC_VERSION | awk '{print $2}')
                    echo "Detected GLIBC version: $GLIBC_VERSION"
                    # Compare versions using sort
                    if printf '%s\n%s\n' "$MIN_GLIBC_VERSION" "$GLIBC_VERSION" | sort -V | head -n 1 | grep -q "$MIN_GLIBC_VERSION"; then
                      echo "GLIBC version $GLIBC_VERSION is sufficient (minimum required: $MIN_GLIBC_VERSION)"
                      echo "Downloading x86_64-unknown-linux-gnu version of EDAMAME Posture binary for Linux..."
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                    else
                      echo "Warning: GLIBC version $GLIBC_VERSION is older than minimum required version $MIN_GLIBC_VERSION"
                      echo "Fallback to using x86_64-unknown-linux-musl version of the binary"
                      echo "Downloading x86_64-unknown-linux-musl version of EDAMAME Posture binary for Linux..."
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                    fi
                  else
                    echo "Unable to detect GLIBC version, getconf command not found"
                    exit 1
                  fi
                  # echo "Downloading Gnu Linux binary..."
                elif [[ "$ARCH" == "i686" ]]; then
                  echo "Downloading Gnu Linux i686 binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                elif [[ "$ARCH" == "aarch64" ]]; then
                  echo "Downloading Gnu Linux ARM binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                elif [[ "$ARCH" == "armhf" ]]; then
                  echo "Downloading Gnu Linux ARM binary..."
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture || \
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture || \
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture
                else
                  echo "Unsupported architecture: $ARCH"
                  exit 1
                fi
            esac
            chmod u+x edamame_posture
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          if [[ -f edamame_posture ]]; then
            echo "Binary already present"
            binary_present=true
          else
            echo "Downloading EDAMAME Posture binary for macOS..."
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture
            chmod u+x edamame_posture
          fi
        elif [[ "$RUNNER_OS" == "Windows" ]]; then
          if [[ -f edamame_posture.exe ]]; then
            echo "Binary already present"
            binary_present=true
          else
            echo "Downloading EDAMAME Posture binary for Windows..."
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_VERSION}/edamame_posture-${POSTURE_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${POSTURE_FALLBACK_VERSION}/edamame_posture-${POSTURE_FALLBACK_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${HARDCODED_FALLBACK_VERSION}/edamame_posture-${HARDCODED_FALLBACK_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi

        # Set the output based on whether the binary was already present
        echo "binary_already_present=$binary_present" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set EDAMAME_POSTURE_CMD variable
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          EDAMAME_POSTURE_CMD="./edamame_posture.exe"
          echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
        else
          if command -v edamame_posture >/dev/null 2>&1; then
            EDAMAME_POSTURE_CMD="sudo edamame_posture"
            echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
          else
            EDAMAME_POSTURE_CMD="sudo ./edamame_posture"
            echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
          fi
        fi

        # Set log level to debug if debug mode is enabled
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "EDAMAME_LOG_LEVEL=debug" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Show initial posture
      run: |
        cd
        $EDAMAME_POSTURE_CMD score
      shell: bash

    - name: Auto remediate/harden posture issues if requested and if we are not running in a self-hosted runner (the binary is already present)
      run: |
        cd
        if [[ "${{ inputs.auto_remediate }}" == "true" && "${{ steps.download_binary.outputs.binary_already_present }}" == "false" ]]; then
          if [[ "${{ inputs.skip_remediations }}" == "" ]]; then
            echo "No remediations to skip"
            $EDAMAME_POSTURE_CMD remediate
          else
            echo "Skipping remediations: ${{ inputs.skip_remediations }}"
            $EDAMAME_POSTURE_CMD remediate "${{ inputs.skip_remediations }}"
          fi
        fi
      shell: bash

    - name: Report email
      run: |
        cd
        if [[ "${{ inputs.report_email }}" != "" ]]; then
          signature=$($EDAMAME_POSTURE_CMD request-signature | grep Signature | awk '{print $2}')
          echo "Signature: $signature"
          echo "Sending compliance report to email: ${{ inputs.report_email }}"
          $EDAMAME_POSTURE_CMD request-report "${{ inputs.report_email }}" "$signature"
        fi
      shell: bash

    - name: Check local policy compliance
      run: |
        cd
        # Check if minimum score and mandatory threats are provided. Mandatory prefixes are optional.
        if [[ -n "${{ inputs.edamame_minimum_score }}" ]]; then
          echo "Checking policy compliance with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
          
          # Capture the policy check output, also use prefix to check for mandatory threats
          policy_output=$($EDAMAME_POSTURE_CMD check-policy "${{ inputs.edamame_minimum_score }}" "${{ inputs.edamame_mandatory_threats }}" "${{ inputs.edamame_mandatory_prefixes }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
        fi
      shell: bash

    - name: Check domain policy compliance
      run: |
        cd
        # Check if both domain and policy are provided
        if [[ -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_policy }}" ]]; then
          echo "Checking policy compliance with domain: ${{ inputs.edamame_domain }} and policy: ${{ inputs.edamame_policy }}"
          
          # Capture the policy check output
          policy_output=$($EDAMAME_POSTURE_CMD check-policy-for-domain "${{ inputs.edamame_domain }}" "${{ inputs.edamame_policy }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy: ${{ inputs.edamame_policy }} and domain: ${{ inputs.edamame_domain }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy: ${{ inputs.edamame_policy }} and domain: ${{ inputs.edamame_domain }}"
        fi
      shell: bash

    - name: Wait for a while if requested
      run: |
        if [[ "${{ inputs.wait }}" == "true" ]]; then
          sleep 180
        fi
      shell: bash

    - name: Start EDAMAME Posture process and wait for connection if all arguments are provided, skip otherwise
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        cd
        # Check if all arguments are provided
        if [[ -n "${{ inputs.edamame_user }}" && -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_pin }}" && -n "${{ inputs.edamame_id }}" ]]; then
          if [[ "${{ steps.download_binary.outputs.binary_already_present }}" == "true" ]]; then
            echo "EDAMAME Posture binary is already present. Checking status..."
            # Continue even if there are errors; capture both stdout and stderr
            $EDAMAME_POSTURE_CMD status > posture_status.txt 2>&1 || true

            # Check if the output indicates Error getting connection status: transport error
            if grep -q "Error getting connection status: transport error" posture_status.txt; then
              echo "edamame_posture is installed but isn't connected"
            else
              connected="$({ grep -i 'connected:' posture_status.txt | awk -F': ' '{print $2}'; } || true)"
              connected="${connected:-false}"
              echo "edamame_posture is connected: $connected"
            fi

            # Compare with inputs
            if [[ "$connected" == "true" ]]; then
              echo "EDAMAME Posture is already running with the specified user and domain. Skipping start process."
              # Instead of exiting, use a variable to control the flow
              SKIP_START=true
            else
              # Linux 
              if [[ "$RUNNER_OS" == "Linux" ]]; then
                # We assume the edamame_posture service is installed
                echo "edamame_posture service is installed but isn't connected, please configure it properly in order to use this runner"
                exit 1
              elif [[ "$RUNNER_OS" == "macOS" ]]; then
                # There are no macOS edamame_posture service package yet, so we have to start the process in the background
                echo "edamame_posture service is installed but isn't connected, it will be automatically started in the background"
              elif [[ "$RUNNER_OS" == "Windows" ]]; then
                # There are no Windows edamame_posture service package yet, so we have to start the process in the background
                echo "edamame_posture service is installed but isn't connected, it will be automatically started in the background"
              fi
            fi
          fi

          # Only continue with the start process if we're not skipping it
          if [[ "$SKIP_START" != "true" ]]; then
            # Add a unique suffix to the edamame_id to avoid conflicts using matrix jobs
            # ms since epoch
            IDSUFFIX=$(node -e "console.log(Date.now())")

            START_ARGS=(
              start
              --user "${{ inputs.edamame_user }}"
              --domain "${{ inputs.edamame_domain }}"
              --pin "${{ inputs.edamame_pin }}"
              --device-id "${{ inputs.edamame_id }}_$IDSUFFIX"
            )

            if [[ "${{ inputs.network_scan }}" == "true" ]]; then
              START_ARGS+=(--network-scan)
            fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

            if [[ "${{ inputs.whitelist }}" != "" ]]; then
              START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
            fi

            if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
              START_ARGS+=(--fail-on-whitelist)
            fi

            if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
              START_ARGS+=(--fail-on-blacklist)
            fi

            if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
              START_ARGS+=(--fail-on-anomalous)
            fi

            if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
              START_ARGS+=(--cancel-on-violation)
            fi

            if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
              START_ARGS+=(--include-local-traffic)
            fi

            if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
              START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
            fi

            if [[ "${{ inputs.agentic_provider }}" != "" ]]; then
              START_ARGS+=(--agentic-provider "${{ inputs.agentic_provider }}")
            fi

            if [[ "${{ inputs.agentic_interval }}" != "" && "${{ inputs.agentic_interval }}" != "3600" ]]; then
              START_ARGS+=(--agentic-interval "${{ inputs.agentic_interval }}")
            fi

            echo "Starting EDAMAME Posture..."
            $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
            echo "Waiting for connection..."
            $EDAMAME_POSTURE_CMD wait-for-connection || { cd; find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"; exit 1; }
          fi
        elif [[ "${{ inputs.disconnected_mode }}" == "true" ]]; then
          echo "Starting EDAMAME Posture in disconnected mode..."
          
          # Stop any existing posture process before starting in disconnected mode
          # background-start-disconnected will fail with "Core services are already running" if posture is running
          echo "Stopping any existing EDAMAME Posture process before starting in disconnected mode..."
          $EDAMAME_POSTURE_CMD stop > /dev/null 2>&1 || echo "No existing posture process to stop (or stop failed, continuing anyway)..."
          # Give it a moment to fully stop
          sleep 2

          START_ARGS=(background-start-disconnected)

          if [[ "${{ inputs.network_scan }}" == "true" ]]; then
            START_ARGS+=(--network-scan)
          fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

          if [[ "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
          fi

          if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--fail-on-whitelist)
          fi

          if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
            START_ARGS+=(--fail-on-blacklist)
          fi

          if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
            START_ARGS+=(--fail-on-anomalous)
          fi

          if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
            START_ARGS+=(--cancel-on-violation)
          fi

          if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
            START_ARGS+=(--include-local-traffic)
          fi

          if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
            START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
          fi

          $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
        fi
      shell: bash

    - name: Detect auto-whitelist mode for second invocation
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if first invocation enabled auto-whitelist by looking for state files
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected from first invocation"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration from first invocation
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Loaded auto-whitelist configuration from first invocation:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found (first invocation didn't use auto_whitelist)"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for second invocation
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state from first invocation..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist from first invocation
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist from first invocation: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # CRITICAL: Verify whitelist was loaded into daemon by first invocation
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying whitelist is active in daemon (iteration $ITERATION)..."
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "❌ ERROR: Whitelist file exists but is NOT loaded in daemon"
              echo "   Expected: custom_whitelist"
              echo "   Got: $WHITELIST_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "The first invocation should have loaded the whitelist into the daemon."
              echo ""
              echo "Debugging info:"
              echo "  - Whitelist file: $(ls -lh auto_whitelist.json 2>/dev/null || echo 'missing')"
              echo "  - Iteration: $ITERATION"
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "✅ Whitelist 'custom_whitelist' confirmed active in daemon"
          fi
        else
          echo "⚠️ Warning: No auto-whitelist files found from first invocation"
          echo "This is unexpected - first invocation should have created these files"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Strategy 1: Try downloading from previous run ID directly (most reliable)
        # This works even if gh run list hasn't updated yet
        # Note: Run IDs are not sequential, so this might not find the actual previous run
        # But it's worth trying as a fast path
        PREVIOUS_RUN_ID=$((CURRENT_RUN_ID - 1))
        echo "Attempting to download artifact from previous run ID: $PREVIOUS_RUN_ID"
        
        # gh run download extracts artifacts to subdirectories, so we download to a temp dir first
        TEMP_DOWNLOAD_DIR=$(mktemp -d)
        DOWNLOAD_OUTPUT=$(gh run download "$PREVIOUS_RUN_ID" --repo ${{ github.repository }} --name "${{ inputs.auto_whitelist_artifact_name }}" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
        DOWNLOAD_EXIT=$?
        
        if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
          # Check if files were downloaded (they might be in a subdirectory)
          FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
          if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
            # Copy files to current directory
            cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
            # Also copy other expected files
            find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
              cp "$file" ./ 2>/dev/null || true
            done
            
            if [[ -f "auto_whitelist.json" ]]; then
              echo "✅ Successfully downloaded artifact from previous run $PREVIOUS_RUN_ID"
              ARTIFACT_FOUND=true
              rm -rf "$TEMP_DOWNLOAD_DIR"
            fi
          fi
        fi
        
        # Cleanup temp dir
        rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "⚠️ Artifact not found in previous run $PREVIOUS_RUN_ID, trying workflow list method..."
          
          # Strategy 2: Use gh run list to find recent successful runs
        WORKFLOW_NAME="${{ github.workflow }}"
        echo "Looking for runs in workflow name: $WORKFLOW_NAME"
        
        RUN_IDS=$(gh run list --workflow="$WORKFLOW_NAME" --repo ${{ github.repository }} --limit $MAX_ATTEMPTS --json databaseId,conclusion --jq ".[] | select(.conclusion == \"success\" and .databaseId != $CURRENT_RUN_ID) | .databaseId" 2>/dev/null || echo "")
        
        if [[ -z "$RUN_IDS" ]]; then
            echo "No previous successful runs found via workflow list"
        else
          echo "Found previous successful runs, attempting to download artifact..."
          for RUN_ID in $RUN_IDS; do
            echo "Attempting to download artifact from run $RUN_ID..."
            
            # Try to download the artifact from this specific run
            # gh run download extracts artifacts to subdirectories, so we download to a temp dir first
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            DOWNLOAD_OUTPUT=$(gh run download "$RUN_ID" --repo ${{ github.repository }} --name "${{ inputs.auto_whitelist_artifact_name }}" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
            DOWNLOAD_EXIT=$?
            
            if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
              # Check if files were downloaded (they might be in a subdirectory)
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                # Copy files to current directory
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                # Also copy other expected files
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "✅ Successfully downloaded artifact from run $RUN_ID"
                  ARTIFACT_FOUND=true
                  rm -rf "$TEMP_DOWNLOAD_DIR"
                  break
                fi
              fi
            fi
            
            # Cleanup temp dir
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
            
            if [[ "$ARTIFACT_FOUND" != "true" ]]; then
              echo "⚠️ Artifact not found in run $RUN_ID (this is normal if artifact doesn't exist)"
            fi
          done
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "ℹ️ No artifact found from previous runs"
          echo "This is expected for the first iteration"
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "✅ Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "✅ Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "⚠️ Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "⚠️ Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "✅ Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "⚠️ Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "❌ No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file for second invocation
        # This allows second invocation to infer parameters without repeating them
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration for second invocation..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "✅ Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "⚠️ Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "⚠️ Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode detected in first invocation"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "❌ ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "✅ Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "⚠️ Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "⚠️ Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "❌ ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "✅ Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "❌ ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "✅ Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "❌ ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Calculate difference (allow small differences for deduplication/filtering)
              DIFF=$((FILE_ENDPOINT_COUNT - DAEMON_ENDPOINT_COUNT))
              # Calculate absolute value
              if [[ "$DIFF" -lt 0 ]]; then
                ABS_DIFF=$((0 - DIFF))
              else
                ABS_DIFF=$DIFF
              fi
              
              if [[ "$DAEMON_ENDPOINT_COUNT" != "$FILE_ENDPOINT_COUNT" ]]; then
                if [[ "$ABS_DIFF" -le 2 ]]; then
                  # Small difference (1-2 endpoints) - likely deduplication or filtering
                  echo ""
                  echo "⚠️ Warning: Small endpoint count difference (daemon may have deduplicated/filtered)"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This is likely expected behavior - daemon may deduplicate or filter invalid endpoints."
                  echo "Continuing with daemon whitelist count: $DAEMON_ENDPOINT_COUNT"
                  echo "✅ Endpoint count verified (small difference acceptable): $DAEMON_ENDPOINT_COUNT endpoints"
                else
                  # Large difference - indicates real problem
                  echo ""
                  echo "❌ ERROR: Significant endpoint count mismatch between file and daemon!"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This indicates the whitelist was not loaded correctly into the daemon."
                  echo "Augmentation will fail or produce incorrect results."
                  echo ""
                  echo "Debugging info:"
                  echo "  - File: $WHITELIST_FILE"
                  echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                  echo "  - Daemon whitelist name: $LOADED_NAME"
                  echo "  - Daemon status:"
                  $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                  exit 1
                fi
              else
                echo "✅ Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints match exactly"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "❌ ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "✅ Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "❌ ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "✅ Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "❌ ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "❌ ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "✅ Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash

    - name: Augment existing custom whitelists if requested
      if: ${{ inputs.augment_custom_whitelists == 'true' }}
      run: |
        cd
        # Ensure a path is provided
        if [[ -z "${{ inputs.custom_whitelists_path }}" ]]; then
          echo "Error: augment_custom_whitelists requires custom_whitelists_path to be set."
          exit 1
        fi

        echo "Generating augmented whitelist from current sessions..."
        AUG_JSON=$($EDAMAME_POSTURE_CMD augment-custom-whitelists)

        if [[ -z "$AUG_JSON" ]]; then
          echo "Error: augment-custom-whitelists returned empty output"
          exit 1
        fi

        # Check if augmented whitelist has endpoints
        if command -v jq &> /dev/null; then
          ENDPOINT_COUNT=$(echo "$AUG_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
          echo "Augmented whitelist contains $ENDPOINT_COUNT endpoints"
          
          if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
            echo "⚠️ Warning: Augmented whitelist is empty (no endpoints)"
            echo "This can happen if:"
            echo "  - No baseline whitelist was loaded before augmentation (use set_custom_whitelists: true first)"
            echo "  - No network sessions were captured yet"
            echo "  - No whitelist exceptions (non-conforming sessions) exist to add"
            echo ""
            echo "Augmentation requires:"
            echo "  1. A baseline whitelist loaded into the system (via set_custom_whitelists)"
            echo "  2. Network sessions captured"
            echo "  3. Some non-conforming sessions to add as exceptions"
            exit 1
          fi
        fi

        echo "$AUG_JSON" > "${{ inputs.custom_whitelists_path }}"
        echo "Augmented whitelist saved to: ${{ inputs.custom_whitelists_path }}"
      shell: bash

    - name: Checkout the repo through the git CLI if requested
      run: |
        if [[ "${{ inputs.checkout }}" == "true" ]]; then
          timeout=true

          # Initialize the repo if it doesn't exist
          git init || true

          # Add the remote if it doesn't exist
          if git remote | grep -q '^origin$'; then
            git remote set-url origin https://x-access-token:${{ inputs.token }}@github.com/${{ github.repository }}.git || true
          else
            git remote add origin https://x-access-token:${{ inputs.token }}@github.com/${{ github.repository }}.git || true
          fi
          for i in {1..10}; do
            echo "Attempt $i: Checking out the repo through the git CLI..."
            if git fetch --depth=1 origin ${{ github.ref }}; then
              branch_name=$(echo "${{ github.ref }}" | sed -e "s/^refs\/heads\///")
              if git checkout -B "$branch_name" FETCH_HEAD; then
                if [[ "${{ inputs.checkout_submodules }}" == "true" ]]; then
                  git submodule update --init --recursive
                fi
                timeout=false
                break
              fi
            else
              echo "Checkout of the repo through the git CLI failed. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((i * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for access to the repo through the git CLI."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Checkout of the repo through the git CLI succeeded."
            echo "Time taken to checkout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."

            # Verify the checked out commit and branch
            echo "Checked out branch: $(git rev-parse --abbrev-ref HEAD)"
            echo "Checked out commit: $(git rev-parse HEAD)"
            if [ "$(git rev-parse HEAD)" != "${{ github.sha }}" ]; then
              echo "Warning: The checked out commit does not match the expected SHA."
              echo "Expected: ${{ github.sha }}"
              echo "Actual: $(git rev-parse HEAD)"
            fi
          fi
        fi
      shell: bash

    - name: Wait for API access to be granted if requested
      run: |
        if [[ "${{ inputs.wait_for_api }}" == "true" ]]; then
          attempts=0
          timeout=true
          for i in {1..10}; do
            attempts=$((attempts + 1))
            # We use the GitHub token to access the API using gh release list that requires authentication limited to the scope of the token
            if gh release list --repo ${{ github.repository }}; then
              timeout=false
              break
            else
              sleep 60
            fi
          done

          elapsed_time=$((attempts * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for API access."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "API access granted."
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Wait for https access to the repo be granted if requested
      run: |
        if [[ "${{ inputs.wait_for_https }}" == "true" ]]; then
          attempts=0
          timeout=true
          repo_url="https://github.com/${{ github.repository }}.git"

          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Checking https access to the repo..."
            status_code=$(curl -o /dev/null -s -w "%{http_code}" -H "Authorization: token ${{ inputs.token }}" $repo_url)

            if [[ "$status_code" == "301" || "$status_code" == "200" ]]; then
              timeout=false
              break
            else
              echo "https access to the repo not yet granted. Curl Status Code: $status_code. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((attempts * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for https access to the repo."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "https access to the repo granted."
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash

    - name: Create custom whitelists from network sessions if requested
      run: |
        if [[ "${{ inputs.create_custom_whitelists }}" == "true" ]]; then
          cd
          echo "Creating custom whitelists from active network sessions..."
          if [[ -n "${{ inputs.custom_whitelists_path }}" ]]; then
            # Save to the specified file
            $EDAMAME_POSTURE_CMD create-custom-whitelists > "${{ inputs.custom_whitelists_path }}"
            
            # Check if the created whitelist has endpoints
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Created whitelist contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "⚠️ Warning: Created whitelist is empty (no endpoints)"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet (wait longer before creating whitelist)"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - All sessions were filtered out"
                echo "The whitelist file was created but will not be loaded automatically if empty"
              fi
            fi
            
            echo "Custom whitelists saved to: ${{ inputs.custom_whitelists_path }}"
          else
            # Just display the whitelist JSON
            $EDAMAME_POSTURE_CMD create-custom-whitelists
          fi
        fi
      shell: bash

    - name: Create or augment auto-whitelist
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        
        # Use configuration from first invocation (via state file) or fallback to inputs
        THRESHOLD="${AUTO_WHITELIST_THRESHOLD:-${{ inputs.auto_whitelist_stability_threshold }}}"
        CONSECUTIVE="${AUTO_WHITELIST_CONSECUTIVE:-${{ inputs.auto_whitelist_stability_consecutive_runs }}}"
        MAX_ITER="${AUTO_WHITELIST_MAX_ITER:-${{ inputs.auto_whitelist_max_iterations }}}"
        
        echo "=== Auto-whitelist Mode: Processing Iteration $AUTO_WHITELIST_ITERATION ==="
        echo "Configuration: threshold=${THRESHOLD}%, consecutive=${CONSECUTIVE}, max=${MAX_ITER}"
        
        # CRITICAL: Verify daemon is ready BEFORE checking whitelist
        echo "Checking daemon readiness before augmentation..."
        if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
          echo "❌ ERROR: Daemon is not responding!"
          echo "Cannot proceed with augmentation - daemon must be running and ready."
          echo ""
          echo "Daemon status:"
          $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
          exit 1
        fi
        echo "✅ Daemon is ready"
        
        # CRITICAL: Verify daemon state before augmentation
        echo "Checking daemon whitelist state..."
        DAEMON_WHITELIST=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
        echo "Daemon whitelist: $DAEMON_WHITELIST"
        
        if [[ "$DAEMON_WHITELIST" != "custom_whitelist" && "$AUTO_WHITELIST_ITERATION" -gt 0 ]]; then
          echo ""
          echo "❌ ERROR: Daemon does not have custom_whitelist loaded!"
          echo "   Expected: custom_whitelist"
          echo "   Actual: $DAEMON_WHITELIST"
          echo ""
          echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
          echo "Without it, augmentation creates a fresh whitelist instead of merging with baseline."
          echo ""
          echo "The first invocation should have loaded the whitelist into the daemon."
          echo "This error indicates the first invocation failed to apply the whitelist correctly."
          echo ""
          echo "Debugging info:"
          echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
          echo "  - AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "  - Whitelist file: $(ls -lh auto_whitelist.json 2>/dev/null || echo 'missing')"
          echo "  - Whitelist file path: $(pwd)/auto_whitelist.json"
          echo "  - File exists: $([ -f "auto_whitelist.json" ] && echo 'yes' || echo 'no')"
          echo "  - Daemon status:"
          $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
          echo ""
          echo "CRITICAL: Cannot proceed with augmentation - whitelist must be loaded in first invocation."
          echo "Augmentation requires custom_whitelist to be active in the daemon."
          echo "Attempting to reload now would mask the root cause of the first invocation failure."
          echo ""
          echo "Fix: Ensure the first invocation successfully loads the whitelist into the daemon."
          exit 1
        fi
        
        echo "✅ Daemon has correct whitelist loaded for augmentation"
        
        # For subsequent runs, force session update before augmentation to ensure exceptions are populated
        if [[ "$AUTO_WHITELIST_EXISTS" == "true" ]]; then
          echo "Forcing session update before augmentation..."
          $EDAMAME_POSTURE_CMD get-sessions > /dev/null 2>&1 || true
          echo "Session update completed"
        fi
        
        # Create/augment whitelist from current sessions
        if [[ "$AUTO_WHITELIST_EXISTS" == "false" ]]; then
            # First run: create initial whitelist from captured traffic
            echo "First run: Creating initial whitelist from captured traffic..."
            echo "Calling: $EDAMAME_POSTURE_CMD create-custom-whitelists"
            
            if ! $EDAMAME_POSTURE_CMD create-custom-whitelists > auto_whitelist_new.json 2>&1; then
              echo ""
              echo "❌ ERROR: create-custom-whitelists command FAILED!"
              echo "   Exit code: $?"
              echo "   Command output:"
              cat auto_whitelist_new.json 2>/dev/null || echo "    (no output captured)"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "✅ Create command executed successfully"
            
            # Save iteration count
            echo "1" > auto_whitelist_iteration.txt
            mv auto_whitelist_new.json auto_whitelist.json
            
            # Count endpoints with error handling
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' auto_whitelist.json 2>/dev/null || echo "0")
            echo "Initial whitelist created with $ENDPOINT_COUNT endpoints"
            
            if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
              echo "⚠️ Warning: Initial auto-whitelist is empty (no endpoints)"
              echo "This can happen if no network sessions were captured yet"
              echo "The whitelist will not be loaded automatically if empty"
            fi
            
            echo "AUTO_WHITELIST_STATUS=created" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
          else
            # Subsequent run: augment and check stability
            # Note: augment-custom-whitelists handles empty baselines correctly by creating whitelist from exceptions
            echo "Iteration $AUTO_WHITELIST_ITERATION: Augmenting whitelist..."
            echo "Current daemon whitelist: $($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo 'unknown')"
            echo "Calling: $EDAMAME_POSTURE_CMD augment-custom-whitelists"
            
            # Capture stdout (JSON) and stderr separately
            # Only JSON should go to the file, stderr should be logged separately
            if ! $EDAMAME_POSTURE_CMD augment-custom-whitelists > auto_whitelist_new.json 2> augment_stderr.log; then
              echo ""
              echo "❌ ERROR: augment-custom-whitelists command FAILED!"
              echo "   Exit code: $?"
              echo ""
              echo "Command stderr output:"
              cat augment_stderr.log 2>/dev/null || echo "    (no stderr captured)"
              echo ""
              echo "Command stdout (JSON) output:"
              head -c 1000 auto_whitelist_new.json 2>/dev/null || echo "    (no stdout captured)"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "Current daemon whitelist:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            
            # Log stderr if any (for debugging)
            if [[ -s augment_stderr.log ]]; then
              echo "⚠️  Command stderr output (non-fatal):"
              cat augment_stderr.log
            fi
            
            echo "✅ Augment command executed successfully"
            
            # Verify output file was created
            if [[ ! -f "auto_whitelist_new.json" ]]; then
              echo "❌ ERROR: augment-custom-whitelists did not create output file!"
              exit 1
            fi
            
            # CRITICAL: Validate JSON structure and clean if needed
            # augment-custom-whitelists might output non-JSON text before the JSON
            if command -v jq &> /dev/null; then
              # Check if file is valid JSON
              if ! jq . auto_whitelist_new.json >/dev/null 2>&1; then
                echo "⚠️  Warning: Output file is not valid JSON, attempting to extract JSON..."
                # Try to extract JSON by finding the first { and using jq to parse from there
                mv auto_whitelist_new.json auto_whitelist_new.json.orig
                # Find line starting with { and extract everything from there
                # Use awk to find first line with { and print rest
                awk '/^\{/ {p=1} p' auto_whitelist_new.json.orig > auto_whitelist_new.json.tmp 2>/dev/null || {
                  # Fallback: try to extract JSON using jq's raw input
                  # jq can sometimes parse JSON even with leading text
                  jq -R 'fromjson?' auto_whitelist_new.json.orig 2>/dev/null | jq . > auto_whitelist_new.json.tmp 2>/dev/null || true
                }
                
                # Validate extracted JSON
                if jq . auto_whitelist_new.json.tmp >/dev/null 2>&1; then
                  mv auto_whitelist_new.json.tmp auto_whitelist_new.json
                  echo "✅ Extracted valid JSON from command output"
                else
                  echo "❌ ERROR: Cannot extract valid JSON from command output"
                  echo "First 1000 chars of output:"
                  head -c 1000 auto_whitelist_new.json.orig | cat -A
                  echo ""
                  echo "Attempting to show structure:"
                  head -20 auto_whitelist_new.json.orig | cat -A
                  exit 1
                fi
              else
                echo "✅ Output file is valid JSON"
              fi
            fi
            
            # CRITICAL: Count endpoints in old and new whitelists before comparison
            if command -v jq &> /dev/null; then
              OLD_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              NEW_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist_new.json" 2>/dev/null || echo "0")
              echo "Old whitelist (before augmentation): $OLD_ENDPOINT_COUNT endpoints"
              echo "New whitelist (after augmentation): $NEW_ENDPOINT_COUNT endpoints"
              
              if [[ "$NEW_ENDPOINT_COUNT" -eq 0 && "$OLD_ENDPOINT_COUNT" -gt 0 ]]; then
                echo ""
                echo "❌ ERROR: Augmentation resulted in empty whitelist!"
                echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                echo ""
                echo "This indicates augment-custom-whitelists failed to preserve baseline endpoints."
                echo "Debugging info:"
                echo "  - Old file size: $(wc -c < auto_whitelist.json) bytes"
                echo "  - New file size: $(wc -c < auto_whitelist_new.json) bytes"
                echo "  - New file first 500 chars:"
                head -c 500 auto_whitelist_new.json | cat -A || echo "    (cannot read file)"
                echo "  - New file JSON structure:"
                jq 'keys' auto_whitelist_new.json 2>/dev/null || echo "    (cannot parse)"
                echo "  - Whitelists in new file:"
                jq '.whitelists[]?.name' auto_whitelist_new.json 2>/dev/null || echo "    (cannot parse)"
                exit 1
              fi
            fi
            
            # Compare old and new whitelists
            DIFF_PERCENT=$($EDAMAME_POSTURE_CMD compare-custom-whitelists-from-files auto_whitelist.json auto_whitelist_new.json | sed 's/%//' || echo "100")
            echo "Whitelist difference: ${DIFF_PERCENT}%"
            echo "AUTO_WHITELIST_DIFF=$DIFF_PERCENT" >> $GITHUB_ENV
            
            # Check if this iteration is stable (below threshold)
            # Use bc for floating-point comparison if available, otherwise use integer comparison
            if command -v bc &> /dev/null; then
              IS_STABLE=$(echo "$DIFF_PERCENT <= $THRESHOLD" | bc -l)
            else
              # Fallback to integer comparison (convert to int)
              DIFF_INT=${DIFF_PERCENT%.*}
              THRESHOLD_INT=${THRESHOLD%.*}
              [[ $DIFF_INT -le $THRESHOLD_INT ]] && IS_STABLE=1 || IS_STABLE=0
            fi
            
            if [[ "$IS_STABLE" == "1" ]]; then
              # Increment consecutive stable runs count
              STABLE_COUNT=$((AUTO_WHITELIST_STABLE_COUNT + 1))
              echo "$STABLE_COUNT" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
              
              echo "✅ Whitelist is STABLE for this run (diff: ${DIFF_PERCENT}% <= threshold: ${THRESHOLD}%)"
              echo "   Consecutive stable runs: $STABLE_COUNT / $CONSECUTIVE required"
              
              # Check if we have enough consecutive stable runs
              if [[ $STABLE_COUNT -ge $CONSECUTIVE ]]; then
                echo "🎉 Whitelist is FULLY STABLE ($STABLE_COUNT consecutive runs with no changes)"
                # Update iteration and whitelist even when fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                
                # Verify final whitelist has endpoints
                if command -v jq &> /dev/null; then
                  FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                  echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
                fi
                
                echo "AUTO_WHITELIST_STATUS=stable" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "🔄 Whitelist is stable for this run, but need more consecutive confirmations"
                # Update iteration and whitelist when stable but not fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                
                # Verify final whitelist has endpoints
                if command -v jq &> /dev/null; then
                  FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                  echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
                fi
                
                echo "AUTO_WHITELIST_STATUS=confirming_stability" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            else
              # Whitelist changed - reset consecutive stable count
              echo "🔄 Whitelist is EVOLVING (diff: ${DIFF_PERCENT}% > threshold: ${THRESHOLD}%)"
              echo "0" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
              
              NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
              echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
              mv auto_whitelist_new.json auto_whitelist.json
              
              # Verify final whitelist has endpoints
              if command -v jq &> /dev/null; then
                FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
              fi
              
              # Check if max iterations reached
              if [[ $NEXT_ITERATION -ge $MAX_ITER ]]; then
                echo "⚠️  Maximum iterations reached ($MAX_ITER), declaring stable"
                echo "AUTO_WHITELIST_STATUS=max_iterations" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "AUTO_WHITELIST_STATUS=evolving" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            fi
          fi
      shell: bash
      env:
        EDAMAME_POSTURE_CMD: ${{ env.EDAMAME_POSTURE_CMD }}
        AUTO_WHITELIST_ITERATION: ${{ env.AUTO_WHITELIST_ITERATION }}
        AUTO_WHITELIST_EXISTS: ${{ env.AUTO_WHITELIST_EXISTS }}
        AUTO_WHITELIST_STABLE_COUNT: ${{ env.AUTO_WHITELIST_STABLE_COUNT }}
        AUTO_WHITELIST_THRESHOLD: ${{ env.AUTO_WHITELIST_THRESHOLD }}
        AUTO_WHITELIST_CONSECUTIVE: ${{ env.AUTO_WHITELIST_CONSECUTIVE }}
        AUTO_WHITELIST_MAX_ITER: ${{ env.AUTO_WHITELIST_MAX_ITER }}

    - name: Dump sessions log if requested
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        ARGS=(get-sessions)

        # Handle whitelist exception enforcement based on auto-whitelist mode
        if [[ "$AUTO_WHITELIST_ENABLED" == "true" ]]; then
          # Auto-whitelist mode: only enforce when stable
          if [[ "$AUTO_WHITELIST_STABLE" == "true" ]]; then
            echo "ℹ️  Auto-whitelist is STABLE - enforcing whitelist violations"
            echo "   Any whitelist exceptions will cause this step to fail"
            ARGS+=(--fail-on-whitelist)
          else
            echo "ℹ️  Auto-whitelist is LEARNING/EVOLVING - whitelist exceptions are expected"
            echo "   New endpoints will be discovered and added to the whitelist"
            echo "   This step will NOT fail on whitelist exceptions during learning"
            # Do NOT add --fail-on-whitelist during learning
          fi
        else
          # Manual mode: respect the exit_on_whitelist_exceptions input
        if [[ "${{ inputs.exit_on_whitelist_exceptions }}" == "true" ]]; then
          ARGS+=(--fail-on-whitelist)
          fi
        fi

        if [[ "${{ inputs.exit_on_blacklisted_sessions }}" == "true" ]]; then
          ARGS+=(--fail-on-blacklist)
        fi

        if [[ "${{ inputs.exit_on_anomalous_sessions }}" == "true" ]]; then
          ARGS+=(--fail-on-anomalous)
        fi

        # Execute get-sessions command
        # During auto-whitelist learning phases, non-zero exit codes are expected
        # (non-conforming sessions are being discovered and will be added to whitelist)
        if [[ "$AUTO_WHITELIST_ENABLED" == "true" && "$AUTO_WHITELIST_STABLE" != "true" ]]; then
          # Learning phase: capture exit code but don't fail
          echo "Executing: $EDAMAME_POSTURE_CMD ${ARGS[*]}"
          set +e  # Don't exit on error during learning phase
          $EDAMAME_POSTURE_CMD "${ARGS[@]}"
          EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo ""
            echo "ℹ️  Non-zero exit code ($EXIT_CODE) - this is expected during learning phase"
            echo "   Non-conforming sessions detected (ignoring during learning)"
            echo "   These sessions will be added to the whitelist via augmentation"
            echo "   This is normal behavior - whitelist is still evolving"
            echo ""
            # Don't exit - continue with augmentation
          else
            echo "✅ No whitelist exceptions detected"
          fi
        else
          # Stable phase or manual mode: fail on errors
        $EDAMAME_POSTURE_CMD "${ARGS[@]}"
        fi
      shell: bash
      env:
        EDAMAME_POSTURE_CMD: ${{ env.EDAMAME_POSTURE_CMD }}
        AUTO_WHITELIST_ENABLED: ${{ env.AUTO_WHITELIST_ENABLED }}
        AUTO_WHITELIST_STABLE: ${{ env.AUTO_WHITELIST_STABLE }}

    - name: Display logs if requested
      run: |
        if [[ "${{ inputs.display_logs }}" == "true" ]]; then
          # Rather scan the home directory for logs in case the dameon has been killed
          cd
          #$EDAMAME_POSTURE_CMD logs
          find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
        fi
      shell: bash

    - name: Upload auto-whitelist artifact
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.AUTO_WHITELIST_ARTIFACT_NAME || inputs.auto_whitelist_artifact_name }}
        path: |
          ~/auto_whitelist.json
          ~/auto_whitelist_iteration.txt
          ~/auto_whitelist_stable_count.txt
          ~/auto_whitelist_config.json
        retention-days: 90
        overwrite: true
        if-no-files-found: warn

    - name: Display auto-whitelist status
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo ""
        echo "=== Auto-whitelist Status ==="
        echo "Iteration: $AUTO_WHITELIST_ITERATION"
        echo "Status: $AUTO_WHITELIST_STATUS"
        echo "Stable: $AUTO_WHITELIST_STABLE"
        if [[ -n "$AUTO_WHITELIST_DIFF" ]]; then
          echo "Difference: ${AUTO_WHITELIST_DIFF}%"
        fi
        # Load configuration for display
        CONSECUTIVE="${AUTO_WHITELIST_CONSECUTIVE:-${{ inputs.auto_whitelist_stability_consecutive_runs }}}"
        
        if [[ -n "$AUTO_WHITELIST_STABLE_COUNT" ]]; then
          echo "Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / $CONSECUTIVE"
        fi
        
        # Display summary with enforcement status
        if [[ "$AUTO_WHITELIST_STATUS" == "created" ]]; then
          echo ""
          echo "ℹ️  This was the first run in listen-only mode."
          echo "   Whitelist exceptions are NORMAL and did NOT cause failure."
          echo "   Re-run the workflow to start refining the whitelist."
        elif [[ "$AUTO_WHITELIST_STATUS" == "evolving" ]]; then
          echo ""
          echo "🔄 Whitelist is still evolving (${AUTO_WHITELIST_DIFF}% change)."
          echo "   New endpoints were discovered and added to the whitelist."
          echo "   Whitelist exceptions are EXPECTED and did NOT cause failure."
          echo "   Consecutive stable runs reset to 0."
          echo "   Re-run the workflow to continue refinement."
        elif [[ "$AUTO_WHITELIST_STATUS" == "confirming_stability" ]]; then
          echo ""
          echo "🔄 Whitelist had no changes this run (${AUTO_WHITELIST_DIFF}%)."
          echo "   No new endpoints discovered - counting stable runs."
          echo "   Whitelist exceptions still allowed (NOT failing yet)."
          echo "   Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / $CONSECUTIVE"
          echo "   Re-run the workflow to confirm stability."
        elif [[ "$AUTO_WHITELIST_STATUS" == "stable" ]]; then
          echo ""
          echo "✅ Whitelist has stabilized!"
          echo "   Achieved $AUTO_WHITELIST_STABLE_COUNT consecutive runs with no changes."
          echo "   🚨 ENFORCEMENT ENABLED: Future runs will FAIL on whitelist violations."
          echo "   Any new endpoint will be treated as a potential supply chain attack."
        elif [[ "$AUTO_WHITELIST_STATUS" == "max_iterations" ]]; then
          echo ""
          echo "⚠️  Maximum iterations reached."
          echo "   Whitelist declared stable even though still evolving."
          echo "   🚨 ENFORCEMENT ENABLED: Future runs will FAIL on whitelist violations."
        fi
      shell: bash
      env:
        AUTO_WHITELIST_CONSECUTIVE: ${{ env.AUTO_WHITELIST_CONSECUTIVE }}

    - name: Stop EDAMAME Posture process if requested
      run: |
        if [[ "${{ inputs.stop }}" == "true" ]]; then
          cd
          echo "Stopping EDAMAME Posture process..."
          $EDAMAME_POSTURE_CMD stop
          echo "EDAMAME Posture process stopped."
        fi
      shell: bash

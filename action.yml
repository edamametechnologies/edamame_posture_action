name: "Setup EDAMAME Posture"
description: "Download and control EDAMAME Posture"
inputs:
  edamame_user:
    description: "EDAMAME user (required to start the process in the background)"
    required: false
  edamame_domain:
    description: "EDAMAME domain (required to start the process in the background)"
    required: false
  edamame_pin:
    description: "EDAMAME PIN (required to start the process in the background)"
    required: false
  edamame_id:
    description: "EDAMAME identifier suffix (required to start the process in the background)"
    required: false
  edamame_policy:
    description: "EDAMAME policy name that the device must comply with (the action will fail if the device does not comply)"
    required: false
  edamame_minimum_score:
    description: "Minimum score that the device must achieve (the action will fail if the device does not achieve the minimum score)"
    required: false
  edamame_mandatory_threats:
    description: "Comma separated list of mandatory threats that the device must not exhibit (the action will fail if the device does not detect the threats)"
    required: false
  edamame_mandatory_prefixes:
    description: "Comma separated list of mandatory tag prefixes covering threats that the device must not exhibit (the action will fail if the device does not have the prefixes)"
    required: false
  auto_remediate:
    description: "Automatically remediate posture issues"
    required: false
    default: "false"
  skip_remediations:
    description: "Remediations to skip when performing auto-remediations (comma separated)"
    required: false
    default: "remote login enabled,remote desktop enabled,local firewall disabled"
  network_scan:
    description: "Scan network for critical devices (only applicable if the background process is started)"
    required: false
    default: "false"
  packet_capture:
    description: "Capture network traffic (auto = follow network_scan)"
    required: false
    default: "auto"
  check_whitelist:
    description: "Report and enforce whitelist exceptions when capturing network traffic (requires a whitelist name)"
    required: false
    default: "false"
  check_blacklist:
    description: "Report and enforce blacklist matches during network capture"
    required: false
    default: "true"
  check_anomalous:
    description: "Report and enforce anomalous session detection during network capture"
    required: false
    default: "true"
  cancel_on_violation:
    description: "Attempt to cancel the current CI pipeline when violations are detected"
    required: false
    default: "false"
  cancel_pipeline_script:
    description: "Path to custom cancellation script (default: /tmp/cancel_pipeline.sh). Script receives violation reason as first argument."
    required: false
    default: ""
  disconnected_mode:
    description: "Start EDAMAME Posture in disconnected mode without requiring domain authentication"
    required: false
    default: "false"
  dump_sessions_log:
    description: "Dump sessions log (requires background process with packet capture enabled)"
    required: false
    default: "false"
  checkout:
    description: "Checkout the repo through the git CLI (retry if access is not granted)"
    required: false
    default: "false"
  checkout_submodules:
    description: "Checkout submodules"
    required: false
    default: "false"
  wait_for_https:
    description: "Wait for https access to the repo be granted"
    required: false
    default: "false"
  wait:
    description: "Wait for a while for access to be granted"
    required: false
    default: "false"
  wait_for_api:
    description: "Wait for API access to be granted"
    required: false
    default: "false"
  token:
    description: "GitHub token to checkout the repo"
    required: false
    default: ${{ github.token }}
  whitelist:
    description: "Whitelist to use for the network scan (only applicable if the background process is started)"
    required: false
    default: ""
  exit_on_whitelist_exceptions:
    description: "Exit with error when whitelist exceptions are detected (directly passed to get-sessions)"
    required: false
    default: "true"
  exit_on_blacklisted_sessions:
    description: "Exit with error when blacklisted sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  exit_on_anomalous_sessions:
    description: "Exit with error when anomalous sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  report_email:
    description: "Report email address"
    required: false
    default: ""
  create_custom_whitelists:
    description: "Create custom whitelists from captured network sessions and save it to the specified path"
    required: false
    default: "false"
  include_process_in_whitelist:
    description: "Include process names in whitelist entries for stricter matching. When enabled, connections from different processes to the same endpoint are treated separately."
    required: false
    default: "false"
  custom_whitelists_path:
    description: "Path to save or load custom whitelists JSON (used with create_custom_whitelists or to provide a whitelist file to apply)"
    required: false
    default: ""
  set_custom_whitelists:
    description: "Apply custom whitelists from a file specified in custom_whitelists_path"
    required: false
    default: "false"
  augment_custom_whitelists:
    description: "Augment the existing custom whitelists using current network sessions and merge the result back into the file specified by custom_whitelists_path. Requires network_scan=true."
    required: false
    default: "false"
  auto_whitelist:
    description: |
      Enable auto-whitelist mode: first run is listen-only, subsequent runs refine whitelist until stable.
      Requires packet_capture=true to capture traffic for comparison and wait_for_api=true to wait for the API to be ready.
      
      Usage pattern (two-invocation):
      1. First invocation: Setup with auto_whitelist=true (starts daemon, applies whitelist)
      2. Do work: Generate traffic (daemon captures in background)
      3. Second invocation: dump_sessions_log=true (augments whitelist, uploads artifact)
      
      The action automatically handles both phases when called twice in the same job.
    required: false
    default: "false"
  auto_whitelist_artifact_name:
    description: "Name for the GitHub artifact to store auto-whitelist state (default: edamame-auto-whitelist)"
    required: false
    default: "edamame-auto-whitelist"
  auto_whitelist_stability_threshold:
    description: "Percentage threshold for whitelist stability (default: 0% - no new endpoints)"
    required: false
    default: "0"
  auto_whitelist_stability_consecutive_runs:
    description: "Number of consecutive runs with no changes required for stability (default: 3)"
    required: false
    default: "3"
  auto_whitelist_max_iterations:
    description: "Maximum number of auto-whitelist iterations before declaring stable (default: 15)"
    required: false
    default: "15"
  auto_whitelist_state_artifact_name:
    description: "Name for the artifact storing auto-whitelist state (default: auto-whitelist-state)"
    required: false
    default: "auto-whitelist-state"
  auto_whitelist_promote_exceptions:
    description: |
      When true, automatically promote any whitelist exceptions to legitimate entries.
      Use this to add new endpoints to a stable whitelist without restarting learning.
      The whitelist remains stable after promotion.
    required: false
    default: "false"
  include_local_traffic:
    description: "Include local traffic in network capture and session logs"
    required: false
    default: "false"
  agentic_mode:
    description: "AI assistant mode for automated security todo processing: auto (execute), analyze (recommendations only), or disabled"
    required: false
    default: "disabled"
  agentic_provider:
    description: "LLM provider for AI assistant: edamame (recommended), claude, openai (all use EDAMAME_LLM_API_KEY env), ollama (uses EDAMAME_LLM_BASE_URL env), or none"
    required: false
    default: "none"
  agentic_interval:
    description: "Interval in seconds for automated AI assistant todo processing"
    required: false
    default: "3600"
  stop:
    description: "Stop the EDAMAME Posture process"
    required: false
    default: "false"
  display_logs:
    description: "Display logs"
    required: false
    default: "false"
  debug:
    description: "Debug mode"
    required: false
    default: "false"
  get_device_info:
    description: "Display device info including eBPF support status (Linux only)"
    required: false
    default: "false"
  verify_ebpf:
    description: "Verify eBPF is properly embedded in the binary. Fails if eBPF was not compiled in (build failure). Runtime restrictions (kernel settings, containers) are acceptable and won't fail. Implies get_device_info=true. (Linux only)"
    required: false
    default: "false"

outputs:
  ebpf_status:
    description: "eBPF support status: enabled, disabled_build, disabled_runtime, not_supported, or unknown"
    value: ${{ steps.device_info.outputs.ebpf_status }}
  ebpf_message:
    description: "Human-readable eBPF status message"
    value: ${{ steps.device_info.outputs.ebpf_message }}

runs:
  using: "composite"

  steps:
    - name: Dependencies
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          cd
          # Install gh, wget, curl, jq using Chocolatey if not already installed
          if ! choco list | grep -E '^gh[[:space:]]'; then
            echo "Installing gh..."
            choco install gh -y
          fi

          if ! choco list | grep -E '^wget[[:space:]]'; then
            echo "Installing wget..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install wget -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^curl[[:space:]]'; then
            echo "Installing curl..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install curl -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^jq[[:space:]]'; then
            echo "Installing jq..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install jq -y | grep -v "Progress:"
          fi

          # Install node if not installed
          if ! choco list | grep -q '^nodejs[[:space:]]'; then
            echo "Installing nodejs..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install nodejs -y | grep -v "Progress:"
          fi

          # Install vcredist2015 if not installed
          if ! choco list | grep -q '^vcredist2015[[:space:]]'; then
            echo "Installing vcredist2015..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install vcredist2015 --package-parameters "/install /quiet /norestart" -y | grep -v "Progress:"
          fi
        elif [[ "$RUNNER_OS" == "Linux" ]]; then
          # Check if this is Alpine Linux
          if command -v apk &> /dev/null || [ -f /etc/alpine-release ]; then
            echo "Detected Alpine Linux, using apk for dependencies..."
            
            # Install required packages with apk
            NEED_PACKAGE_INSTALL="false"
            command -v git &> /dev/null || NEED_PACKAGE_INSTALL="true"
            command -v curl &> /dev/null || NEED_PACKAGE_INSTALL="true"
            command -v wget &> /dev/null || NEED_PACKAGE_INSTALL="true"
            command -v jq &> /dev/null || NEED_PACKAGE_INSTALL="true"
            command -v node &> /dev/null || NEED_PACKAGE_INSTALL="true"
            command -v gh &> /dev/null || NEED_PACKAGE_INSTALL="true"
            
            if [[ "$NEED_PACKAGE_INSTALL" == "true" ]]; then
              echo "Installing missing tools via apk..."
              
              # Update apk cache if needed
              apk update 2>/dev/null || sudo apk update 2>/dev/null || true
              
              # Install packages (apk handles missing packages gracefully)
              APK_PACKAGES=""
              command -v git &> /dev/null || APK_PACKAGES="$APK_PACKAGES git"
              command -v curl &> /dev/null || APK_PACKAGES="$APK_PACKAGES curl"
              command -v wget &> /dev/null || APK_PACKAGES="$APK_PACKAGES wget"
              command -v jq &> /dev/null || APK_PACKAGES="$APK_PACKAGES jq"
              command -v node &> /dev/null || APK_PACKAGES="$APK_PACKAGES nodejs npm"
              command -v gh &> /dev/null || APK_PACKAGES="$APK_PACKAGES github-cli"
              
              if [[ -n "$APK_PACKAGES" ]]; then
                echo "Installing:$APK_PACKAGES"
                apk add --no-cache $APK_PACKAGES 2>/dev/null || sudo apk add --no-cache $APK_PACKAGES
              fi
            else
              echo "All required tools present on Alpine, skipping apk install"
            fi
          else
            # Debian/Ubuntu-based Linux
            # Define function to wait for apt/dpkg locks
          wait_for_apt_locks() {
            echo "Checking for apt/dpkg locks..."
            local TIMEOUT=300
            local TIME_PASSED=0
            local LOCK_FILES=(
              "/var/lib/apt/lists/lock"
              "/var/lib/dpkg/lock-frontend"
              "/var/lib/dpkg/lock"
              "/var/cache/apt/archives/lock"
            )
            
            while [ $TIME_PASSED -lt $TIMEOUT ]; do
              local LOCKED=false
              local HAS_LOCK_CHECKER=false
              
              # Method 1: Check with fuser if available
              if command -v fuser >/dev/null 2>&1; then
                HAS_LOCK_CHECKER=true
                for lock_file in "${LOCK_FILES[@]}"; do
                  if [ -f "$lock_file" ] && sudo fuser "$lock_file" >/dev/null 2>&1; then
                    LOCKED=true
                    echo "  Lock held: $lock_file (by process $(sudo fuser "$lock_file" 2>/dev/null))"
                    break
                  fi
                done
              fi
              
              # Method 2: Check with lsof as fallback
              if [ "$LOCKED" = "false" ] && command -v lsof >/dev/null 2>&1; then
                HAS_LOCK_CHECKER=true
                for lock_file in "${LOCK_FILES[@]}"; do
                  if [ -f "$lock_file" ] && sudo lsof "$lock_file" >/dev/null 2>&1; then
                    LOCKED=true
                    echo "  Lock held (lsof): $lock_file"
                    break
                  fi
                done
              fi
              
              # If no lock checker is available, just proceed
              # (apt will fail with a clear error if there's actually a lock)
              if [ "$HAS_LOCK_CHECKER" = "false" ]; then
                echo "No lock checker (fuser/lsof) available, proceeding..."
                return 0
              fi
              
              if [ "$LOCKED" = "false" ]; then
                echo "No apt/dpkg locks held, proceeding..."
                return 0
              fi
              
              echo "Waiting for apt/dpkg locks to be released... ($TIME_PASSED/${TIMEOUT}s)"
              sleep 5
              TIME_PASSED=$((TIME_PASSED + 5))
            done
            
            echo "Timed out waiting for apt/dpkg locks after $TIMEOUT seconds."
            return 1
          }
          
          export DEBIAN_FRONTEND=noninteractive
          apt_cmd_with_retry() {
            local max_attempts=10
            local delay_seconds=5
            local attempt=1
            local cmd=("$@")
            
            while true; do
              echo "Running: ${cmd[*]} (attempt $attempt/$max_attempts)"
              
              if ! wait_for_apt_locks; then
                echo "Failed to acquire locks, retrying..."
                sleep $delay_seconds
                attempt=$((attempt + 1))
                if (( attempt > max_attempts )); then
                  echo "Command failed after $max_attempts attempts: ${cmd[*]}"
                  return 1
                fi
                continue
              fi
              
              if "${cmd[@]}"; then
                return 0
              fi
              
              local exit_code=$?
              
              # Check if dpkg was interrupted
              if [ $exit_code -eq 100 ]; then
                echo "dpkg was interrupted, running dpkg --configure -a..."
                sudo dpkg --configure -a || true
              fi
              
              if (( attempt >= max_attempts )); then
                echo "Command failed after $max_attempts attempts: ${cmd[*]}"
                return $exit_code
              fi
              
              echo "Command failed with exit code $exit_code (attempt $attempt/$max_attempts). Retrying in $delay_seconds seconds..."
              sleep $delay_seconds
              attempt=$((attempt + 1))
            done
          }
          
          # Initial wait for any background apt processes (unattended-upgrades, etc.)
          echo "Waiting for any background apt processes to complete..."
          wait_for_apt_locks
          
          # Install sudo if needed
          if ! command -v sudo &> /dev/null; then
            echo "Installing sudo..."
            apt_cmd_with_retry apt-get install -y --no-install-recommends sudo
          fi          
          # Update package lists only if tools need to be installed
          # Skip on non-setup operations to avoid unnecessary lock contention
          NEED_PACKAGE_INSTALL="false"
          command -v git &> /dev/null || NEED_PACKAGE_INSTALL="true"
          command -v wget &> /dev/null || NEED_PACKAGE_INSTALL="true"
          command -v gh &> /dev/null || NEED_PACKAGE_INSTALL="true"
          command -v curl &> /dev/null || NEED_PACKAGE_INSTALL="true"
          command -v jq &> /dev/null || NEED_PACKAGE_INSTALL="true"
          command -v bc &> /dev/null || NEED_PACKAGE_INSTALL="true"
          command -v node &> /dev/null || NEED_PACKAGE_INSTALL="true"
          
          if [[ "$NEED_PACKAGE_INSTALL" == "true" ]]; then
            echo "Updating package lists (tools missing)..."
            apt_cmd_with_retry sudo -E apt-get update -y
          else
            echo "All required tools present, skipping apt update"
          fi

          # Check/install git
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            apt_cmd_with_retry sudo -E apt-get install -y git
          fi

          # Check/install wget (needed for GitHub CLI repository setup)
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            apt_cmd_with_retry sudo -E apt-get install -y wget
          fi

          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            sudo mkdir -p -m 755 /etc/apt/keyrings
            GH_KEY_TMP=$(mktemp)
            wget -nv -O "$GH_KEY_TMP" https://cli.github.com/packages/githubcli-archive-keyring.gpg
            sudo install -m 644 "$GH_KEY_TMP" /etc/apt/keyrings/githubcli-archive-keyring.gpg
            rm -f "$GH_KEY_TMP"
            sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            apt_cmd_with_retry sudo -E apt-get update -y
            apt_cmd_with_retry sudo -E apt-get install -y gh
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            apt_cmd_with_retry sudo -E apt-get install -y curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            apt_cmd_with_retry sudo -E apt-get install -y jq
          fi

          # Check/install bc (needed for auto-whitelist floating-point comparisons)
          if ! command -v bc &> /dev/null; then
            echo "Installing bc..."
            apt_cmd_with_retry sudo -E apt-get install -y bc
          fi


          # Check/install node + npm
          if ! command -v node &> /dev/null; then
            echo "Installing node + npm..."
            apt_cmd_with_retry sudo -E apt-get install -y nodejs npm
          fi
          fi  # Close Alpine detection if block
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            brew install gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            brew install wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            brew install curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            brew install jq
          fi

          # Check/install node
          if ! command -v node &> /dev/null; then
            echo "Installing node..."
            brew install node
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi
      shell: bash

    - name: Install or Update EDAMAME Posture
      id: install_posture
      shell: bash
      env:
        INSTALL_STATE_FILE: ${{ runner.temp }}/edamame_install_state
      run: |
        set -euo pipefail
        STATE_FILE="$INSTALL_STATE_FILE"
        INSTALL_ARGS=(--state-file "$STATE_FILE")
        
        # Only pass connection parameters on initial setup, not on subsequent operations
        # This prevents unnecessary daemon restarts when action is called for policy checks, etc.
        IS_INITIAL_SETUP="true"
        if [[ "${{ inputs.stop }}" == "true" || \
              "${{ inputs.dump_sessions_log }}" == "true" || \
              -n "${{ inputs.edamame_policy }}" || \
              -n "${{ inputs.edamame_minimum_score }}" || \
              "${{ inputs.create_custom_whitelists }}" == "true" || \
              "${{ inputs.augment_custom_whitelists }}" == "true" ]]; then
          IS_INITIAL_SETUP="false"
          echo "Detected non-setup operation - skipping credential pass to installer"
          echo "This prevents unnecessary daemon restarts that would lose captured sessions"
        fi
        
        # Add connection parameters only if this is initial setup
        if [[ "$IS_INITIAL_SETUP" == "true" ]]; then
          echo "Initial setup detected - passing credentials and network flags to installer"
          if [[ -n "${{ inputs.edamame_user }}" ]]; then
            INSTALL_ARGS+=(--user "${{ inputs.edamame_user }}")
          fi
          if [[ -n "${{ inputs.edamame_domain }}" ]]; then
            INSTALL_ARGS+=(--domain "${{ inputs.edamame_domain }}")
          fi
          if [[ -n "${{ inputs.edamame_pin }}" ]]; then
            INSTALL_ARGS+=(--pin "${{ inputs.edamame_pin }}")
          fi
          
          # Add device ID with timestamp suffix for uniqueness
          if [[ -n "${{ inputs.edamame_id }}" ]]; then
            IDSUFFIX=$(node -e "console.log(Date.now())")
            INSTALL_ARGS+=(--device-id "${{ inputs.edamame_id }}_${IDSUFFIX}")
          fi
          
          # Add network monitoring flags (only on initial setup to persist in service config)
          if [[ "${{ inputs.network_scan }}" == "true" ]]; then
            INSTALL_ARGS+=(--start-lanscan)
          fi
          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            INSTALL_ARGS+=(--start-capture)
          fi
        fi
        
        # Add whitelist configuration
        if [[ -n "${{ inputs.whitelist }}" ]]; then
          INSTALL_ARGS+=(--whitelist "${{ inputs.whitelist }}")
        fi
        if [[ "${{ inputs.check_whitelist }}" == "true" || -n "${{ inputs.whitelist }}" ]]; then
          INSTALL_ARGS+=(--fail-on-whitelist)
        fi
        if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
          INSTALL_ARGS+=(--fail-on-blacklist)
        fi
        if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
          INSTALL_ARGS+=(--fail-on-anomalous)
        fi
        if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
          INSTALL_ARGS+=(--cancel-on-violation)
          
          # Create cancellation script BEFORE install.sh runs
          # This ensures the script exists when install.sh starts the daemon (connected mode)
          # The same script is used for both connected and disconnected modes
          echo "[INFO] cancel_on_violation enabled - creating pipeline cancellation script"
          
          # Determine script path
          # The daemon runs with sudo (HOME=/root), so we need to create the script there
          if [[ -n "${{ inputs.cancel_pipeline_script }}" ]]; then
            CANCEL_SCRIPT_PATH="${{ inputs.cancel_pipeline_script }}"
          else
            # Use $HOME which matches the daemon's default lookup path
            # Since we use sudo -E, the daemon inherits the same HOME as the action
            CANCEL_SCRIPT_PATH="$HOME/cancel_pipeline.sh"
          fi
          
          echo "Creating cancellation script at: $CANCEL_SCRIPT_PATH"
          
          # Capture CI environment variables now (before sudo)
          CAPTURED_GITHUB_ACTIONS="${GITHUB_ACTIONS:-}"
          CAPTURED_GITHUB_RUN_ID="${GITHUB_RUN_ID:-}"
          CAPTURED_GITHUB_REPOSITORY="${GITHUB_REPOSITORY:-}"
          CAPTURED_GITHUB_TOKEN="${{ inputs.token }}"
          CAPTURED_GITLAB_CI="${GITLAB_CI:-}"
          CAPTURED_CI_PROJECT_ID="${CI_PROJECT_ID:-}"
          CAPTURED_CI_PIPELINE_ID="${CI_PIPELINE_ID:-}"
          CAPTURED_GITLAB_TOKEN="${GITLAB_TOKEN:-}"
          CAPTURED_CI_JOB_TOKEN="${CI_JOB_TOKEN:-}"
          
          # Create cancellation script using printf
          # Write to $HOME which is accessible by current user (no sudo needed)
          # Note: Uses POSIX sh for portability, syncs after each log write
          # Log file includes run ID for non-ephemeral runners
          printf '#!/bin/sh\n# EDAMAME Pipeline Cancellation Script\nGITHUB_ACTIONS="%s"\nGITHUB_RUN_ID="%s"\nGITHUB_REPOSITORY="%s"\nGITHUB_TOKEN="%s"\nGITLAB_CI="%s"\nCI_PROJECT_ID="%s"\nCI_PIPELINE_ID="%s"\nGITLAB_TOKEN="%s"\nCI_JOB_TOKEN="%s"\nif [ -n "$GITHUB_RUN_ID" ]; then\n  LOGFILE="$HOME/cancel_pipeline_${GITHUB_RUN_ID}.log"\nelif [ -n "$CI_PIPELINE_ID" ]; then\n  LOGFILE="$HOME/cancel_pipeline_${CI_PIPELINE_ID}.log"\nelse\n  LOGFILE="$HOME/cancel_pipeline.log"\nfi\nlog() { echo "$1" >> "$LOGFILE"; sync 2>/dev/null; echo "$1"; }\nlog ""\nlog "========================================"\nlog "EDAMAME Pipeline Cancellation Script"\nlog "Timestamp: $(date +%%Y-%%m-%%dT%%H:%%M:%%S)"\nlog "========================================"\nREASON="${1:-Policy violation detected}"\nlog "Reason: $REASON"\nlog "GITHUB_ACTIONS=$GITHUB_ACTIONS"\nlog "GITHUB_RUN_ID=$GITHUB_RUN_ID"\nlog "GITHUB_REPOSITORY=$GITHUB_REPOSITORY"\nlog "GITHUB_TOKEN length: ${#GITHUB_TOKEN}"\nlog "LOGFILE=$LOGFILE"\nif [ -n "$GITHUB_ACTIONS" ]; then\n  log "Detected GitHub Actions environment"\n  export GH_TOKEN="$GITHUB_TOKEN"\n  log "Executing: gh run cancel $GITHUB_RUN_ID --repo $GITHUB_REPOSITORY"\n  sync 2>/dev/null\n  if gh run cancel "$GITHUB_RUN_ID" --repo "$GITHUB_REPOSITORY" >> "$LOGFILE" 2>&1; then\n    log "[OK] Pipeline cancellation command succeeded"\n  else\n    log "[ERROR] Pipeline cancellation command failed with exit code: $?"\n  fi\nelif [ -n "$GITLAB_CI" ]; then\n  log "Detected GitLab CI environment"\n  TOKEN="${GITLAB_TOKEN:-$CI_JOB_TOKEN}"\n  curl -s -X POST -H "PRIVATE-TOKEN: $TOKEN" "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/pipelines/${CI_PIPELINE_ID}/cancel" >> "$LOGFILE" 2>&1\n  log "[OK] Pipeline cancellation command executed"\nelse\n  log "[ERROR] No CI environment detected"\n  exit 1\nfi\nlog "Script completed at: $(date +%%Y-%%m-%%dT%%H:%%M:%%S)"\nlog "========================================"\nsync 2>/dev/null\n' \
            "$CAPTURED_GITHUB_ACTIONS" "$CAPTURED_GITHUB_RUN_ID" "$CAPTURED_GITHUB_REPOSITORY" "$CAPTURED_GITHUB_TOKEN" \
            "$CAPTURED_GITLAB_CI" "$CAPTURED_CI_PROJECT_ID" "$CAPTURED_CI_PIPELINE_ID" "$CAPTURED_GITLAB_TOKEN" "$CAPTURED_CI_JOB_TOKEN" \
            > "$CANCEL_SCRIPT_PATH"
          
          chmod 700 "$CANCEL_SCRIPT_PATH"
          echo "[OK] Cancellation script created at $CANCEL_SCRIPT_PATH"
        fi
        if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
          INSTALL_ARGS+=(--include-local-traffic)
        fi
        
        # Add agentic mode configuration
        if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
          INSTALL_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
        fi
        if [[ "${{ inputs.agentic_provider }}" != "none" && "${{ inputs.agentic_provider }}" != "" ]]; then
          INSTALL_ARGS+=(--agentic-provider "${{ inputs.agentic_provider }}")
          # Log which provider is being used
          case "${{ inputs.agentic_provider }}" in
            edamame)
              echo "[OK] Using EDAMAME Portal LLM (requires EDAMAME_API_KEY env var)"
              ;;
            claude|openai)
              echo "[OK] Using BYOLLM provider: ${{ inputs.agentic_provider }} (requires EDAMAME_LLM_API_KEY env var)"
              ;;
            ollama)
              echo "[OK] Using local Ollama (requires EDAMAME_LLM_BASE_URL env var)"
              ;;
          esac
        fi
        if [[ "${{ inputs.agentic_interval }}" != "3600" && -n "${{ inputs.agentic_interval }}" ]]; then
          INSTALL_ARGS+=(--agentic-interval "${{ inputs.agentic_interval }}")
        fi
        
        # Add debug build flag
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          INSTALL_ARGS+=(--debug-build)
        fi
        
        # Platform-specific flags
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          INSTALL_ARGS+=(--install-dir "$HOME")
        fi
        
        echo "Running installer with args: ${INSTALL_ARGS[*]}"
        INSTALL_SCRIPT_REF="v0.9.82"
        RELEASE_API="https://api.github.com/repos/edamametechnologies/edamame_posture_cli/releases?per_page=2"
        echo "Determining latest installer release from: $RELEASE_API"
        if command -v curl >/dev/null 2>&1; then
          LATEST_JSON=$(curl -fsSL "$RELEASE_API" 2>/dev/null || true)
        elif command -v wget >/dev/null 2>&1; then
          LATEST_JSON=$(wget -q -O - "$RELEASE_API" 2>/dev/null || true)
        else
          LATEST_JSON=""
        fi
        if [[ -n "$LATEST_JSON" ]]; then
          LATEST_TAG=$(awk -F\" '
            /"tag_name"[[:space:]]*:/ {
              tag=$4
              gsub(/^v/, "", tag)
              if (tag != "") {
                print "v" tag
                exit
              }
            }
          ' <<< "$LATEST_JSON")
          if [[ -n "$LATEST_TAG" ]]; then
            INSTALL_SCRIPT_REF="$LATEST_TAG"
          fi
        fi
        echo "Using installer reference: $INSTALL_SCRIPT_REF"
        
        # Download with retry logic for transient errors (502, 503, 504, 429, connection errors)
        download_file_with_retry() {
          local url="$1"
          local destination="$2"
          local max_retries=5
          local retry_delay=2
          local attempt=1
          
          while [ $attempt -le $max_retries ]; do
            echo "  Download attempt $attempt/$max_retries..."
            local http_code=""
            local exit_code=0
            
            if command -v curl >/dev/null 2>&1; then
              # Don't use -f so we can capture the actual HTTP code
              # -s: silent, -S: show errors, -L: follow redirects
              # -w: write HTTP code to stdout after content
              # -o: write content to file
              http_code=$(curl --proto '=https' --tlsv1.2 -sSL -w "%{http_code}" "$url" -o "$destination" 2>&1) || exit_code=$?
            elif command -v wget >/dev/null 2>&1; then
              # wget doesn't have easy HTTP code extraction, use --server-response
              if wget -q --server-response "$url" -O "$destination" 2>&1 | grep -q "200 OK"; then
                http_code="200"
              else
                exit_code=1
                # Try to extract status code from wget output
                http_code=$(wget -q --server-response "$url" -O /dev/null 2>&1 | awk '/HTTP\//{print $2}' | tail -1)
              fi
            else
              echo "  [ERROR] Neither curl nor wget available"
              return 1
            fi
            
            # Check for success (HTTP 2xx)
            case "$http_code" in
              2*)
                if [ -s "$destination" ]; then
                  echo "  [OK] Download succeeded (HTTP $http_code)"
                  return 0
                else
                  echo "  [WARN] HTTP $http_code but file is empty"
                fi
                ;;
            esac
            
            # Check if it's a retryable error
            local should_retry=false
            case "$http_code" in
              429)
                echo "  [WARN] HTTP 429 (Rate limited) - retryable"
                should_retry=true
                ;;
              500)
                echo "  [WARN] HTTP 500 (Internal server error) - retryable"
                should_retry=true
                ;;
              502)
                echo "  [WARN] HTTP 502 (Bad gateway) - retryable"
                should_retry=true
                ;;
              503)
                echo "  [WARN] HTTP 503 (Service unavailable) - retryable"
                should_retry=true
                ;;
              504)
                echo "  [WARN] HTTP 504 (Gateway timeout) - retryable"
                should_retry=true
                ;;
              000|"")
                echo "  [WARN] Connection failed (no HTTP response) - retryable"
                should_retry=true
                ;;
              4*)
                echo "  [ERROR] HTTP $http_code (Client error) - not retryable"
                ;;
              *)
                if [ $exit_code -ne 0 ]; then
                  echo "  [WARN] Download failed (exit code: $exit_code, HTTP: $http_code) - retryable"
                  should_retry=true
                else
                  echo "  [ERROR] HTTP $http_code - not retryable"
                fi
                ;;
            esac
            
            if [ "$should_retry" = "true" ] && [ $attempt -lt $max_retries ]; then
              echo "  Waiting ${retry_delay}s before retry..."
              sleep $retry_delay
              retry_delay=$((retry_delay * 2))  # Exponential backoff: 2s, 4s, 8s, 16s, 32s
              attempt=$((attempt + 1))
              rm -f "$destination"  # Clean up partial download
            else
              if [ "$should_retry" = "true" ]; then
                echo "  [ERROR] Max retries ($max_retries) exceeded"
              fi
              rm -f "$destination"
              return 1
            fi
          done
          
          return 1
        }
        
        # Simple download without retry (for fallbacks)
        download_file() {
          local url="$1"
          local destination="$2"
          if command -v curl >/dev/null 2>&1; then
            curl --proto '=https' --tlsv1.2 -fsSL "$url" -o "$destination"
          elif command -v wget >/dev/null 2>&1; then
            wget -q "$url" -O "$destination"
          else
            return 1
          fi
        }
        
        RELEASE_INSTALL_URL="https://github.com/edamametechnologies/edamame_posture_cli/releases/download/${INSTALL_SCRIPT_REF}/install.sh"
        # Raw URL uses main branch (install.sh is not tagged with releases)
        RAW_INSTALL_URL="https://raw.githubusercontent.com/edamametechnologies/edamame_posture_cli/main/install.sh"
        TMP_INSTALL_SCRIPT=$(mktemp)
        DOWNLOAD_SOURCE=""
        
        echo "Attempting to download installer from release asset: $RELEASE_INSTALL_URL"
        if download_file_with_retry "$RELEASE_INSTALL_URL" "$TMP_INSTALL_SCRIPT"; then
          DOWNLOAD_SOURCE="release"
        else
          echo "[WARNING] Failed to download installer from release asset after retries. Falling back to raw source."
          echo "Attempting to download from: $RAW_INSTALL_URL"
          if download_file_with_retry "$RAW_INSTALL_URL" "$TMP_INSTALL_SCRIPT"; then
            DOWNLOAD_SOURCE="raw"
          else
            echo "[ERROR] Unable to download installer from either release asset or raw source after retries."
            rm -f "$TMP_INSTALL_SCRIPT"
            exit 1
          fi
        fi
        echo "Installer downloaded from $DOWNLOAD_SOURCE source. Executing..."
        sh "$TMP_INSTALL_SCRIPT" "${INSTALL_ARGS[@]}"
        rm -f "$TMP_INSTALL_SCRIPT"
        if [[ ! -f "$STATE_FILE" ]]; then
          echo "[WARNING] Installer did not produce state file at $STATE_FILE; reconstructing from current system state."
          binary_path=$(command -v edamame_posture 2>/dev/null || echo "")
          if [[ -z "$binary_path" ]]; then
            echo "[ERROR] Unable to locate edamame_posture binary after installation."
            exit 1
          fi
          mkdir -p "$(dirname "$STATE_FILE")"
          {
            echo "binary_path=${binary_path}"
            echo "install_method=unknown"
            echo "installed_via_package_manager=unknown"
            echo "binary_already_present=false"
            if [[ "$RUNNER_OS" == "Linux" ]]; then
              echo "platform=linux"
            elif [[ "$RUNNER_OS" == "macOS" ]]; then
              echo "platform=macos"
            elif [[ "$RUNNER_OS" == "Windows" ]]; then
              echo "platform=windows"
            else
              echo "platform=$RUNNER_OS"
            fi
          } > "$STATE_FILE"
        fi
        echo "=== Installer State ==="
        cat "$STATE_FILE"
        # shellcheck disable=SC1090
        source "$STATE_FILE"
        echo "binary_already_present=${binary_already_present:-false}" >> "$GITHUB_OUTPUT"
        echo "installed_via_package_manager=${installed_via_package_manager:-false}" >> "$GITHUB_OUTPUT"
        echo "install_method=${install_method:-binary}" >> "$GITHUB_OUTPUT"
        echo "binary_path=${binary_path:-}" >> "$GITHUB_OUTPUT"

    - name: Set EDAMAME_POSTURE_CMD variable
      shell: bash
      run: |
        set -euo pipefail
        echo "=== Setting EDAMAME_POSTURE_CMD ==="
        echo "Install method: ${{ steps.install_posture.outputs.install_method }}"
        echo "Installed via package manager: ${{ steps.install_posture.outputs.installed_via_package_manager }}"
        BINARY_PATH="${{ steps.install_posture.outputs.binary_path }}"
        if [[ -z "$BINARY_PATH" ]]; then
          if command -v edamame_posture >/dev/null 2>&1; then
            BINARY_PATH=$(command -v edamame_posture)
          elif [[ -f "$HOME/edamame_posture" ]]; then
            BINARY_PATH="$HOME/edamame_posture"
          elif [[ -f "$HOME/edamame_posture.exe" ]]; then
            BINARY_PATH="$HOME/edamame_posture.exe"
          else
            echo "[ERROR] edamame_posture not found!"
            exit 1
          fi
        fi
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          EDAMAME_POSTURE_CMD="$BINARY_PATH"
        else
          # Determine how to run with elevated privileges while preserving environment
          # -E flag preserves environment variables for CI/CD detection
          # The daemon checks for GITHUB_ACTIONS, CI, GITLAB_CI, etc.
          if [[ $(id -u) -eq 0 ]]; then
            # Already root, no sudo needed
            EDAMAME_POSTURE_CMD="$BINARY_PATH"
          elif command -v sudo >/dev/null 2>&1; then
            # sudo available, use -E to preserve environment
            EDAMAME_POSTURE_CMD="sudo -E $BINARY_PATH"
          elif command -v doas >/dev/null 2>&1; then
            # doas available (Alpine, OpenBSD) - preserves env by default
            EDAMAME_POSTURE_CMD="doas $BINARY_PATH"
          else
            # No privilege escalation available, try direct execution
            echo "[WARNING] No sudo/doas available and not running as root"
            EDAMAME_POSTURE_CMD="$BINARY_PATH"
          fi
        fi
        echo "Using binary at: $BINARY_PATH"
        echo "EDAMAME_BINARY_PATH=$BINARY_PATH" >> $GITHUB_ENV
        echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "EDAMAME_LOG_LEVEL=debug" >> $GITHUB_ENV
          echo "Debug logging enabled"
        fi
        echo "EDAMAME_POSTURE_CMD set to: $EDAMAME_POSTURE_CMD"

    - name: Inspect edamame_posture service (if present)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        set -euo pipefail
        if command -v systemctl >/dev/null 2>&1 && [[ -d /run/systemd/system ]]; then
          echo "=== systemctl status edamame_posture ==="
          sudo systemctl status edamame_posture.service --no-pager || true
          SERVICE_USER=$(systemctl show -p User edamame_posture.service 2>/dev/null | cut -d'=' -f2)
          if [[ -z "$SERVICE_USER" ]]; then
            SERVICE_USER="root (default)"
          fi
          echo "Configured systemd service user: $SERVICE_USER"
        elif command -v rc-service >/dev/null 2>&1; then
          echo "=== rc-service edamame_posture status ==="
          sudo rc-service edamame_posture status || true
          echo "OpenRC services run as root by default (override via init script as needed)."
        else
          echo "systemd/OpenRC not detected (likely container without init); skipping service inspection."
        fi

    - name: Show initial posture
      run: |
        cd
        $EDAMAME_POSTURE_CMD score
      shell: bash

    - name: Get device info and verify eBPF support
      id: device_info
      if: ${{ inputs.get_device_info == 'true' || inputs.verify_ebpf == 'true' }}
      shell: bash
      run: |
        set -euo pipefail
        echo "=== Getting Device Info ==="
        
        # Get device info from the installed binary
        DEVICE_INFO=$($EDAMAME_POSTURE_CMD get-device-info 2>&1) || true
        echo "$DEVICE_INFO"
        echo ""
        
        # Extract eBPF support line - look for "eBPF support:" or "ebpf_support:" pattern
        # and grab only the value part (after the colon), trimming whitespace
        EBPF_LINE=$(echo "$DEVICE_INFO" | grep -iE "(eBPF support|ebpf_support)" | head -1 || echo "")
        # Extract just the status part after the colon (e.g., "Enabled: kernel 6.x..." or "Disabled: ...")
        EBPF_STATUS=$(echo "$EBPF_LINE" | sed 's/.*[Ss]upport[:"]*[[:space:]]*//' | tr -d '\n' || echo "")
        echo "=== eBPF Status ==="
        echo "$EBPF_STATUS"
        echo ""
        
        # Sanitize message for GitHub Actions output (remove newlines, escape special chars)
        sanitize_for_output() {
          echo "$1" | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g' | head -c 500
        }
        
        # Track if we should fail (only for verify_ebpf mode)
        SHOULD_FAIL=false
        
        # Determine eBPF status category
        if [[ "$RUNNER_OS" != "Linux" ]]; then
          echo "ebpf_status=not_supported" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=eBPF not supported on $RUNNER_OS" >> "$GITHUB_OUTPUT"
          echo "⏭️  eBPF not supported on $RUNNER_OS"
        elif echo "$EBPF_STATUS" | grep -q "Enabled:.*kprobe attached"; then
          echo "ebpf_status=enabled" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=$(sanitize_for_output "$EBPF_STATUS")" >> "$GITHUB_OUTPUT"
          echo "✅ eBPF is fully operational (kprobes attached)"
        elif echo "$EBPF_STATUS" | grep -q "not embedded"; then
          echo "ebpf_status=disabled_build" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=eBPF object not embedded (build failure)" >> "$GITHUB_OUTPUT"
          echo "❌ eBPF was NOT compiled into the binary (clang/llvm was not available at build time)"
          SHOULD_FAIL=true
        elif echo "$EBPF_STATUS" | grep -qE "unprivileged_bpf_disabled|container may lack|doesn't support kprobes|SYS_ADMIN|CAP_BPF|failed to load|failed to create"; then
          echo "ebpf_status=disabled_runtime" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=$(sanitize_for_output "$EBPF_STATUS")" >> "$GITHUB_OUTPUT"
          echo "⚠️  eBPF embedded but kernel restrictions prevent loading (acceptable)"
        elif echo "$EBPF_STATUS" | grep -q "Disabled:"; then
          echo "ebpf_status=disabled_runtime" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=$(sanitize_for_output "$EBPF_STATUS")" >> "$GITHUB_OUTPUT"
          echo "⚠️  eBPF disabled: $EBPF_STATUS (acceptable - runtime restriction)"
        elif echo "$EBPF_STATUS" | grep -q "Not supported"; then
          echo "ebpf_status=not_supported" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=eBPF not supported on this platform" >> "$GITHUB_OUTPUT"
          echo "⏭️  eBPF not supported on this platform"
        else
          echo "ebpf_status=unknown" >> "$GITHUB_OUTPUT"
          echo "ebpf_message=Could not determine eBPF status" >> "$GITHUB_OUTPUT"
          echo "⚠️  Could not determine eBPF status from: $EBPF_STATUS"
          # Unknown status with verify_ebpf should fail
          if [[ "${{ inputs.verify_ebpf }}" == "true" ]]; then
            SHOULD_FAIL=true
          fi
        fi
        
        # Fail if verify_ebpf is enabled and we detected a build failure
        if [[ "${{ inputs.verify_ebpf }}" == "true" && "$SHOULD_FAIL" == "true" ]]; then
          echo ""
          echo "::error::eBPF verification failed - binary was not built with eBPF support"
          exit 1
        fi

    - name: Auto remediate/harden posture issues if requested and if we are not running in a self-hosted runner (the binary is already present)
      run: |
        cd
        if [[ "${{ inputs.auto_remediate }}" == "true" && "${{ steps.install_posture.outputs.binary_already_present }}" == "false" ]]; then
          if [[ "${{ inputs.skip_remediations }}" == "" ]]; then
            echo "No remediations to skip"
            $EDAMAME_POSTURE_CMD remediate
          else
            echo "Skipping remediations: ${{ inputs.skip_remediations }}"
            $EDAMAME_POSTURE_CMD remediate "${{ inputs.skip_remediations }}"
          fi
        fi
      shell: bash

    - name: Report email
      run: |
        cd
        if [[ "${{ inputs.report_email }}" != "" ]]; then
          signature=$($EDAMAME_POSTURE_CMD request-signature | grep Signature | awk '{print $2}')
          echo "Signature: $signature"
          echo "Sending compliance report to email: ${{ inputs.report_email }}"
          $EDAMAME_POSTURE_CMD request-report "${{ inputs.report_email }}" "$signature"
        fi
      shell: bash

    - name: Check local policy compliance
      run: |
        cd
        # Check if minimum score and mandatory threats are provided. Mandatory prefixes are optional.
        if [[ -n "${{ inputs.edamame_minimum_score }}" ]]; then
          echo "Checking policy compliance with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
          
          # Capture the policy check output, also use prefix to check for mandatory threats
          policy_output=$($EDAMAME_POSTURE_CMD check-policy "${{ inputs.edamame_minimum_score }}" "${{ inputs.edamame_mandatory_threats }}" "${{ inputs.edamame_mandatory_prefixes }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
        fi
      shell: bash

    - name: Check domain policy compliance
      run: |
        cd
        # Check if both domain and policy are provided
        if [[ -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_policy }}" ]]; then
          POLICY_NAME="${{ inputs.edamame_policy }}"
          DOMAIN_NAME="${{ inputs.edamame_domain }}"
          
          echo "Checking policy compliance with domain: $DOMAIN_NAME and policy: $POLICY_NAME"
          
          # Capture the policy check output - use variables to avoid shell interpretation issues
          policy_output=$($EDAMAME_POSTURE_CMD check-policy-for-domain "$DOMAIN_NAME" "$POLICY_NAME")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy: $POLICY_NAME and domain: $DOMAIN_NAME"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy: $POLICY_NAME and domain: $DOMAIN_NAME"
        fi
      shell: bash

    - name: Wait for EDAMAME Posture connection
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' && inputs.disconnected_mode != 'true' }}
      run: |
        cd
        # Note: Daemon/service is now started by install.sh with all parameters
        # This step only waits for connection when credentials are provided
        
        echo "Waiting for EDAMAME Posture to connect..."
        if [[ -n "${{ inputs.edamame_user }}" && -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_pin }}" ]]; then
          # On Windows, set a timeout of 1200 seconds instead of the default 900 seconds
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            $EDAMAME_POSTURE_CMD wait-for-connection 1200 || { cd; find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"; exit 1; }
          else
            $EDAMAME_POSTURE_CMD wait-for-connection || { cd; find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"; exit 1; }
          fi
        else
          echo "No connection parameters provided, skipping connection wait"
        fi
      shell: bash
    
    - name: Start EDAMAME Posture in disconnected mode if requested
      if: ${{ inputs.disconnected_mode == 'true' && inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        cd
        if [[ "${{ inputs.disconnected_mode }}" == "true" ]]; then
          echo "Starting EDAMAME Posture in disconnected mode..."
          
          # Stop any existing posture process before starting in disconnected mode
          # This handles cases where disconnected mode is called multiple times or after connected mode
          echo "Stopping any existing EDAMAME Posture process..."
          
          # Try to stop via CLI first
          $EDAMAME_POSTURE_CMD stop > /dev/null 2>&1 || true
          
          # On Linux, also ensure systemd service is stopped (in case it was started manually)
          if [[ "$RUNNER_OS" == "Linux" ]] && command -v systemctl >/dev/null 2>&1; then
          sudo systemctl stop edamame_posture.service 2>/dev/null || true
          fi
          
          # Give it a moment to fully stop
          sleep 2

          START_ARGS=(background-start-disconnected)

          if [[ "${{ inputs.network_scan }}" == "true" ]]; then
          START_ARGS+=(--network-scan)
          fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

          if [[ "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
          fi

          if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--fail-on-whitelist)
          fi

          if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
            START_ARGS+=(--fail-on-blacklist)
          fi

          if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
            START_ARGS+=(--fail-on-anomalous)
          fi

          if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
            START_ARGS+=(--cancel-on-violation)
          fi

          if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
            START_ARGS+=(--include-local-traffic)
          fi

          if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
            START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
          fi
          
          # Add agentic provider for disconnected mode
          if [[ "${{ inputs.agentic_provider }}" != "none" && "${{ inputs.agentic_provider }}" != "" ]]; then
            START_ARGS+=(--agentic-provider "${{ inputs.agentic_provider }}")
          fi

          # Verify cancellation script exists (was created earlier in the install step)
          if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
            CANCEL_SCRIPT_PATH="${{ inputs.cancel_pipeline_script }}"
            if [[ -z "$CANCEL_SCRIPT_PATH" ]]; then
              # Same $HOME as used during creation (sudo -E preserves HOME)
              CANCEL_SCRIPT_PATH="$HOME/cancel_pipeline.sh"
            fi
            if [[ -f "$CANCEL_SCRIPT_PATH" ]]; then
              echo "[OK] Cancellation script verified at $CANCEL_SCRIPT_PATH"
            else
              echo "[WARNING] Cancellation script NOT found at $CANCEL_SCRIPT_PATH"
            fi
          fi

          $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
        fi
      shell: bash

    # We must wait here as we can use the API to download the whitelist artifact from the previous run
    - name: Wait for API access to be granted if requested
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        if [[ "${{ inputs.wait_for_api }}" == "true" ]]; then
          echo "Waiting for GitHub API access to be granted..."
          echo "Note: This runs AFTER the daemon has started and connected"
          echo "      so the daemon can whitelist the runner IP via EDAMAME backend"
          attempts=0
          timeout=true
          last_error=""
          
          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Testing API access..."
            
            # We use the GitHub token to access the run details API, which tests org-level IP allowlist access
            # This endpoint requires authentication even for public repos and is blocked by IP allowlists
            # Capture both stdout and stderr to see what's actually happening
            if output=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }} 2>&1); then
              timeout=false
              echo "[OK] API access granted!"
              break
            else
              exit_code=$?
              last_error="$output"
              echo "[WARNING] API call failed with exit code $exit_code"
              echo "Error output: $last_error"
              
              if [ $attempts -lt 10 ]; then
                echo "Waiting 60 seconds before retry..."
                sleep 60
              fi
            fi
          done

          # Calculate elapsed time (first attempt is immediate, subsequent attempts wait 60s each)
          if [ $attempts -gt 1 ]; then
            elapsed_time=$(( (attempts - 1) * 60 ))
          else
            elapsed_time=0
          fi
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo ""
            echo "[ERROR] Timeout occurred while waiting for API access."
            echo "Total attempts: $attempts"
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            echo "Last error: $last_error"
            echo ""
            echo "Dumping EDAMAME logs for debugging..."
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Wait for https access to the repo be granted if requested
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        if [[ "${{ inputs.wait_for_https }}" == "true" ]]; then
          echo "Waiting for HTTPS access to the repository..."
          echo "Note: This runs AFTER the daemon has started and connected"
          echo "      so the daemon can whitelist the runner IP via EDAMAME backend"
          attempts=0
          timeout=true
          repo_url="https://github.com/${{ github.repository }}.git"
          last_status=""

          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Checking HTTPS access to the repo..."
            status_code=$(curl -o /dev/null -s -w "%{http_code}" -H "Authorization: token ${{ inputs.token }}" $repo_url)
            last_status="$status_code"

            if [[ "$status_code" == "301" || "$status_code" == "200" ]]; then
              timeout=false
              echo "[OK] HTTPS access granted (status: $status_code)!"
              break
            else
              echo "[WARNING] HTTPS access not yet granted. Status Code: $status_code"
              if [ $attempts -lt 10 ]; then
                echo "Waiting 60 seconds before retry..."
                sleep 60
              fi
            fi
          done

          # Calculate elapsed time (first attempt is immediate, subsequent attempts wait 60s each)
          if [ $attempts -gt 1 ]; then
            elapsed_time=$(( (attempts - 1) * 60 ))
          else
            elapsed_time=0
          fi
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo ""
            echo "[ERROR] Timeout occurred while waiting for HTTPS access to the repo."
            echo "Total attempts: $attempts"
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            echo "Last status code: $last_status"
            echo ""
            echo "Dumping EDAMAME logs for debugging..."
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash

    - name: Wait for a while if requested
      run: |
        if [[ "${{ inputs.wait }}" == "true" ]]; then
          sleep 180
        fi
      shell: bash

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode is enabled"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "[ERROR] ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "[OK] Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "[OK] Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Validate endpoint counts
              # Note: Daemon factorizes whitelists on load, merging endpoints with same domain/protocol/AS/process
              # This REDUCES the count, so daemon count <= file count is EXPECTED
              if [[ "$DAEMON_ENDPOINT_COUNT" -eq 0 && "$FILE_ENDPOINT_COUNT" -gt 0 ]]; then
                echo ""
                echo "[ERROR] ERROR: Daemon has 0 endpoints but file has $FILE_ENDPOINT_COUNT!"
                echo "This indicates the whitelist was not loaded correctly into the daemon."
                echo ""
                echo "Debugging info:"
                echo "  - File: $WHITELIST_FILE"
                echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                echo "  - Daemon whitelist name: $LOADED_NAME"
                echo "  - Daemon status:"
                $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                exit 1
              elif [[ "$DAEMON_ENDPOINT_COUNT" -gt "$FILE_ENDPOINT_COUNT" ]]; then
                echo ""
                echo "[WARNING] Daemon has MORE endpoints than file (${DAEMON_ENDPOINT_COUNT} > ${FILE_ENDPOINT_COUNT})"
                echo "This is unexpected but continuing..."
              elif [[ "$DAEMON_ENDPOINT_COUNT" -lt "$FILE_ENDPOINT_COUNT" ]]; then
                echo "[OK] Daemon factorized whitelist: $FILE_ENDPOINT_COUNT raw → $DAEMON_ENDPOINT_COUNT merged endpoints"
              else
                echo "[OK] Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "[OK] Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "[OK] Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "[OK] Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode is enabled"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "[ERROR] ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "[OK] Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "[OK] Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Validate endpoint counts
              # Note: Daemon factorizes whitelists on load, merging endpoints with same domain/protocol/AS/process
              # This REDUCES the count, so daemon count <= file count is EXPECTED
              if [[ "$DAEMON_ENDPOINT_COUNT" -eq 0 && "$FILE_ENDPOINT_COUNT" -gt 0 ]]; then
                echo ""
                echo "[ERROR] ERROR: Daemon has 0 endpoints but file has $FILE_ENDPOINT_COUNT!"
                echo "This indicates the whitelist was not loaded correctly into the daemon."
                echo ""
                echo "Debugging info:"
                echo "  - File: $WHITELIST_FILE"
                echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                echo "  - Daemon whitelist name: $LOADED_NAME"
                echo "  - Daemon status:"
                $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                exit 1
              elif [[ "$DAEMON_ENDPOINT_COUNT" -gt "$FILE_ENDPOINT_COUNT" ]]; then
                echo ""
                echo "[WARNING] Daemon has MORE endpoints than file (${DAEMON_ENDPOINT_COUNT} > ${FILE_ENDPOINT_COUNT})"
                echo "This is unexpected but continuing..."
              elif [[ "$DAEMON_ENDPOINT_COUNT" -lt "$FILE_ENDPOINT_COUNT" ]]; then
                echo "[OK] Daemon factorized whitelist: $FILE_ENDPOINT_COUNT raw → $DAEMON_ENDPOINT_COUNT merged endpoints"
              else
                echo "[OK] Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "[OK] Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "[OK] Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "[OK] Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash


    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode is enabled"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "[ERROR] ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "[OK] Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "[OK] Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Validate endpoint counts
              # Note: Daemon factorizes whitelists on load, merging endpoints with same domain/protocol/AS/process
              # This REDUCES the count, so daemon count <= file count is EXPECTED
              if [[ "$DAEMON_ENDPOINT_COUNT" -eq 0 && "$FILE_ENDPOINT_COUNT" -gt 0 ]]; then
                echo ""
                echo "[ERROR] ERROR: Daemon has 0 endpoints but file has $FILE_ENDPOINT_COUNT!"
                echo "This indicates the whitelist was not loaded correctly into the daemon."
                echo ""
                echo "Debugging info:"
                echo "  - File: $WHITELIST_FILE"
                echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                echo "  - Daemon whitelist name: $LOADED_NAME"
                echo "  - Daemon status:"
                $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                exit 1
              elif [[ "$DAEMON_ENDPOINT_COUNT" -gt "$FILE_ENDPOINT_COUNT" ]]; then
                echo ""
                echo "[WARNING] Daemon has MORE endpoints than file (${DAEMON_ENDPOINT_COUNT} > ${FILE_ENDPOINT_COUNT})"
                echo "This is unexpected but continuing..."
              elif [[ "$DAEMON_ENDPOINT_COUNT" -lt "$FILE_ENDPOINT_COUNT" ]]; then
                echo "[OK] Daemon factorized whitelist: $FILE_ENDPOINT_COUNT raw → $DAEMON_ENDPOINT_COUNT merged endpoints"
              else
                echo "[OK] Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "[OK] Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "[OK] Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "[OK] Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash

    - name: Augment existing custom whitelists if requested
      if: ${{ inputs.augment_custom_whitelists == 'true' }}
      run: |
        cd
        # Ensure a path is provided
        if [[ -z "${{ inputs.custom_whitelists_path }}" ]]; then
          echo "Error: augment_custom_whitelists requires custom_whitelists_path to be set."
          exit 1
        fi

        echo "Generating augmented whitelist from current sessions..."
        AUG_JSON=$($EDAMAME_POSTURE_CMD augment-custom-whitelists)

        if [[ -z "$AUG_JSON" ]]; then
          echo "Error: augment-custom-whitelists returned empty output"
          exit 1
        fi

        # Check if augmented whitelist has endpoints
        if command -v jq &> /dev/null; then
          ENDPOINT_COUNT=$(echo "$AUG_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
          echo "Augmented whitelist contains $ENDPOINT_COUNT endpoints"
          
          if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
            echo "[WARNING]  Warning: Augmented whitelist is empty (no endpoints)"
            echo "This can happen if:"
            echo "  - No baseline whitelist was loaded before augmentation (use set_custom_whitelists: true first)"
            echo "  - No network sessions were captured yet"
            echo "  - No whitelist exceptions (non-conforming sessions) exist to add"
            echo ""
            echo "Augmentation requires:"
            echo "  1. A baseline whitelist loaded into the system (via set_custom_whitelists)"
            echo "  2. Network sessions captured"
            echo "  3. Some non-conforming sessions to add as exceptions"
            exit 1
          fi
        fi

        echo "$AUG_JSON" > "${{ inputs.custom_whitelists_path }}"
        echo "Augmented whitelist saved to: ${{ inputs.custom_whitelists_path }}"
      shell: bash

    

    - name: Checkout the repo through the git CLI if requested
      run: |
        if [[ "${{ inputs.checkout }}" == "true" ]]; then
          timeout=true

          # Initialize the repo if it doesn't exist
          git init || true

          # Add the remote if it doesn't exist (support GHES/self-hosted via GITHUB_SERVER_URL)
          server_url="${GITHUB_SERVER_URL:-https://github.com}"
          server_url="${server_url%/}"
          if [[ "$server_url" == *"://"* ]]; then
            server_scheme="${server_url%%://*}"
            server_host_path="${server_url#*://}"
          else
            server_scheme="https"
            server_host_path="$server_url"
          fi
          remote_url="${server_scheme}://x-access-token:${{ inputs.token }}@${server_host_path}/${{ github.repository }}.git"
          if git remote | grep -q '^origin$'; then
            git remote set-url origin "$remote_url" || true
          else
            git remote add origin "$remote_url" || true
          fi
          for i in {1..10}; do
            echo "Attempt $i: Checking out the repo through the git CLI..."
            if git fetch --depth=1 origin ${{ github.ref }}; then
              branch_name=$(echo "${{ github.ref }}" | sed -e "s/^refs\/heads\///")
              if git checkout -B "$branch_name" FETCH_HEAD; then
                if [[ "${{ inputs.checkout_submodules }}" == "true" ]]; then
                  git submodule update --init --recursive
                fi
                timeout=false
                break
              fi
            else
              echo "Checkout of the repo through the git CLI failed. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((i * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for access to the repo through the git CLI."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Checkout of the repo through the git CLI succeeded."
            echo "Time taken to checkout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."

            # Verify the checked out commit and branch
            echo "Checked out branch: $(git rev-parse --abbrev-ref HEAD)"
            echo "Checked out commit: $(git rev-parse HEAD)"
            if [ "$(git rev-parse HEAD)" != "${{ github.sha }}" ]; then
              echo "Warning: The checked out commit does not match the expected SHA."
              echo "Expected: ${{ github.sha }}"
              echo "Actual: $(git rev-parse HEAD)"
            fi
          fi
        fi
      shell: bash

    - name: Create custom whitelists from network sessions if requested
      run: |
        if [[ "${{ inputs.create_custom_whitelists }}" == "true" ]]; then
          cd
          echo "Creating custom whitelists from active network sessions..."
          
          # Build the command with optional --include-process flag
          CREATE_CMD="$EDAMAME_POSTURE_CMD create-custom-whitelists"
          if [[ "${{ inputs.include_process_in_whitelist }}" == "true" ]]; then
            CREATE_CMD="$CREATE_CMD --include-process"
            echo "Including process names in whitelist for stricter matching"
          fi
          
          if [[ -n "${{ inputs.custom_whitelists_path }}" ]]; then
            # Save to the specified file
            $CREATE_CMD > "${{ inputs.custom_whitelists_path }}"
            
            # Check if the created whitelist has endpoints
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Created whitelist contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Created whitelist is empty (no endpoints)"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet (wait longer before creating whitelist)"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - All sessions were filtered out"
                echo "The whitelist file was created but will not be loaded automatically if empty"
              fi
            fi
            
            echo "Custom whitelists saved to: ${{ inputs.custom_whitelists_path }}"
          else
            # Just display the whitelist JSON
            $CREATE_CMD
          fi
        fi
      shell: bash

    - name: Create or augment auto-whitelist
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        
        # Use configuration from saved state or fallback to inputs
        THRESHOLD="${AUTO_WHITELIST_THRESHOLD:-${{ inputs.auto_whitelist_stability_threshold }}}"
        CONSECUTIVE="${AUTO_WHITELIST_CONSECUTIVE:-${{ inputs.auto_whitelist_stability_consecutive_runs }}}"
        MAX_ITER="${AUTO_WHITELIST_MAX_ITER:-${{ inputs.auto_whitelist_max_iterations }}}"
        
        echo "=== Auto-whitelist Mode: Processing Iteration $AUTO_WHITELIST_ITERATION ==="
        echo "Configuration: threshold=${THRESHOLD}%, consecutive=${CONSECUTIVE}, max=${MAX_ITER}"
        
        # CRITICAL: Verify daemon is ready BEFORE checking whitelist
        echo "Checking daemon readiness before augmentation..."
        if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
          echo "[ERROR] ERROR: Daemon is not responding!"
          echo "Cannot proceed with augmentation - daemon must be running and ready."
          echo ""
          echo "Daemon status:"
          $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
          exit 1
        fi
        echo "[OK] Daemon is ready"
        
        # CRITICAL: Verify daemon state before augmentation
        echo "Checking daemon whitelist state..."
        DAEMON_WHITELIST=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
        echo "Daemon whitelist: $DAEMON_WHITELIST"
        
        if [[ "$DAEMON_WHITELIST" != "custom_whitelist" && "$AUTO_WHITELIST_ITERATION" -gt 0 ]]; then
          echo ""
          echo "[ERROR] ERROR: Daemon does not have custom_whitelist loaded!"
          echo "   Expected: custom_whitelist"
          echo "   Actual: $DAEMON_WHITELIST"
          echo ""
          echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
          echo "Without it, augmentation creates a fresh whitelist instead of merging with baseline."
          echo ""
          echo "The daemon should have loaded the whitelist during setup."
          echo "This error indicates the whitelist was not applied correctly."
          echo ""
          echo "Debugging info:"
          echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
          echo "  - AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "  - Whitelist file: $(ls -lh auto_whitelist.json 2>/dev/null || echo 'missing')"
          echo "  - Whitelist file path: $(pwd)/auto_whitelist.json"
          echo "  - File exists: $([ -f "auto_whitelist.json" ] && echo 'yes' || echo 'no')"
          echo "  - Daemon status:"
          $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
          echo ""
          echo "CRITICAL: Cannot proceed with augmentation - whitelist must be loaded during setup."
          echo "Augmentation requires custom_whitelist to be active in the daemon."
          echo "Attempting to reload now would mask the root cause of the setup failure."
          echo ""
          echo "Fix: Ensure the whitelist is successfully loaded into the daemon during setup."
          exit 1
        fi
        
        echo "[OK] Daemon has correct whitelist loaded for augmentation"
        
        # For subsequent runs, force session update before augmentation to ensure exceptions are populated
        if [[ "$AUTO_WHITELIST_EXISTS" == "true" ]]; then
          echo "Forcing session update before augmentation..."
          $EDAMAME_POSTURE_CMD get-sessions > /dev/null 2>&1 || true
          echo "Session update completed"
        fi
        
        # Check if we're promoting exceptions (stable whitelist + promote flag)
        PROMOTE_EXCEPTIONS="${{ inputs.auto_whitelist_promote_exceptions }}"
        if [[ "$PROMOTE_EXCEPTIONS" == "true" && "$AUTO_WHITELIST_STABLE" == "true" ]]; then
          echo ""
          echo "╔══════════════════════════════════════════════════════════════════════════════╗"
          echo "║              PROMOTING EXCEPTIONS TO WHITELIST                               ║"
          echo "╚══════════════════════════════════════════════════════════════════════════════╝"
          echo ""
          echo "The whitelist is stable but 'auto_whitelist_promote_exceptions: true' is set."
          echo "Any non-conforming sessions will be added to the whitelist."
          echo ""
          
          # Count endpoints before promotion
          OLD_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
          
          # Augment (add exceptions)
          echo "Calling: $EDAMAME_POSTURE_CMD augment-custom-whitelists"
          if ! $EDAMAME_POSTURE_CMD augment-custom-whitelists > auto_whitelist_new.json 2> augment_stderr.log; then
            echo "[ERROR] ERROR: augment-custom-whitelists command FAILED!"
            cat augment_stderr.log 2>/dev/null || true
            exit 1
          fi
          
          # Validate JSON
          if ! jq . auto_whitelist_new.json >/dev/null 2>&1; then
            echo "[ERROR] Invalid JSON output from augment-custom-whitelists"
            exit 1
          fi
          
          # Count new endpoints
          NEW_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist_new.json" 2>/dev/null || echo "0")
          PROMOTED_COUNT=$((NEW_ENDPOINT_COUNT - OLD_ENDPOINT_COUNT))
          
          mv auto_whitelist_new.json auto_whitelist.json
          
          # Update iteration but KEEP stable count (whitelist remains stable)
          NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
          echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
          # Don't modify auto_whitelist_stable_count.txt - keep it at max
          
          echo ""
          echo "═══════════════════════════════════════════════════════════════════════════════"
          echo "                    PROMOTION COMPLETE"
          echo "═══════════════════════════════════════════════════════════════════════════════"
          echo ""
          if [[ $PROMOTED_COUNT -gt 0 ]]; then
            echo "[OK] Promoted $PROMOTED_COUNT new endpoint(s) to whitelist"
            echo "   Before: $OLD_ENDPOINT_COUNT endpoints"
            echo "   After:  $NEW_ENDPOINT_COUNT endpoints"
          else
            echo "[OK] No new endpoints to promote (whitelist unchanged)"
          fi
          echo ""
          echo "The whitelist remains STABLE and will continue enforcing."
          echo "Next run will use the updated whitelist."
          echo ""
          echo "To disable promotion mode, remove 'auto_whitelist_promote_exceptions: true'"
          echo "from your workflow configuration."
          echo ""
          
          echo "AUTO_WHITELIST_STATUS=promoted" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_PROMOTED_COUNT=$PROMOTED_COUNT" >> $GITHUB_ENV
          
          # Exit early - don't continue to normal augmentation logic
          exit 0
        fi
        
        # Create/augment whitelist from current sessions
        if [[ "$AUTO_WHITELIST_EXISTS" == "false" ]]; then
            # First run: create initial whitelist from captured traffic
            echo "First run: Creating initial whitelist from captured traffic..."
            echo "Calling: $EDAMAME_POSTURE_CMD create-custom-whitelists"
            
            if ! $EDAMAME_POSTURE_CMD create-custom-whitelists > auto_whitelist_new.json 2>&1; then
              echo ""
              echo "[ERROR] ERROR: create-custom-whitelists command FAILED!"
              echo "   Exit code: $?"
              echo "   Command output:"
              cat auto_whitelist_new.json 2>/dev/null || echo "    (no output captured)"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Create command executed successfully"
            
            # Save iteration count
            echo "1" > auto_whitelist_iteration.txt
            mv auto_whitelist_new.json auto_whitelist.json
            
            # Count endpoints with error handling
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' auto_whitelist.json 2>/dev/null || echo "0")
            echo "Initial whitelist created with $ENDPOINT_COUNT endpoints"
            
            if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
              echo "[WARNING]  Warning: Initial auto-whitelist is empty (no endpoints)"
              echo "This can happen if no network sessions were captured yet"
              echo "The whitelist will not be loaded automatically if empty"
            fi
            
            echo "AUTO_WHITELIST_STATUS=created" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
          else
            # Subsequent run: augment and check stability
            # Note: augment-custom-whitelists handles empty baselines correctly by creating whitelist from exceptions
            echo "Iteration $AUTO_WHITELIST_ITERATION: Augmenting whitelist..."
            echo "Current daemon whitelist: $($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo 'unknown')"
            echo "Calling: $EDAMAME_POSTURE_CMD augment-custom-whitelists"
            
            # Capture stdout (JSON) and stderr separately
            # Only JSON should go to the file, stderr should be logged separately
            if ! $EDAMAME_POSTURE_CMD augment-custom-whitelists > auto_whitelist_new.json 2> augment_stderr.log; then
              echo ""
              echo "[ERROR] ERROR: augment-custom-whitelists command FAILED!"
              echo "   Exit code: $?"
              echo ""
              echo "Command stderr output:"
              cat augment_stderr.log 2>/dev/null || echo "    (no stderr captured)"
              echo ""
              echo "Command stdout (JSON) output:"
              head -c 1000 auto_whitelist_new.json 2>/dev/null || echo "    (no stdout captured)"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "Current daemon whitelist:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            
            # Log stderr if any (for debugging)
            if [[ -s augment_stderr.log ]]; then
              echo "[WARNING] Command stderr output (non-fatal):"
              cat augment_stderr.log
            fi
            
            echo "[OK] Augment command executed successfully"
            
            # Verify output file was created
            if [[ ! -f "auto_whitelist_new.json" ]]; then
              echo "[ERROR] ERROR: augment-custom-whitelists did not create output file!"
              exit 1
            fi
            
            # CRITICAL: Validate JSON structure and clean if needed
            # augment-custom-whitelists might output non-JSON text before the JSON
            if command -v jq &> /dev/null; then
              # Check if file is valid JSON
              if ! jq . auto_whitelist_new.json >/dev/null 2>&1; then
                echo "[WARNING] Warning: Output file is not valid JSON, attempting to extract JSON..."
                # Try to extract JSON by finding the first { and using jq to parse from there
                mv auto_whitelist_new.json auto_whitelist_new.json.orig
                # Find line starting with { and extract everything from there
                # Use awk to find first line with { and print rest
                awk '/^\{/ {p=1} p' auto_whitelist_new.json.orig > auto_whitelist_new.json.tmp 2>/dev/null || {
                  # Fallback: try to extract JSON using jq's raw input
                  # jq can sometimes parse JSON even with leading text
                  jq -R 'fromjson?' auto_whitelist_new.json.orig 2>/dev/null | jq . > auto_whitelist_new.json.tmp 2>/dev/null || true
                }
                
                # Validate extracted JSON
                if jq . auto_whitelist_new.json.tmp >/dev/null 2>&1; then
                  mv auto_whitelist_new.json.tmp auto_whitelist_new.json
                  echo "[OK] Extracted valid JSON from command output"
                else
                  echo "[ERROR] ERROR: Cannot extract valid JSON from command output"
                  echo "First 1000 chars of output:"
                  head -c 1000 auto_whitelist_new.json.orig | cat -A
                  echo ""
                  echo "Attempting to show structure:"
                  head -20 auto_whitelist_new.json.orig | cat -A
                  exit 1
                fi
              else
                echo "[OK] Output file is valid JSON"
              fi
            fi
            
            # CRITICAL: Count endpoints in old and new whitelists before comparison
            if command -v jq &> /dev/null; then
              OLD_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              NEW_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist_new.json" 2>/dev/null || echo "0")
              echo "Old whitelist (before augmentation): $OLD_ENDPOINT_COUNT endpoints"
              echo "New whitelist (after augmentation): $NEW_ENDPOINT_COUNT endpoints"
              
              if [[ "$NEW_ENDPOINT_COUNT" -eq 0 && "$OLD_ENDPOINT_COUNT" -gt 0 ]]; then
                echo ""
                echo "[ERROR] ERROR: Augmentation resulted in empty whitelist!"
                echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                echo ""
                echo "This indicates augment-custom-whitelists failed to preserve baseline endpoints."
                echo "Debugging info:"
                echo "  - Old file size: $(wc -c < auto_whitelist.json) bytes"
                echo "  - New file size: $(wc -c < auto_whitelist_new.json) bytes"
                echo "  - New file first 500 chars:"
                head -c 500 auto_whitelist_new.json | cat -A || echo "    (cannot read file)"
                echo "  - New file JSON structure:"
                jq 'keys' auto_whitelist_new.json 2>/dev/null || echo "    (cannot parse)"
                echo "  - Whitelists in new file:"
                jq '.whitelists[]?.name' auto_whitelist_new.json 2>/dev/null || echo "    (cannot parse)"
                exit 1
              fi

              if [[ "$NEW_ENDPOINT_COUNT" -lt "$OLD_ENDPOINT_COUNT" ]]; then
                ENDPOINT_DELTA=$((OLD_ENDPOINT_COUNT - NEW_ENDPOINT_COUNT))
                if [[ "$ENDPOINT_DELTA" -le 2 ]]; then
                  echo ""
                  echo "[WARNING] Warning: Endpoint count decreased slightly after augmentation"
                  echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                  echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                  echo "   Difference: -$ENDPOINT_DELTA endpoints"
                  echo "   Continuing (difference within acceptable deduplication threshold ≤2)"
                else
                  echo ""
                  echo "[ERROR] ERROR: Endpoint count decreased after augmentation!"
                  echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                  echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                  echo "   Difference: -$ENDPOINT_DELTA endpoints"
                  echo ""
                  echo "Auto-whitelist must be monotonically increasing during learning."
                  echo "This indicates augment-custom-whitelists removed baseline endpoints."
                  echo ""
                  echo "Debugging info:"
                  echo "  - Old file size: $(wc -c < auto_whitelist.json) bytes"
                  echo "  - New file size: $(wc -c < auto_whitelist_new.json) bytes"
                  echo "  - Old file first 200 chars:"
                  head -c 200 auto_whitelist.json | cat -A || echo "    (cannot read file)"
                  echo "  - New file first 200 chars:"
                  head -c 200 auto_whitelist_new.json | cat -A || echo "    (cannot read file)"
                  exit 1
                fi
              fi
            fi
            
            # Compare old and new whitelists
            DIFF_PERCENT=$($EDAMAME_POSTURE_CMD compare-custom-whitelists-from-files auto_whitelist.json auto_whitelist_new.json | sed 's/%//' || echo "100")
            echo "Whitelist difference: ${DIFF_PERCENT}%"
            echo "AUTO_WHITELIST_DIFF=$DIFF_PERCENT" >> $GITHUB_ENV
            
            # Check if this iteration is stable (below threshold)
            # Use bc for floating-point comparison if available, otherwise use integer comparison
            if command -v bc &> /dev/null; then
              IS_STABLE=$(echo "$DIFF_PERCENT <= $THRESHOLD" | bc -l)
            else
              # Fallback to integer comparison (convert to int)
              DIFF_INT=${DIFF_PERCENT%.*}
              THRESHOLD_INT=${THRESHOLD%.*}
              [[ $DIFF_INT -le $THRESHOLD_INT ]] && IS_STABLE=1 || IS_STABLE=0
            fi
            
            if [[ "$IS_STABLE" == "1" ]]; then
              # Increment consecutive stable runs count
              STABLE_COUNT=$((AUTO_WHITELIST_STABLE_COUNT + 1))
              echo "$STABLE_COUNT" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
              
              echo "[OK] Whitelist is STABLE for this run (diff: ${DIFF_PERCENT}% <= threshold: ${THRESHOLD}%)"
              echo "   Consecutive stable runs: $STABLE_COUNT / $CONSECUTIVE required"
              
              # Check if we have enough consecutive stable runs
              if [[ $STABLE_COUNT -ge $CONSECUTIVE ]]; then
                echo "[SUCCESS] Whitelist is FULLY STABLE ($STABLE_COUNT consecutive runs with no changes)"
                # Update iteration and whitelist even when fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                
                # Verify final whitelist has endpoints
                if command -v jq &> /dev/null; then
                  FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                  echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
                fi
                
                echo "AUTO_WHITELIST_STATUS=stable" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "[PROGRESS] Whitelist is stable for this run, but need more consecutive confirmations"
                # Update iteration and whitelist when stable but not fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                
                # Verify final whitelist has endpoints
                if command -v jq &> /dev/null; then
                  FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                  echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
                fi
                
                echo "AUTO_WHITELIST_STATUS=confirming_stability" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            else
              # Whitelist changed - reset consecutive stable count
              echo "[PROGRESS] Whitelist is EVOLVING (diff: ${DIFF_PERCENT}% > threshold: ${THRESHOLD}%)"
              echo "0" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
              
              NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
              echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
              mv auto_whitelist_new.json auto_whitelist.json
              
              # Verify final whitelist has endpoints
              if command -v jq &> /dev/null; then
                FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
              fi
              
              # Check if max iterations reached
              if [[ $NEXT_ITERATION -ge $MAX_ITER ]]; then
                echo "[WARNING] Maximum iterations reached ($MAX_ITER), declaring stable"
                echo "AUTO_WHITELIST_STATUS=max_iterations" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "AUTO_WHITELIST_STATUS=evolving" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            fi
          fi
      shell: bash
      env:
        EDAMAME_POSTURE_CMD: ${{ env.EDAMAME_POSTURE_CMD }}
        AUTO_WHITELIST_ITERATION: ${{ env.AUTO_WHITELIST_ITERATION }}
        AUTO_WHITELIST_EXISTS: ${{ env.AUTO_WHITELIST_EXISTS }}
        AUTO_WHITELIST_STABLE_COUNT: ${{ env.AUTO_WHITELIST_STABLE_COUNT }}
        AUTO_WHITELIST_THRESHOLD: ${{ env.AUTO_WHITELIST_THRESHOLD }}
        AUTO_WHITELIST_CONSECUTIVE: ${{ env.AUTO_WHITELIST_CONSECUTIVE }}
        AUTO_WHITELIST_MAX_ITER: ${{ env.AUTO_WHITELIST_MAX_ITER }}

    - name: Dump sessions log if requested
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        ARGS=(get-sessions)

        # Handle whitelist exception enforcement based on auto-whitelist mode
        if [[ "$AUTO_WHITELIST_ENABLED" == "true" ]]; then
          # Auto-whitelist mode: only enforce when stable
          if [[ "$AUTO_WHITELIST_STABLE" == "true" ]]; then
            echo "[INFO] Auto-whitelist is STABLE - enforcing whitelist violations"
            echo "   Any whitelist exceptions will cause this step to fail"
            ARGS+=(--fail-on-whitelist)
          else
            echo "[INFO] Auto-whitelist is LEARNING/EVOLVING - whitelist exceptions are expected"
            echo "   New endpoints will be discovered and added to the whitelist"
            echo "   This step will NOT fail on whitelist exceptions during learning"
            # Do NOT add --fail-on-whitelist during learning
          fi
        else
          # Manual mode: respect the exit_on_whitelist_exceptions input
        if [[ "${{ inputs.exit_on_whitelist_exceptions }}" == "true" ]]; then
          ARGS+=(--fail-on-whitelist)
          fi
        fi

        if [[ "${{ inputs.exit_on_blacklisted_sessions }}" == "true" ]]; then
          ARGS+=(--fail-on-blacklist)
        fi

        if [[ "${{ inputs.exit_on_anomalous_sessions }}" == "true" ]]; then
          ARGS+=(--fail-on-anomalous)
        fi

        # Execute get-sessions command
        # During auto-whitelist learning phases, non-zero exit codes are expected
        # (non-conforming sessions are being discovered and will be added to whitelist)
        if [[ "$AUTO_WHITELIST_ENABLED" == "true" && "$AUTO_WHITELIST_STABLE" != "true" ]]; then
          # Learning phase: capture exit code but don't fail
          echo "Executing: $EDAMAME_POSTURE_CMD ${ARGS[*]}"
          set +e  # Don't exit on error during learning phase
          $EDAMAME_POSTURE_CMD "${ARGS[@]}"
          EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo ""
            echo "[INFO] Non-zero exit code ($EXIT_CODE) - this is expected during learning phase"
            echo "   Non-conforming sessions detected (ignoring during learning)"
            echo "   These sessions will be added to the whitelist via augmentation"
            echo "   This is normal behavior - whitelist is still evolving"
            echo ""
            # Don't exit - continue with augmentation
          else
            echo "[OK] No whitelist exceptions detected"
          fi
        elif [[ "$AUTO_WHITELIST_ENABLED" == "true" && "$AUTO_WHITELIST_STABLE" == "true" ]]; then
          # Stable/enforcement phase: capture exit code and provide recovery instructions on failure
          echo "Executing: $EDAMAME_POSTURE_CMD ${ARGS[*]}"
          set +e
          $EDAMAME_POSTURE_CMD "${ARGS[@]}"
          EXIT_CODE=$?
          set -e
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo ""
            echo "╔══════════════════════════════════════════════════════════════════════════════╗"
            echo "║                    WHITELIST VIOLATION DETECTED                              ║"
            echo "╚══════════════════════════════════════════════════════════════════════════════╝"
            echo ""
            echo "The auto-whitelist is in ENFORCEMENT mode and detected unauthorized network traffic."
            echo "This could indicate:"
            echo "  • A supply chain attack (compromised dependency)"
            echo "  • A legitimate new endpoint that needs to be whitelisted"
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo "                         RECOVERY OPTIONS"
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            echo "OPTION 1: Add exception to whitelist (if legitimate)"
            echo "─────────────────────────────────────────────────────"
            echo "Re-run this workflow with 'auto_whitelist_promote_exceptions: true' to"
            echo "automatically add the detected exceptions to your whitelist:"
            echo ""
            echo "  - name: Setup EDAMAME Posture"
            echo "    uses: edamametechnologies/edamame_posture_action@v1"
            echo "    with:"
            echo "      auto_whitelist: true"
            echo "      auto_whitelist_promote_exceptions: true  # <-- Add this"
            echo "      # ... other options"
            echo ""
            echo "OPTION 2: Temporarily switch to learning mode"
            echo "─────────────────────────────────────────────────────"
            echo "Delete the auto-whitelist artifact to restart learning:"
            echo ""
            echo "  gh api -X DELETE repos/${{ github.repository }}/actions/artifacts \\"
            echo "    --jq '.artifacts[] | select(.name==\"${{ env.AUTO_WHITELIST_ARTIFACT_NAME || inputs.auto_whitelist_artifact_name }}\") | .id' \\"
            echo "    | xargs -I {} gh api -X DELETE repos/${{ github.repository }}/actions/artifacts/{}"
            echo ""
            echo "OPTION 3: Manual augmentation (one-time)"
            echo "─────────────────────────────────────────────────────"
            echo "Run a separate workflow step to augment the whitelist:"
            echo ""
            echo "  - name: Augment whitelist with new endpoints"
            echo "    uses: edamametechnologies/edamame_posture_action@v1"
            echo "    with:"
            echo "      augment_custom_whitelists: true"
            echo "      custom_whitelists_path: ~/auto_whitelist.json"
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo "                         DOCUMENTATION"
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            echo "For more details on auto-whitelist recovery, see:"
            echo "  https://github.com/edamametechnologies/edamame_posture_action#troubleshooting"
            echo ""
            echo "For supply chain attack investigation guidance, see:"
            echo "  https://github.com/edamametechnologies/edamame_posture_action#what-are-custom-whitelists"
            echo ""
            echo "═══════════════════════════════════════════════════════════════════════════════"
            echo ""
            # Save exception info for potential promotion
            echo "AUTO_WHITELIST_VIOLATION=true" >> $GITHUB_ENV
            exit $EXIT_CODE
          else
            echo "[OK] No whitelist exceptions detected - workflow is conforming"
          fi
        else
          # Manual mode: fail on errors
          $EDAMAME_POSTURE_CMD "${ARGS[@]}"
        fi
      shell: bash
      env:
        EDAMAME_POSTURE_CMD: ${{ env.EDAMAME_POSTURE_CMD }}
        AUTO_WHITELIST_ENABLED: ${{ env.AUTO_WHITELIST_ENABLED }}
        AUTO_WHITELIST_STABLE: ${{ env.AUTO_WHITELIST_STABLE }}

    - name: Display logs if requested
      run: |
        if [[ "${{ inputs.display_logs }}" == "true" ]]; then
          # Rather scan the home directory for logs in case the dameon has been killed
          cd
          #$EDAMAME_POSTURE_CMD logs
          find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
        fi
      shell: bash

    - name: Save auto-whitelist state
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        STATE_ITERATION=$(cat auto_whitelist_iteration.txt 2>/dev/null || echo "0")
        cat <<'EOF' > auto_whitelist_state.json
        {
          "last_run_id": "${GITHUB_RUN_ID}",
          "last_iteration": "__STATE_ITERATION__",
          "artifact_name": "${{ env.AUTO_WHITELIST_ARTIFACT_NAME || inputs.auto_whitelist_artifact_name }}",
          "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        sed -i "s/__STATE_ITERATION__/$STATE_ITERATION/" auto_whitelist_state.json
      shell: bash
    
    - name: Upload auto-whitelist artifact
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.AUTO_WHITELIST_ARTIFACT_NAME || inputs.auto_whitelist_artifact_name }}
        path: |
          ~/auto_whitelist.json
          ~/auto_whitelist_iteration.txt
          ~/auto_whitelist_stable_count.txt
          ~/auto_whitelist_config.json
          ~/auto_whitelist_state.json
        retention-days: 90
        overwrite: true
        if-no-files-found: warn
    
    - name: Upload auto-whitelist state artifact
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.auto_whitelist_state_artifact_name }}
        path: ~/auto_whitelist_state.json
        retention-days: 90
        overwrite: true
        if-no-files-found: warn
    
    - name: Display final whitelist file
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo ""
        echo "=== Final auto_whitelist.json uploaded in previous step ==="
        if command -v jq &> /dev/null; then
          jq . auto_whitelist.json || cat auto_whitelist.json
        else
          cat auto_whitelist.json
        fi
        echo "=== End of whitelist file ==="
      shell: bash

    - name: Display auto-whitelist status
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo ""
        echo "=== Auto-whitelist Status ==="
        echo "Iteration: $AUTO_WHITELIST_ITERATION"
        echo "Status: $AUTO_WHITELIST_STATUS"
        echo "Stable: $AUTO_WHITELIST_STABLE"
        if [[ -n "$AUTO_WHITELIST_DIFF" ]]; then
          echo "Difference: ${AUTO_WHITELIST_DIFF}%"
        fi
        # Load configuration for display
        CONSECUTIVE="${AUTO_WHITELIST_CONSECUTIVE:-${{ inputs.auto_whitelist_stability_consecutive_runs }}}"
        
        if [[ -n "$AUTO_WHITELIST_STABLE_COUNT" ]]; then
          echo "Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / $CONSECUTIVE"
        fi
        
        # Display summary with enforcement status
        if [[ "$AUTO_WHITELIST_STATUS" == "created" ]]; then
          echo ""
          echo "[INFO] This was the first run in listen-only mode."
          echo "   Whitelist exceptions are NORMAL and did NOT cause failure."
          echo "   Re-run the workflow to start refining the whitelist."
        elif [[ "$AUTO_WHITELIST_STATUS" == "evolving" ]]; then
          echo ""
          echo "[PROGRESS] Whitelist is still evolving (${AUTO_WHITELIST_DIFF}% change)."
          echo "   New endpoints were discovered and added to the whitelist."
          echo "   Whitelist exceptions are EXPECTED and did NOT cause failure."
          echo "   Consecutive stable runs reset to 0."
          echo "   Re-run the workflow to continue refinement."
        elif [[ "$AUTO_WHITELIST_STATUS" == "confirming_stability" ]]; then
          echo ""
          echo "[PROGRESS] Whitelist had no changes this run (${AUTO_WHITELIST_DIFF}%)."
          echo "   No new endpoints discovered - counting stable runs."
          echo "   Whitelist exceptions still allowed (NOT failing yet)."
          echo "   Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / $CONSECUTIVE"
          echo "   Re-run the workflow to confirm stability."
        elif [[ "$AUTO_WHITELIST_STATUS" == "stable" ]]; then
          echo ""
          echo "[OK] Whitelist has stabilized!"
          echo "   Achieved $AUTO_WHITELIST_STABLE_COUNT consecutive runs with no changes."
          echo "   ENFORCEMENT ENABLED: Future runs will FAIL on whitelist violations."
          echo "   Any new endpoint will be treated as a potential supply chain attack."
        elif [[ "$AUTO_WHITELIST_STATUS" == "max_iterations" ]]; then
          echo ""
          echo "[WARNING] Maximum iterations reached."
          echo "   Whitelist declared stable even though still evolving."
          echo "   ENFORCEMENT ENABLED: Future runs will FAIL on whitelist violations."
        elif [[ "$AUTO_WHITELIST_STATUS" == "promoted" ]]; then
          echo ""
          echo "[OK] Exception promotion completed successfully!"
          if [[ -n "$AUTO_WHITELIST_PROMOTED_COUNT" && "$AUTO_WHITELIST_PROMOTED_COUNT" -gt 0 ]]; then
            echo "   Promoted $AUTO_WHITELIST_PROMOTED_COUNT new endpoint(s) to whitelist."
          else
            echo "   No new endpoints needed promotion."
          fi
          echo "   Whitelist remains STABLE - enforcement continues."
          echo "   Remove 'auto_whitelist_promote_exceptions: true' when done adding endpoints."
        fi
      shell: bash
      env:
        AUTO_WHITELIST_CONSECUTIVE: ${{ env.AUTO_WHITELIST_CONSECUTIVE }}
        AUTO_WHITELIST_PROMOTED_COUNT: ${{ env.AUTO_WHITELIST_PROMOTED_COUNT }}

    - name: Stop EDAMAME Posture process if requested
      run: |
        if [[ "${{ inputs.stop }}" == "true" ]]; then
          cd
          echo "Stopping EDAMAME Posture process..."
          $EDAMAME_POSTURE_CMD stop
          
          # Wait for daemon to fully stop
          echo "Verifying daemon has stopped..."
          MAX_ATTEMPTS=10
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "Daemon successfully stopped (attempt $ATTEMPT)"
              break
            fi
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "Warning: Daemon still running after $ATTEMPT attempts, forcing kill..."
              # Force kill on final attempt
              if [[ "$RUNNER_OS" == "Windows" ]]; then
                taskkill //F //IM edamame_posture.exe 2>/dev/null || true
              else
                pkill -9 edamame_posture 2>/dev/null || true
                if [[ "$RUNNER_OS" == "Linux" ]]; then
                  sudo systemctl stop edamame_posture.service 2>/dev/null || true
                  sudo rc-service edamame_posture stop 2>/dev/null || true
                fi
              fi
              sleep 1
              break
            fi
            
            echo "Daemon still running, waiting... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
            ATTEMPT=$((ATTEMPT + 1))
            sleep 1
          done
          
          echo "EDAMAME Posture process stopped."
        fi
      shell: bash

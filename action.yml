name: "Setup EDAMAME Posture"
description: "Download and control EDAMAME Posture"
inputs:
  edamame_user:
    description: "EDAMAME user (required to start the process in the background)"
    required: false
  edamame_domain:
    description: "EDAMAME domain (required to start the process in the background)"
    required: false
  edamame_pin:
    description: "EDAMAME PIN (required to start the process in the background)"
    required: false
  edamame_id:
    description: "EDAMAME identifier suffix (required to start the process in the background)"
    required: false
  edamame_policy:
    description: "EDAMAME policy name that the device must comply with (the action will fail if the device does not comply)"
    required: false
  edamame_minimum_score:
    description: "Minimum score that the device must achieve (the action will fail if the device does not achieve the minimum score)"
    required: false
  edamame_mandatory_threats:
    description: "Comma separated list of mandatory threats that the device must not exhibit (the action will fail if the device does not detect the threats)"
    required: false
  edamame_mandatory_prefixes:
    description: "Comma separated list of mandatory tag prefixes covering threats that the device must not exhibit (the action will fail if the device does not have the prefixes)"
    required: false
  auto_remediate:
    description: "Automatically remediate posture issues"
    required: false
    default: "false"
  skip_remediations:
    description: "Remediations to skip when performing auto-remediations (comma separated)"
    required: false
  network_scan:
    description: "Scan network for critical devices and capture network traffic (only applicable if the background process is started)"
    required: false
    default: "false"
  disconnected_mode:
    description: "Start EDAMAME Posture in disconnected mode without requiring domain authentication"
    required: false
    default: "false"
  dump_sessions_log:
    description: "Dump sessions log (only effective if the background process is started with network_scan set to true)"
    required: false
    default: "false"
  checkout:
    description: "Checkout the repo through the git CLI (retry if access is not granted)"
    required: false
    default: "false"
  checkout_submodules:
    description: "Checkout submodules"
    required: false
    default: "false"
  wait_for_https:
    description: "Wait for https access to the repo be granted"
    required: false
    default: "false"
  wait:
    description: "Wait for a while for access to be granted"
    required: false
    default: "false"
  wait_for_api:
    description: "Wait for API access to be granted"
    required: false
    default: "false"
  token:
    description: "GitHub token to checkout the repo"
    required: false
    default: ${{ github.token }}
  whitelist:
    description: "Whitelist to use for the network scan (only applicable if the background process is started)"
    required: false
    default: "github"
  exit_on_whitelist_exceptions:
    description: "Exit with error when whitelist exceptions are detected (directly passed to get-sessions)"
    required: false
    default: "true"
  exit_on_blacklisted_sessions:
    description: "Exit with error when blacklisted sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  exit_on_anomalous_sessions:
    description: "Exit with error when anomalous sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  report_email:
    description: "Report email address"
    required: false
    default: ""
  create_custom_whitelists:
    description: "Create custom whitelists from captured network sessions and save it to the specified path"
    required: false
    default: "false"
  custom_whitelists_path:
    description: "Path to save or load custom whitelists JSON (used with create_custom_whitelists or to provide a whitelist file to apply)"
    required: false
    default: ""
  set_custom_whitelists:
    description: "Apply custom whitelists from a file specified in custom_whitelists_path"
    required: false
    default: "false"
  augment_custom_whitelists:
    description: "Augment the existing custom whitelists using current network sessions and merge the result back into the file specified by custom_whitelists_path. Requires network_scan=true."
    required: false
    default: "false"
  stop:
    description: "Stop the EDAMAME Posture process"
    required: false
    default: "false"
  display_logs:
    description: "Display logs"
    required: false
    default: "false"
  debug:
    description: "Debug mode"
    required: false
    default: "false"

runs:
  using: "composite"

  steps:
    - name: Dependencies
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          cd
          # Install gh, wget, curl, jq using Chocolatey if not already installed
          if ! choco list | grep -E '^gh[[:space:]]'; then
            echo "Installing gh..."
            choco install gh -y
          fi

          if ! choco list | grep -E '^wget[[:space:]]'; then
            echo "Installing wget..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install wget -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^curl[[:space:]]'; then
            echo "Installing curl..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install curl -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^jq[[:space:]]'; then
            echo "Installing jq..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install jq -y | grep -v "Progress:"
          fi

          # Install node if not installed
          if ! choco list | grep -q '^nodejs[[:space:]]'; then
            echo "Installing nodejs..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install nodejs -y | grep -v "Progress:"
          fi

          # Install vcredist2015 if not installed
          if ! choco list | grep -q '^vcredist2015[[:space:]]'; then
            echo "Installing vcredist2015..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install vcredist2015 --package-parameters "/install /quiet /norestart" -y | grep -v "Progress:"
          fi

          # Check and download Packet.dll
          if [ ! -f "Packet.dll" ]; then
              echo "Packet.dll not found. Downloading..."
              wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/raw/refs/heads/main/windows/Packet.dll -O Packet.dll
              chmod +x Packet.dll
          else
              echo "Packet.dll already exists. Skipping download."
          fi

          # Check and download wpcap.dll
          if [ ! -f "wpcap.dll" ]; then
              echo "wpcap.dll not found. Downloading..."
              wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/raw/refs/heads/main/windows/wpcap.dll -O wpcap.dll
              chmod +x wpcap.dll
          else
              echo "wpcap.dll already exists. Skipping download."
          fi
        elif [[ "$RUNNER_OS" == "Linux" ]]; then
          # Define function to wait for apt/dpkg locks
          wait_for_apt_locks() {
            echo "Checking for apt/dpkg locks..."
            TIMEOUT=300
            TIME_PASSED=0
            # Check common lock files
            LOCK_FILES=(
              "/var/lib/apt/lists/lock"
              "/var/lib/dpkg/lock-frontend"
              "/var/lib/dpkg/lock"
            )
            while sudo fuser "${LOCK_FILES[@]}" >/dev/null 2>&1; do
              echo "Waiting for apt/dpkg locks to be released..."
              sleep 5
              TIME_PASSED=$((TIME_PASSED + 5))
              if [ $TIME_PASSED -ge $TIMEOUT ]; then
                echo "Timed out waiting for apt/dpkg locks after $TIMEOUT seconds."
                exit 1
              fi
            done
            echo "No apt/dpkg locks held, proceeding..."
          }
          
          # Avoid prompts during apt-get install
          export DEBIAN_FRONTEND=noninteractive
          
          # Install sudo if needed
          if ! command -v sudo &> /dev/null; then
            echo "Installing sudo..."
            # Wait for apt lock before any operations
            wait_for_apt_locks
            apt-get update -y
            wait_for_apt_locks
            apt-get install -y --no-install-recommends sudo
            
            # Wait again after installing sudo
            wait_for_apt_locks
          fi          
          # Update package lists
          echo "Updating package lists..."
          wait_for_apt_locks
          sudo -E apt-get update

          # Check/install git
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            wait_for_apt_locks
            sudo -E apt-get install -y git
          fi

          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            wait_for_apt_locks
            (type -p wget >/dev/null || (wait_for_apt_locks; sudo -E apt-get update -y && wait_for_apt_locks && sudo -E apt-get install -y wget)) \
              && sudo mkdir -p -m 755 /etc/apt/keyrings \
                    && out=$(mktemp) && wget -nv -O$out https://cli.github.com/packages/githubcli-archive-keyring.gpg \
                    && cat $out | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null \
              && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \
              && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
              && wait_for_apt_locks \
              && sudo -E apt-get update -y \
              && wait_for_apt_locks \
              && sudo -E apt-get install -y gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            wait_for_apt_locks
            sudo -E apt-get install -y wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            wait_for_apt_locks
            sudo -E apt-get install -y curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            wait_for_apt_locks
            sudo -E apt-get install -y jq
          fi

          # Check/install libpcap0.8t64
          if ! dpkg -s libpcap0.8t64 &> /dev/null; then
            echo "Installing libpcap0.8t64..."
            wait_for_apt_locks
            # Install libpcap0.8t64 if available, otherwise install libpcap0.8
            if ! sudo -E apt-get install -y libpcap0.8t64  &> /dev/null; then
              echo "Failed to install libpcap0.8t64, using libpcap0.8 instead"
              if ! dpkg -s libpcap0.8 &> /dev/null; then
                echo "Installing libpcap0.8..."
                wait_for_apt_locks
                sudo -E apt-get install -y libpcap0.8
              fi
            fi
          fi

          # Check/install build-essential
          if ! dpkg -s build-essential &> /dev/null; then
            echo "Installing build-essential..."
            wait_for_apt_locks
            sudo -E apt-get install -y build-essential
          fi

          # Check/install node + npm
          if ! command -v node &> /dev/null; then
            echo "Installing node + npm..."
            wait_for_apt_locks
            sudo -E apt-get install -y nodejs npm
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            brew install gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            brew install wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            brew install curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            brew install jq
          fi

          # Check/install node
          if ! command -v node &> /dev/null; then
            echo "Installing node..."
            brew install node
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi
      shell: bash

    - name: Download EDAMAME Posture binary
      id: download_binary
      run: |
        JQ=jq
        echo "jq version: $($JQ --version)"

        # --- Determine Latest Version via Redirect ---
        LATEST_VERSION=""
        echo "Attempting to get latest version via redirect..."
        REDIRECT_OUTPUT=$(curl -s -L -I -o /dev/null -w '%{url_effective}:%{http_code}' https://github.com/edamametechnologies/edamame_posture_cli/releases/latest)

        # Extract status code (part after the last colon) using bash parameter expansion
        HTTP_STATUS="${REDIRECT_OUTPUT##*:}"
        # Extract URL (part before the last colon and the status code) using bash parameter expansion
        LATEST_RELEASE_URL="${REDIRECT_OUTPUT%:$HTTP_STATUS}"

        echo "Redirect URL: $LATEST_RELEASE_URL"
        echo "HTTP Status: $HTTP_STATUS"

        if [[ "$HTTP_STATUS" == "200" && "$LATEST_RELEASE_URL" == *"/releases/tag/"* ]]; then
          LATEST_VERSION=$(basename "$LATEST_RELEASE_URL")
          LATEST_VERSION=${LATEST_VERSION#v} # Remove v prefix
          echo "Latest version found via redirect: $LATEST_VERSION"
        else
          echo "Failed to get latest version via redirect (Status: $HTTP_STATUS, URL: $LATEST_RELEASE_URL). Will try API fallback."
        fi

        # --- Determine Fallback Version via API ---
        API_FALLBACK_VERSION=""
        HARDCODED_FALLBACK_VERSION="0.9.24" # Define hardcoded fallback
        echo "Attempting to get fallback version via API..."
        WAIT_TIME=5
        for i in {1..3}; do # Limit retries
          FALLBACK_API_RESPONSE=$(curl -s https://api.github.com/repos/edamametechnologies/edamame_posture_cli/releases)
          
          # Check for rate limit first
          if echo "$FALLBACK_API_RESPONSE" | grep -qi "API rate limit exceeded"; then
            WAIT_TIME=$((WAIT_TIME * 2))
            if [[ $WAIT_TIME -gt 60 ]]; then WAIT_TIME=60; fi # Cap wait time
            echo "API rate limit exceeded for fallback, sleeping for $WAIT_TIME seconds (Attempt $i)"
            sleep $WAIT_TIME
          # If not rate limited, check if response is valid and has enough data
          elif echo "$FALLBACK_API_RESPONSE" | $JQ -e '. | length > 1' > /dev/null; then
            # Get the tag name of the second non-draft, non-prerelease release
            API_FALLBACK_VERSION=$($JQ -r '[.[] | select(.draft==false and .prerelease==false)][1].tag_name' <<< "$FALLBACK_API_RESPONSE")
            if [[ -n "$API_FALLBACK_VERSION" && "$API_FALLBACK_VERSION" != "null" ]]; then
                API_FALLBACK_VERSION=${API_FALLBACK_VERSION#v} # Remove v prefix
                echo "Fallback version found via API: $API_FALLBACK_VERSION"
                break # Success, exit loop
            else
                echo "Could not extract a valid second latest tag from API response (Attempt $i). JQ filter returned null or empty."
                # Log beginning of response for debugging
                echo "API Response (start): $(echo "$FALLBACK_API_RESPONSE" | head -c 100)..."
                API_FALLBACK_VERSION=""
                sleep 5 # Short sleep before retry on parsing error
            fi
          # If not rate limited and response is not valid/sufficient
          else 
            echo "Invalid API response for fallback (Attempt $i). Not rate limit, and not valid JSON or insufficient releases."
            # Log beginning of response for debugging
            echo "API Response (start): $(echo "$FALLBACK_API_RESPONSE" | head -c 100)..."
            API_FALLBACK_VERSION=""
            sleep 5 # Short sleep before retry on other errors
          fi
        done

        if [[ -z "$API_FALLBACK_VERSION" ]]; then
          echo "Failed to get fallback version from API after retries."
        fi

        # --- Set VERSION and FALLBACK_VERSION for Download ---
        if [[ -n "$LATEST_VERSION" ]]; then
          VERSION="$LATEST_VERSION"
          if [[ -n "$API_FALLBACK_VERSION" ]]; then
            FALLBACK_VERSION="$API_FALLBACK_VERSION"
          else
            echo "Using hardcoded fallback version as API fallback failed."
            FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          fi
        else
          # Latest version via redirect failed
          if [[ -n "$API_FALLBACK_VERSION" ]]; then
            echo "Using API fallback version as primary version."
            VERSION="$API_FALLBACK_VERSION"
            FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          else
            echo "Both redirect and API failed. Using hardcoded versions."
            VERSION="$HARDCODED_FALLBACK_VERSION"
            FALLBACK_VERSION="$HARDCODED_FALLBACK_VERSION"
          fi
        fi

        echo "VERSION to download: $VERSION"
        echo "FALLBACK_VERSION to download: $FALLBACK_VERSION"

        # We only support edamame_posture installed in the current directory on Windows and macOS
        # Navigate to the home directory
        cd
        binary_present=false

        # If debug is true, we will not download the binary
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "Debug mode is enabled, using debug version of the binary"
          BIN_POSTFIX="-debug"
        else
          echo "Debug mode is disabled, using latest version of the binary"
          BIN_POSTFIX=""
        fi

        # On Linux we also provide a deb package to have it installed in /usr/bin
        if [[ "$RUNNER_OS" == "Linux" ]]; then
          if [[ -f edamame_posture || -f /usr/bin/edamame_posture ]]; then
            echo "Binary already present"
            binary_present=true
          else
            ARCH=$(uname -m)
            if [[ -f /etc/os-release ]]; then
              source /etc/os-release
            else
              echo "/etc/os-release not found. Cannot determine distribution."
              exit 1
            fi
            case "$ID" in
              "alpine")
                # Alpine Linux
                if [[ "$ARCH" == "x86_64" ]]; then
                  echo "Downloading Alpine Linux binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                else
                  echo "Downloading Alpine Linux ARM binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-aarch64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                fi
                ;;
              *)
                # Everything else (Amazon, Ubuntu, Debian, or any unknown distro)
                if [[ "$ARCH" == "x86_64" ]]; then
                  MIN_GLIBC_VERSION="2.29"
                  echo "Minimum required GLIBC version: $MIN_GLIBC_VERSION"
                  if command -v getconf >/dev/null 2>&1; then
                    echo "Using getconf to determine GLIBC version"
                    GLIBC_VERSION=$(getconf GNU_LIBC_VERSION | awk '{print $2}')
                    echo "Detected GLIBC version: $GLIBC_VERSION"
                    # Compare versions using sort
                    if printf '%s\n%s\n' "$MIN_GLIBC_VERSION" "$GLIBC_VERSION" | sort -V | head -n 1 | grep -q "$MIN_GLIBC_VERSION"; then
                      echo "GLIBC version $GLIBC_VERSION is sufficient (minimum required: $MIN_GLIBC_VERSION)"
                      echo "Downloading x86_64-unknown-linux-gnu version of EDAMAME Posture binary for Linux..."
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-x86_64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                    else
                      echo "Warning: GLIBC version $GLIBC_VERSION is older than minimum required version $MIN_GLIBC_VERSION"
                      echo "Fallback to using x86_64-unknown-linux-musl version of the binary"
                      echo "Downloading x86_64-unknown-linux-musl version of EDAMAME Posture binary for Linux..."
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture || \
                      wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-x86_64-unknown-linux-musl${BIN_POSTFIX} -O edamame_posture
                    fi
                  else
                    echo "Unable to detect GLIBC version, getconf command not found"
                    exit 1
                  fi
                  # echo "Downloading Gnu Linux binary..."
                elif [[ "$ARCH" == "i686" ]]; then
                  echo "Downloading Gnu Linux i686 binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-i686-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                elif [[ "$ARCH" == "aarch64" ]]; then
                  echo "Downloading Gnu Linux ARM binary..."
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture || \
                  wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-aarch64-unknown-linux-gnu${BIN_POSTFIX} -O edamame_posture
                elif [[ "$ARCH" == "armhf" ]]; then
                  echo "Downloading Gnu Linux ARM binary..."
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture || \
                  wget https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-armv7-unknown-linux-gnueabihf${BIN_POSTFIX} -O edamame_posture
                else
                  echo "Unsupported architecture: $ARCH"
                  exit 1
                fi
            esac
            chmod u+x edamame_posture
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          if [[ -f edamame_posture ]]; then
            echo "Binary already present"
            binary_present=true
          else
            echo "Downloading EDAMAME Posture binary for macOS..."
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-universal-apple-darwin${BIN_POSTFIX} -O edamame_posture
            chmod u+x edamame_posture
          fi
        elif [[ "$RUNNER_OS" == "Windows" ]]; then
          if [[ -f edamame_posture.exe ]]; then
            echo "Binary already present"
            binary_present=true
          else
            echo "Downloading EDAMAME Posture binary for Windows..."
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${VERSION}/edamame_posture-${VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe || \
            wget --no-verbose https://github.com/edamametechnologies/edamame_posture_cli/releases/download/v${FALLBACK_VERSION}/edamame_posture-${FALLBACK_VERSION}-x86_64-pc-windows-msvc${BIN_POSTFIX}.exe -O edamame_posture.exe
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi

        # Set the output based on whether the binary was already present
        echo "binary_already_present=$binary_present" >> $GITHUB_OUTPUT
      shell: bash

    - name: Set EDAMAME_POSTURE_CMD variable
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          EDAMAME_POSTURE_CMD="./edamame_posture.exe"
          echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
        else
          if command -v edamame_posture >/dev/null 2>&1; then
            EDAMAME_POSTURE_CMD="sudo edamame_posture"
            echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
          else
            EDAMAME_POSTURE_CMD="sudo ./edamame_posture"
            echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
          fi
        fi

        # Set log level to debug if debug mode is enabled
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "EDAMAME_LOG_LEVEL=debug" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Show initial posture
      run: |
        cd
        $EDAMAME_POSTURE_CMD score
      shell: bash

    - name: Auto remediate/harden posture issues if requested and if we are not running in a self-hosted runner (the binary is already present)
      run: |
        cd
        if [[ "${{ inputs.auto_remediate }}" == "true" && "${{ steps.download_binary.outputs.binary_already_present }}" == "false" ]]; then
          if [[ "${{ inputs.skip_remediations }}" == "" ]]; then
            echo "No remediations to skip"
            $EDAMAME_POSTURE_CMD remediate
          else
            echo "Skipping remediations: ${{ inputs.skip_remediations }}"
            $EDAMAME_POSTURE_CMD remediate "${{ inputs.skip_remediations }}"
          fi
        fi
      shell: bash

    - name: Report email
      run: |
        cd
        if [[ "${{ inputs.report_email }}" != "" ]]; then
          signature=$($EDAMAME_POSTURE_CMD request-signature | grep Signature | awk '{print $2}')
          echo "Signature: $signature"
          echo "Sending compliance report to email: ${{ inputs.report_email }}"
          $EDAMAME_POSTURE_CMD request-report "${{ inputs.report_email }}" "$signature"
        fi
      shell: bash

    - name: Check local policy compliance
      run: |
        cd
        # Check if minimum score and mandatory threats are provided. Mandatory prefixes are optional.
        if [[ -n "${{ inputs.edamame_minimum_score }}" ]]; then
          echo "Checking policy compliance with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
          
          # Capture the policy check output, also use prefix to check for mandatory threats
          policy_output=$($EDAMAME_POSTURE_CMD check-policy "${{ inputs.edamame_minimum_score }}" "${{ inputs.edamame_mandatory_threats }}" "${{ inputs.edamame_mandatory_prefixes }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
        fi
      shell: bash

    - name: Check domain policy compliance
      run: |
        cd
        # Check if both domain and policy are provided
        if [[ -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_policy }}" ]]; then
          echo "Checking policy compliance with domain: ${{ inputs.edamame_domain }} and policy: ${{ inputs.edamame_policy }}"
          
          # Capture the policy check output
          policy_output=$($EDAMAME_POSTURE_CMD check-policy-for-domain "${{ inputs.edamame_domain }}" "${{ inputs.edamame_policy }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy: ${{ inputs.edamame_policy }} and domain: ${{ inputs.edamame_domain }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy: ${{ inputs.edamame_policy }} and domain: ${{ inputs.edamame_domain }}"
        fi
      shell: bash

    - name: Wait for a while if requested
      run: |
        if [[ "${{ inputs.wait }}" == "true" ]]; then
          sleep 180
        fi
      shell: bash

    - name: Start EDAMAME Posture process and wait for connection if all arguments are provided, skip otherwise
      run: |
        cd
        # Check if all arguments are provided
        if [[ -n "${{ inputs.edamame_user }}" && -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_pin }}" && -n "${{ inputs.edamame_id }}" ]]; then
          if [[ "${{ steps.download_binary.outputs.binary_already_present }}" == "true" ]]; then
            echo "EDAMAME Posture binary is already present. Checking status..."
            # Continue even if there are errors; capture both stdout and stderr
            $EDAMAME_POSTURE_CMD status > posture_status.txt 2>&1 || true

            # Check if the output indicates Error getting connection status: transport error
            if grep -q "Error getting connection status: transport error" posture_status.txt; then
              echo "edamame_posture is installed but isn't connected"
            else
              connected="$({ grep -i 'connected:' posture_status.txt | awk -F': ' '{print $2}'; } || true)"
              connected="${connected:-false}"
              echo "edamame_posture is connected: $connected"
            fi

            # Compare with inputs
            if [[ "$connected" == "true" ]]; then
              echo "EDAMAME Posture is already running with the specified user and domain. Skipping start process."
              # Instead of exiting, use a variable to control the flow
              SKIP_START=true
            else
              # Linux 
              if [[ "$RUNNER_OS" == "Linux" ]]; then
                # We assume the edamame_posture service is installed
                echo "edamame_posture service is installed but isn't connected, please configure it properly in order to use this runner"
                exit 1
              elif [[ "$RUNNER_OS" == "macOS" ]]; then
                # There are no macOS edamame_posture service package yet, so we have to start the process in the background
                echo "edamame_posture service is installed but isn't connected, it will be automatically started in the background"
              elif [[ "$RUNNER_OS" == "Windows" ]]; then
                # There are no Windows edamame_posture service package yet, so we have to start the process in the background
                echo "edamame_posture service is installed but isn't connected, it will be automatically started in the background"
              fi
            fi
          fi

          # Only continue with the start process if we're not skipping it
          if [[ "$SKIP_START" != "true" ]]; then
            # Add a unique suffix to the edamame_id to avoid conflicts using matrix jobs
            # ms since epoch
            IDSUFFIX=$(node -e "console.log(Date.now())")

            if [[ "${{ inputs.whitelist }}" != "" ]]; then
              if [[ "$RUNNER_OS" == "Windows" ]]; then
                WHITELIST="${{ inputs.whitelist }}_windows"
              elif [[ "$RUNNER_OS" == "macOS" ]]; then
                WHITELIST="${{ inputs.whitelist }}_macos"
              else
                WHITELIST="${{ inputs.whitelist }}_linux"
              fi
            else
              WHITELIST=""
            fi

            echo "Starting EDAMAME Posture..."
            $EDAMAME_POSTURE_CMD start "${{ inputs.edamame_user }}" "${{ inputs.edamame_domain }}" "${{ inputs.edamame_pin }}" "${{ inputs.edamame_id }}_$IDSUFFIX" "${{ inputs.network_scan }}" $WHITELIST
            echo "Waiting for connection..."
            $EDAMAME_POSTURE_CMD wait-for-connection || { cd; find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"; exit 1; }
          fi
        elif [[ "${{ inputs.disconnected_mode }}" == "true" ]]; then
          echo "Starting EDAMAME Posture in disconnected mode..."

          if [[ "${{ inputs.whitelist }}" != "" ]]; then
            if [[ "$RUNNER_OS" == "Windows" ]]; then
              WHITELIST="${{ inputs.whitelist }}_windows"
            elif [[ "$RUNNER_OS" == "macOS" ]]; then
              WHITELIST="${{ inputs.whitelist }}_macos"
            else
              WHITELIST="${{ inputs.whitelist }}_linux"
            fi
          else
            WHITELIST=""
          fi
          
          $EDAMAME_POSTURE_CMD background-start-disconnected "${{ inputs.network_scan }}" $WHITELIST
        fi
      shell: bash

    - name: Apply custom whitelists if provided
      run: |
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
      shell: bash

    - name: Augment existing custom whitelists if requested
      if: ${{ inputs.augment_custom_whitelists == 'true' }}
      run: |
        cd
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          echo "Augmenting custom whitelists is not fully supported on Windows due to licensing limitations."
          exit 0
        fi

        # Ensure a path is provided
        if [[ -z "${{ inputs.custom_whitelists_path }}" ]]; then
          echo "Error: augment_custom_whitelists requires custom_whitelists_path to be set."
          exit 1
        fi

        echo "Generating augmented whitelist from current sessions..."
        AUG_JSON=$($EDAMAME_POSTURE_CMD augment-custom-whitelists)

        if [[ -z "$AUG_JSON" ]]; then
          echo "Error: augment-custom-whitelists returned empty output"
          exit 1
        fi

        echo "$AUG_JSON" > "${{ inputs.custom_whitelists_path }}"
        echo "Augmented whitelist saved to: ${{ inputs.custom_whitelists_path }}"
      shell: bash

    - name: Checkout the repo through the git CLI if requested
      run: |
        if [[ "${{ inputs.checkout }}" == "true" ]]; then
          timeout=true

          # Initialize the repo if it doesn't exist
          git init || true

          # Add the remote if it doesn't exist
          if git remote | grep -q '^origin$'; then
            git remote set-url origin https://x-access-token:${{ inputs.token }}@github.com/${{ github.repository }}.git || true
          else
            git remote add origin https://x-access-token:${{ inputs.token }}@github.com/${{ github.repository }}.git || true
          fi
          for i in {1..10}; do
            echo "Attempt $i: Checking out the repo through the git CLI..."
            if git fetch --depth=1 origin ${{ github.ref }}; then
              branch_name=$(echo "${{ github.ref }}" | sed -e "s/^refs\/heads\///")
              if git checkout -B "$branch_name" FETCH_HEAD; then
                if [[ "${{ inputs.checkout_submodules }}" == "true" ]]; then
                  git submodule update --init --recursive
                fi
                timeout=false
                break
              fi
            else
              echo "Checkout of the repo through the git CLI failed. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((i * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for access to the repo through the git CLI."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Checkout of the repo through the git CLI succeeded."
            echo "Time taken to checkout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."

            # Verify the checked out commit and branch
            echo "Checked out branch: $(git rev-parse --abbrev-ref HEAD)"
            echo "Checked out commit: $(git rev-parse HEAD)"
            if [ "$(git rev-parse HEAD)" != "${{ github.sha }}" ]; then
              echo "Warning: The checked out commit does not match the expected SHA."
              echo "Expected: ${{ github.sha }}"
              echo "Actual: $(git rev-parse HEAD)"
            fi
          fi
        fi
      shell: bash

    - name: Wait for API access to be granted if requested
      run: |
        if [[ "${{ inputs.wait_for_api }}" == "true" ]]; then
          attempts=0
          timeout=true
          for i in {1..10}; do
            attempts=$((attempts + 1))
            # We use the GitHub token to access the API using gh release list that requires authentication limited to the scope of the token
            if gh release list --repo ${{ github.repository }}; then
              timeout=false
              break
            else
              sleep 60
            fi
          done

          elapsed_time=$((attempts * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for API access."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "API access granted."
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Wait for https access to the repo be granted if requested
      run: |
        if [[ "${{ inputs.wait_for_https }}" == "true" ]]; then
          attempts=0
          timeout=true
          repo_url="https://github.com/${{ github.repository }}.git"

          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Checking https access to the repo..."
            status_code=$(curl -o /dev/null -s -w "%{http_code}" -H "Authorization: token ${{ inputs.token }}" $repo_url)

            if [[ "$status_code" == "301" || "$status_code" == "200" ]]; then
              timeout=false
              break
            else
              echo "https access to the repo not yet granted. Curl Status Code: $status_code. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((attempts * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for https access to the repo."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "https access to the repo granted."
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash

    - name: Create custom whitelists from network sessions if requested
      run: |
        if [[ "${{ inputs.create_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            echo "Creating custom whitelists is not fully supported on Windows due to licensing limitations."
          else
            echo "Creating custom whitelists from active network sessions..."
            if [[ -n "${{ inputs.custom_whitelists_path }}" ]]; then
              # Save to the specified file
              $EDAMAME_POSTURE_CMD create-custom-whitelists > "${{ inputs.custom_whitelists_path }}"
              echo "Custom whitelists saved to: ${{ inputs.custom_whitelists_path }}"
            else
              # Just display the whitelist JSON
              $EDAMAME_POSTURE_CMD create-custom-whitelists
            fi
          fi
        fi
      shell: bash

    - name: Dump sessions log if requested
      run: |
        if [[ "${{ inputs.dump_sessions_log }}" == "true" ]]; then
          cd
          if [[ "$RUNNER_OS" == "Windows" ]]; then
            # Not in place due to license issues
            echo "Dumping sessions log is not supported on Windows."
          else
            # Format: get-sessions [ZEEK_FORMAT] [LOCAL_TRAFFIC] [CHECK_WHITELIST] [CHECK_BLACKLIST] [CHECK_ANOMALOUS]
            $EDAMAME_POSTURE_CMD get-sessions false false ${{ inputs.exit_on_whitelist_exceptions }} ${{ inputs.exit_on_blacklisted_sessions }} ${{ inputs.exit_on_anomalous_sessions }}
          fi
        fi
      shell: bash

    - name: Display logs if requested
      run: |
        if [[ "${{ inputs.display_logs }}" == "true" ]]; then
          # Rather scan the home directory for logs in case the dameon has been killed
          cd
          #$EDAMAME_POSTURE_CMD logs
          find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
        fi
      shell: bash

    - name: Stop EDAMAME Posture process if requested
      run: |
        if [[ "${{ inputs.stop }}" == "true" ]]; then
          cd
          echo "Stopping EDAMAME Posture process..."
          $EDAMAME_POSTURE_CMD stop
          echo "EDAMAME Posture process stopped."
        fi
      shell: bash

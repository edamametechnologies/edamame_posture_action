name: "Setup EDAMAME Posture"
description: "Download and control EDAMAME Posture"
inputs:
  edamame_user:
    description: "EDAMAME user (required to start the process in the background)"
    required: false
  edamame_domain:
    description: "EDAMAME domain (required to start the process in the background)"
    required: false
  edamame_pin:
    description: "EDAMAME PIN (required to start the process in the background)"
    required: false
  edamame_id:
    description: "EDAMAME identifier suffix (required to start the process in the background)"
    required: false
  edamame_policy:
    description: "EDAMAME policy name that the device must comply with (the action will fail if the device does not comply)"
    required: false
  edamame_minimum_score:
    description: "Minimum score that the device must achieve (the action will fail if the device does not achieve the minimum score)"
    required: false
  edamame_mandatory_threats:
    description: "Comma separated list of mandatory threats that the device must not exhibit (the action will fail if the device does not detect the threats)"
    required: false
  edamame_mandatory_prefixes:
    description: "Comma separated list of mandatory tag prefixes covering threats that the device must not exhibit (the action will fail if the device does not have the prefixes)"
    required: false
  auto_remediate:
    description: "Automatically remediate posture issues"
    required: false
    default: "false"
  skip_remediations:
    description: "Remediations to skip when performing auto-remediations (comma separated)"
    required: false
    default: "remote login enabled,remote desktop enabled,local firewall disabled"
  network_scan:
    description: "Scan network for critical devices (only applicable if the background process is started)"
    required: false
    default: "false"
  packet_capture:
    description: "Capture network traffic (auto = follow network_scan)"
    required: false
    default: "auto"
  check_whitelist:
    description: "Report and enforce whitelist exceptions when capturing network traffic (requires a whitelist name)"
    required: false
    default: "false"
  check_blacklist:
    description: "Report and enforce blacklist matches during network capture"
    required: false
    default: "true"
  check_anomalous:
    description: "Report and enforce anomalous session detection during network capture"
    required: false
    default: "true"
  cancel_on_violation:
    description: "Attempt to cancel the current CI pipeline when violations are detected"
    required: false
    default: "false"
  cancel_pipeline_script:
    description: "Path to custom cancellation script (default: /tmp/cancel_pipeline.sh). Script receives violation reason as first argument."
    required: false
    default: ""
  disconnected_mode:
    description: "Start EDAMAME Posture in disconnected mode without requiring domain authentication"
    required: false
    default: "false"
  dump_sessions_log:
    description: "Dump sessions log (requires background process with packet capture enabled)"
    required: false
    default: "false"
  checkout:
    description: "Checkout the repo through the git CLI (retry if access is not granted)"
    required: false
    default: "false"
  checkout_submodules:
    description: "Checkout submodules"
    required: false
    default: "false"
  wait_for_https:
    description: "Wait for https access to the repo be granted"
    required: false
    default: "false"
  wait:
    description: "Wait for a while for access to be granted"
    required: false
    default: "false"
  wait_for_api:
    description: "Wait for API access to be granted"
    required: false
    default: "false"
  token:
    description: "GitHub token to checkout the repo"
    required: false
    default: ${{ github.token }}
  whitelist:
    description: "Whitelist to use for the network scan (only applicable if the background process is started)"
    required: false
    default: ""
  exit_on_whitelist_exceptions:
    description: "Exit with error when whitelist exceptions are detected (directly passed to get-sessions)"
    required: false
    default: "true"
  exit_on_blacklisted_sessions:
    description: "Exit with error when blacklisted sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  exit_on_anomalous_sessions:
    description: "Exit with error when anomalous sessions are detected (directly passed to get-sessions)"
    required: false
    default: "false"
  report_email:
    description: "Report email address"
    required: false
    default: ""
  create_custom_whitelists:
    description: "Create custom whitelists from captured network sessions and save it to the specified path"
    required: false
    default: "false"
  custom_whitelists_path:
    description: "Path to save or load custom whitelists JSON (used with create_custom_whitelists or to provide a whitelist file to apply)"
    required: false
    default: ""
  set_custom_whitelists:
    description: "Apply custom whitelists from a file specified in custom_whitelists_path"
    required: false
    default: "false"
  augment_custom_whitelists:
    description: "Augment the existing custom whitelists using current network sessions and merge the result back into the file specified by custom_whitelists_path. Requires network_scan=true."
    required: false
    default: "false"
  auto_whitelist:
    description: |
      Enable auto-whitelist mode: first run is listen-only, subsequent runs refine whitelist until stable.
      Recommended settings: network_scan=true with packet_capture enabled so traffic is captured for comparison.
      
      Usage pattern (two-invocation):
      1. First invocation: Setup with auto_whitelist=true (starts daemon, applies whitelist)
      2. Do work: Generate traffic (daemon captures in background)
      3. Second invocation: dump_sessions_log=true (augments whitelist, uploads artifact)
      
      The action automatically handles both phases when called twice in the same job.
    required: false
    default: "false"
  auto_whitelist_artifact_name:
    description: "Name for the GitHub artifact to store auto-whitelist state (default: edamame-auto-whitelist)"
    required: false
    default: "edamame-auto-whitelist"
  auto_whitelist_stability_threshold:
    description: "Percentage threshold for whitelist stability (default: 0% - no new endpoints)"
    required: false
    default: "0"
  auto_whitelist_stability_consecutive_runs:
    description: "Number of consecutive runs with no changes required for stability (default: 3)"
    required: false
    default: "3"
  auto_whitelist_max_iterations:
    description: "Maximum number of auto-whitelist iterations before declaring stable (default: 15)"
    required: false
    default: "15"
  auto_whitelist_state_artifact_name:
    description: "Name for the artifact storing auto-whitelist state (default: auto-whitelist-state)"
    required: false
    default: "auto-whitelist-state"
  include_local_traffic:
    description: "Include local traffic in network capture and session logs"
    required: false
    default: "false"
  agentic_mode:
    description: "AI assistant mode for automated security todo processing: auto (execute), analyze (recommendations only), or disabled"
    required: false
    default: "disabled"
  agentic_provider:
    description: "LLM provider for AI assistant: claude, openai, ollama, or none (requires EDAMAME_LLM_API_KEY environment variable)"
    required: false
    default: "none"
  agentic_interval:
    description: "Interval in seconds for automated AI assistant todo processing"
    required: false
    default: "3600"
  stop:
    description: "Stop the EDAMAME Posture process"
    required: false
    default: "false"
  display_logs:
    description: "Display logs"
    required: false
    default: "false"
  debug:
    description: "Debug mode"
    required: false
    default: "false"

runs:
  using: "composite"

  steps:
    - name: Dependencies
      run: |
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          cd
          # Install gh, wget, curl, jq using Chocolatey if not already installed
          if ! choco list | grep -E '^gh[[:space:]]'; then
            echo "Installing gh..."
            choco install gh -y
          fi

          if ! choco list | grep -E '^wget[[:space:]]'; then
            echo "Installing wget..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install wget -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^curl[[:space:]]'; then
            echo "Installing curl..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install curl -y | grep -v "Progress:"
          fi

          if ! choco list | grep -q '^jq[[:space:]]'; then
            echo "Installing jq..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install jq -y | grep -v "Progress:"
          fi

          # Install node if not installed
          if ! choco list | grep -q '^nodejs[[:space:]]'; then
            echo "Installing nodejs..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install nodejs -y | grep -v "Progress:"
          fi

          # Install vcredist2015 if not installed
          if ! choco list | grep -q '^vcredist2015[[:space:]]'; then
            echo "Installing vcredist2015..."
            # --no-progress is not supported by all Chocolatey version/systems, we rather filter lines with "Progress:"
            choco install vcredist2015 --package-parameters "/install /quiet /norestart" -y | grep -v "Progress:"
          fi
        elif [[ "$RUNNER_OS" == "Linux" ]]; then
          # Define function to wait for apt/dpkg locks
          wait_for_apt_locks() {
            echo "Checking for apt/dpkg locks..."
            TIMEOUT=300
            TIME_PASSED=0
            # Check common lock files
            LOCK_FILES=(
              "/var/lib/apt/lists/lock"
              "/var/lib/dpkg/lock-frontend"
              "/var/lib/dpkg/lock"
            )
            while sudo fuser "${LOCK_FILES[@]}" >/dev/null 2>&1; do
              echo "Waiting for apt/dpkg locks to be released..."
              sleep 5
              TIME_PASSED=$((TIME_PASSED + 5))
              if [ $TIME_PASSED -ge $TIMEOUT ]; then
                echo "Timed out waiting for apt/dpkg locks after $TIMEOUT seconds."
                exit 1
              fi
            done
            echo "No apt/dpkg locks held, proceeding..."
          }
          
          export DEBIAN_FRONTEND=noninteractive
          apt_cmd_with_retry() {
            local max_attempts=5
            local delay_seconds=10
            local attempt=1
            local cmd=("$@")
            while true; do
              wait_for_apt_locks
              if "${cmd[@]}"; then
                return 0
              fi
              exit_code=$?
              if (( attempt >= max_attempts )); then
                echo "Command failed after $max_attempts attempts: ${cmd[*]}"
                return $exit_code
              fi
              echo "Command failed with exit code $exit_code (attempt $attempt/$max_attempts). Retrying in $delay_seconds seconds..."
              sleep $delay_seconds
              attempt=$((attempt + 1))
            done
          }
          
          # Install sudo if needed
          if ! command -v sudo &> /dev/null; then
            echo "Installing sudo..."
            # Wait for apt lock before any operations
            apt_cmd_with_retry apt-get install -y --no-install-recommends sudo
            
            # Wait again after installing sudo
            wait_for_apt_locks
          fi          
          # Update package lists
          echo "Updating package lists..."
          apt_cmd_with_retry sudo -E apt-get update -y

          # Check/install git
          if ! command -v git &> /dev/null; then
            echo "Installing git..."
            apt_cmd_with_retry sudo -E apt-get install -y git
          fi

          # Check/install wget (needed for GitHub CLI repository setup)
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            apt_cmd_with_retry sudo -E apt-get install -y wget
          fi

          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            sudo mkdir -p -m 755 /etc/apt/keyrings
            GH_KEY_TMP=$(mktemp)
            wget -nv -O "$GH_KEY_TMP" https://cli.github.com/packages/githubcli-archive-keyring.gpg
            sudo install -m 644 "$GH_KEY_TMP" /etc/apt/keyrings/githubcli-archive-keyring.gpg
            rm -f "$GH_KEY_TMP"
            sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            apt_cmd_with_retry sudo -E apt-get update -y
            apt_cmd_with_retry sudo -E apt-get install -y gh
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            apt_cmd_with_retry sudo -E apt-get install -y curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            apt_cmd_with_retry sudo -E apt-get install -y jq
          fi

          # Check/install bc (needed for auto-whitelist floating-point comparisons)
          if ! command -v bc &> /dev/null; then
            echo "Installing bc..."
            apt_cmd_with_retry sudo -E apt-get install -y bc
          fi

          # Note: libpcap runtime installation and soname compatibility is now handled by install.sh
          # when installing via APT, so we don't need to duplicate that logic here.

          # Check/install build-essential
          if ! dpkg -s build-essential &> /dev/null; then
            echo "Installing build-essential..."
            apt_cmd_with_retry sudo -E apt-get install -y build-essential
          fi

          # Check/install node + npm
          if ! command -v node &> /dev/null; then
            echo "Installing node + npm..."
            apt_cmd_with_retry sudo -E apt-get install -y nodejs npm
          fi
        elif [[ "$RUNNER_OS" == "macOS" ]]; then
          # Check/install gh
          if ! command -v gh &> /dev/null; then
            echo "Installing gh..."
            brew install gh
          fi

          # Check/install wget
          if ! command -v wget &> /dev/null; then
            echo "Installing wget..."
            brew install wget
          fi

          # Check/install curl
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            brew install curl
          fi

          # Check/install jq
          if ! command -v jq &> /dev/null; then
            echo "Installing jq..."
            brew install jq
          fi

          # Check/install node
          if ! command -v node &> /dev/null; then
            echo "Installing node..."
            brew install node
          fi
        else
          echo "Unsupported OS: $RUNNER_OS"
          exit 1
        fi
      shell: bash

    - name: Install or Update EDAMAME Posture
      id: install_posture
      shell: bash
      env:
        INSTALL_STATE_FILE: ${{ runner.temp }}/edamame_install_state
      run: |
        set -euo pipefail
        STATE_FILE="$INSTALL_STATE_FILE"
        INSTALL_ARGS=(--state-file "$STATE_FILE" --ci-mode)
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          INSTALL_ARGS+=(--debug-build)
        fi
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          INSTALL_ARGS+=(--install-dir "$HOME")
        fi
        echo "Running installer with args: ${INSTALL_ARGS[*]}"
        INSTALL_SCRIPT_REF="v0.9.82"
        RELEASE_API="https://api.github.com/repos/edamametechnologies/edamame_posture_cli/releases?per_page=2"
        echo "Determining latest installer release from: $RELEASE_API"
        if command -v curl >/dev/null 2>&1; then
          LATEST_JSON=$(curl -fsSL "$RELEASE_API" 2>/dev/null || true)
        elif command -v wget >/dev/null 2>&1; then
          LATEST_JSON=$(wget -q -O - "$RELEASE_API" 2>/dev/null || true)
        else
          LATEST_JSON=""
        fi
        if [[ -n "$LATEST_JSON" ]]; then
          LATEST_TAG=$(awk -F\" '
            /"tag_name"[[:space:]]*:/ {
              tag=$4
              gsub(/^v/, "", tag)
              if (tag != "") {
                print "v" tag
                exit
              }
            }
          ' <<< "$LATEST_JSON")
          if [[ -n "$LATEST_TAG" ]]; then
            INSTALL_SCRIPT_REF="$LATEST_TAG"
          fi
        fi
        echo "Using installer reference: $INSTALL_SCRIPT_REF"
        download_file() {
          local url="$1"
          local destination="$2"
          if command -v curl >/dev/null 2>&1; then
            curl --proto '=https' --tlsv1.2 -fsSL "$url" -o "$destination"
          elif command -v wget >/dev/null 2>&1; then
            wget -q "$url" -O "$destination"
          else
            return 1
          fi
        }
        RELEASE_INSTALL_URL="https://github.com/edamametechnologies/edamame_posture_cli/releases/download/${INSTALL_SCRIPT_REF}/install.sh"
        RAW_INSTALL_URL="https://raw.githubusercontent.com/edamametechnologies/edamame_posture_cli/${INSTALL_SCRIPT_REF}/install.sh"
        TMP_INSTALL_SCRIPT=$(mktemp)
        DOWNLOAD_SOURCE=""
        echo "Attempting to download installer from release asset: $RELEASE_INSTALL_URL"
        if download_file "$RELEASE_INSTALL_URL" "$TMP_INSTALL_SCRIPT"; then
          DOWNLOAD_SOURCE="release"
        else
          echo "[WARNING] Failed to download installer from release asset. Falling back to raw source."
          if download_file "$RAW_INSTALL_URL" "$TMP_INSTALL_SCRIPT"; then
            DOWNLOAD_SOURCE="raw"
          else
            echo "[ERROR] Unable to download installer from either release asset or raw source."
            rm -f "$TMP_INSTALL_SCRIPT"
            exit 1
          fi
        fi
        echo "Installer downloaded from $DOWNLOAD_SOURCE source. Executing..."
        sh "$TMP_INSTALL_SCRIPT" "${INSTALL_ARGS[@]}"
        rm -f "$TMP_INSTALL_SCRIPT"
        if [[ ! -f "$STATE_FILE" ]]; then
          echo "[WARNING] Installer did not produce state file at $STATE_FILE; reconstructing from current system state."
          binary_path=$(command -v edamame_posture 2>/dev/null || echo "")
          if [[ -z "$binary_path" ]]; then
            echo "[ERROR] Unable to locate edamame_posture binary after installation."
            exit 1
          fi
          mkdir -p "$(dirname "$STATE_FILE")"
          {
            echo "binary_path=${binary_path}"
            echo "install_method=unknown"
            echo "installed_via_package_manager=unknown"
            echo "binary_already_present=false"
            if [[ "$RUNNER_OS" == "Linux" ]]; then
              echo "platform=linux"
            elif [[ "$RUNNER_OS" == "macOS" ]]; then
              echo "platform=macos"
            elif [[ "$RUNNER_OS" == "Windows" ]]; then
              echo "platform=windows"
            else
              echo "platform=$RUNNER_OS"
            fi
          } > "$STATE_FILE"
        fi
        echo "=== Installer State ==="
        cat "$STATE_FILE"
        # shellcheck disable=SC1090
        source "$STATE_FILE"
        echo "binary_already_present=${binary_already_present:-false}" >> "$GITHUB_OUTPUT"
        echo "installed_via_package_manager=${installed_via_package_manager:-false}" >> "$GITHUB_OUTPUT"
        echo "install_method=${install_method:-binary}" >> "$GITHUB_OUTPUT"
        echo "binary_path=${binary_path:-}" >> "$GITHUB_OUTPUT"

    - name: Set EDAMAME_POSTURE_CMD variable
      shell: bash
      run: |
        set -euo pipefail
        echo "=== Setting EDAMAME_POSTURE_CMD ==="
        echo "Install method: ${{ steps.install_posture.outputs.install_method }}"
        echo "Installed via package manager: ${{ steps.install_posture.outputs.installed_via_package_manager }}"
        BINARY_PATH="${{ steps.install_posture.outputs.binary_path }}"
        if [[ -z "$BINARY_PATH" ]]; then
          if command -v edamame_posture >/dev/null 2>&1; then
            BINARY_PATH=$(command -v edamame_posture)
          elif [[ -f "$HOME/edamame_posture" ]]; then
            BINARY_PATH="$HOME/edamame_posture"
          elif [[ -f "$HOME/edamame_posture.exe" ]]; then
            BINARY_PATH="$HOME/edamame_posture.exe"
          else
            echo "[ERROR] edamame_posture not found!"
            exit 1
          fi
        fi
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          EDAMAME_POSTURE_CMD="$BINARY_PATH"
        else
          EDAMAME_POSTURE_CMD="sudo $BINARY_PATH"
        fi
        echo "Using binary at: $BINARY_PATH"
        echo "EDAMAME_BINARY_PATH=$BINARY_PATH" >> $GITHUB_ENV
        echo "EDAMAME_POSTURE_CMD=$EDAMAME_POSTURE_CMD" >> $GITHUB_ENV
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "EDAMAME_LOG_LEVEL=debug" >> $GITHUB_ENV
          echo "Debug logging enabled"
        fi
        echo "EDAMAME_POSTURE_CMD set to: $EDAMAME_POSTURE_CMD"

    - name: Inspect edamame_posture service (if present)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        set -euo pipefail
        if command -v systemctl >/dev/null 2>&1 && [[ -d /run/systemd/system ]]; then
          echo "=== systemctl status edamame_posture ==="
          sudo systemctl status edamame_posture.service --no-pager || true
          SERVICE_USER=$(systemctl show -p User edamame_posture.service 2>/dev/null | cut -d'=' -f2)
          if [[ -z "$SERVICE_USER" ]]; then
            SERVICE_USER="root (default)"
          fi
          echo "Configured systemd service user: $SERVICE_USER"
        elif command -v rc-service >/dev/null 2>&1; then
          echo "=== rc-service edamame_posture status ==="
          sudo rc-service edamame_posture status || true
          echo "OpenRC services run as root by default (override via init script as needed)."
        else
          echo "systemd/OpenRC not detected (likely container without init); skipping service inspection."
        fi

    - name: Show initial posture
      run: |
        cd
        $EDAMAME_POSTURE_CMD score
      shell: bash

    - name: Auto remediate/harden posture issues if requested and if we are not running in a self-hosted runner (the binary is already present)
      run: |
        cd
        if [[ "${{ inputs.auto_remediate }}" == "true" && "${{ steps.install_posture.outputs.binary_already_present }}" == "false" ]]; then
          if [[ "${{ inputs.skip_remediations }}" == "" ]]; then
            echo "No remediations to skip"
            $EDAMAME_POSTURE_CMD remediate
          else
            echo "Skipping remediations: ${{ inputs.skip_remediations }}"
            $EDAMAME_POSTURE_CMD remediate "${{ inputs.skip_remediations }}"
          fi
        fi
      shell: bash

    - name: Report email
      run: |
        cd
        if [[ "${{ inputs.report_email }}" != "" ]]; then
          signature=$($EDAMAME_POSTURE_CMD request-signature | grep Signature | awk '{print $2}')
          echo "Signature: $signature"
          echo "Sending compliance report to email: ${{ inputs.report_email }}"
          $EDAMAME_POSTURE_CMD request-report "${{ inputs.report_email }}" "$signature"
        fi
      shell: bash

    - name: Check local policy compliance
      run: |
        cd
        # Check if minimum score and mandatory threats are provided. Mandatory prefixes are optional.
        if [[ -n "${{ inputs.edamame_minimum_score }}" ]]; then
          echo "Checking policy compliance with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
          
          # Capture the policy check output, also use prefix to check for mandatory threats
          policy_output=$($EDAMAME_POSTURE_CMD check-policy "${{ inputs.edamame_minimum_score }}" "${{ inputs.edamame_mandatory_threats }}" "${{ inputs.edamame_mandatory_prefixes }}")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy with minimum score: ${{ inputs.edamame_minimum_score }}, mandatory threats: ${{ inputs.edamame_mandatory_threats }} and mandatory prefixes: ${{ inputs.edamame_mandatory_prefixes }}"
        fi
      shell: bash

    - name: Check domain policy compliance
      run: |
        cd
        # Check if both domain and policy are provided
        if [[ -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_policy }}" ]]; then
          POLICY_NAME="${{ inputs.edamame_policy }}"
          DOMAIN_NAME="${{ inputs.edamame_domain }}"
          
          echo "Checking policy compliance with domain: $DOMAIN_NAME and policy: $POLICY_NAME"
          
          # Capture the policy check output - use variables to avoid shell interpretation issues
          policy_output=$($EDAMAME_POSTURE_CMD check-policy-for-domain "$DOMAIN_NAME" "$POLICY_NAME")
          policy_status=$?
          
          echo "$policy_output"
          
          # Check if the policy check was successful
          if [[ $policy_status -ne 0 ]]; then
            echo "Device does not comply with the required policy: $POLICY_NAME and domain: $DOMAIN_NAME"
            echo "Exiting workflow due to policy non-compliance."
            exit 1
          fi
          
          echo "Device complies with the required policy: $POLICY_NAME and domain: $DOMAIN_NAME"
        fi
      shell: bash

    - name: Wait for a while if requested
      run: |
        if [[ "${{ inputs.wait }}" == "true" ]]; then
          sleep 180
        fi
      shell: bash

    - name: Start EDAMAME Posture process and wait for connection if all arguments are provided, skip otherwise
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        cd
        # Check if all arguments are provided
        if [[ -n "${{ inputs.edamame_user }}" && -n "${{ inputs.edamame_domain }}" && -n "${{ inputs.edamame_pin }}" && -n "${{ inputs.edamame_id }}" ]]; then
          SKIP_START=false
          if [[ "${{ steps.install_posture.outputs.binary_already_present }}" == "true" ]]; then
            echo "EDAMAME Posture binary is already present. Checking status..."
            # Continue even if there are errors; capture both stdout and stderr
            $EDAMAME_POSTURE_CMD status > posture_status.txt 2>&1 || true

            # Check if the output indicates Error getting connection status: transport error
            if grep -q "Error getting connection status: transport error" posture_status.txt; then
              echo "edamame_posture is installed but isn't connected"
            else
              connected="$({ grep -i 'connected:' posture_status.txt | awk -F': ' '{print $2}'; } || true)"
              connected="${connected:-false}"
              echo "edamame_posture is connected: $connected"
            fi

            current_user="$({ grep -i 'Connected user' posture_status.txt | head -n1 | sed -E 's/.*Connected user:[[:space:]]*//I' | xargs; } || true)"
            current_domain="$({ grep -i 'Connected domain' posture_status.txt | head -n1 | sed -E 's/.*Connected domain:[[:space:]]*//I' | xargs; } || true)"

            # Compare with inputs; restart if mismatched
            if [[ "$connected" == "true" ]]; then
              mismatch=false
              if [[ -n "${{ inputs.edamame_user }}" && "$current_user" != "${{ inputs.edamame_user }}" ]]; then
                mismatch=true
              fi
              if [[ -n "${{ inputs.edamame_domain }}" && "$current_domain" != "${{ inputs.edamame_domain }}" ]]; then
                mismatch=true
              fi

              if [[ "$mismatch" == "true" ]]; then
                echo "Connected user/domain ($current_user / $current_domain) differ from requested (${{ inputs.edamame_user }} / ${{ inputs.edamame_domain }}). Restarting posture..."
                $EDAMAME_POSTURE_CMD stop > /dev/null 2>&1 || true
                if command -v systemctl >/dev/null 2>&1; then
                  sudo systemctl stop edamame_posture.service 2>/dev/null || true
                elif command -v rc-service >/dev/null 2>&1; then
                  sudo rc-service edamame_posture stop 2>/dev/null || true
                fi
                SKIP_START=false
              else
                SKIP_START=true
              fi
            fi

            if [[ "$connected" == "true" ]]; then
              if [[ "$SKIP_START" == "true" ]]; then
                echo "EDAMAME Posture is already running with the requested credentials. Skipping start process."
              else
                echo "Connected posture will be restarted with the requested credentials."
              fi
            else
              echo "EDAMAME Posture service is installed but isn't connected, it will be automatically started in the background."
            fi
          fi

          # Only continue with the start process if we're not skipping it
          if [[ "$SKIP_START" != "true" ]]; then
            # Add a unique suffix to the edamame_id to avoid conflicts using matrix jobs
            # ms since epoch
            IDSUFFIX=$(node -e "console.log(Date.now())")

            START_ARGS=(
              start
              --user "${{ inputs.edamame_user }}"
              --domain "${{ inputs.edamame_domain }}"
              --pin "${{ inputs.edamame_pin }}"
              --device-id "${{ inputs.edamame_id }}_$IDSUFFIX"
            )

            if [[ "${{ inputs.network_scan }}" == "true" ]]; then
              START_ARGS+=(--network-scan)
            fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

            if [[ "${{ inputs.whitelist }}" != "" ]]; then
              START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
            fi

            if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
              if [[ "${{ inputs.whitelist }}" == "" ]]; then
                # We only have a check_whitelist=true but no whitelist name
                # In this case, we don't pass the fail-on-whitelist flag to the daemon at start
                # The daemon will be updated later with the custom whitelist
                echo "Checking whitelist requested but no whitelist name provided. Will wait for custom whitelist to be loaded."
              else
                START_ARGS+=(--fail-on-whitelist)
              fi
            fi

            if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
              START_ARGS+=(--fail-on-blacklist)
            fi

            if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
              START_ARGS+=(--fail-on-anomalous)
            fi

            if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
              START_ARGS+=(--cancel-on-violation)
            fi

            if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
              START_ARGS+=(--include-local-traffic)
            fi

            if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
              START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
            fi

            # Only add agentic-provider flag if explicitly set and not "none"
            # Default is "none" which means no agentic provider
            AGENTIC_PROVIDER="${{ inputs.agentic_provider }}"
            if [[ -n "$AGENTIC_PROVIDER" && "$AGENTIC_PROVIDER" != "none" && "$AGENTIC_PROVIDER" != "false" ]]; then
              START_ARGS+=(--agentic-provider "$AGENTIC_PROVIDER")
            fi

            if [[ "${{ inputs.agentic_interval }}" != "" && "${{ inputs.agentic_interval }}" != "3600" ]]; then
              START_ARGS+=(--agentic-interval "${{ inputs.agentic_interval }}")
            fi

            # Create cancellation script if cancel_on_violation is enabled
            # This allows the daemon to cancel the pipeline WITHOUT having direct access to tokens
            # The script runs in the original environment context and has access to CI variables
            if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
              echo "[WARNING] cancel_on_violation enabled - creating pipeline cancellation script"
              
              # Determine script path
              if [[ -n "${{ inputs.cancel_pipeline_script }}" ]]; then
                CANCEL_SCRIPT_PATH="${{ inputs.cancel_pipeline_script }}"
              else
                # Use /tmp instead of $HOME because daemon runs with sudo and has different $HOME
                CANCEL_SCRIPT_PATH="/tmp/cancel_pipeline.sh"
              fi
              
              echo "Creating cancellation script at: $CANCEL_SCRIPT_PATH"
              
              # Capture CI environment variables now (before sudo)
              # The script will have these values embedded, not rely on runtime environment
              CAPTURED_GITHUB_ACTIONS="${GITHUB_ACTIONS:-}"
              CAPTURED_GITHUB_RUN_ID="${GITHUB_RUN_ID:-}"
              CAPTURED_GITHUB_REPOSITORY="${GITHUB_REPOSITORY:-}"
              CAPTURED_GITHUB_TOKEN="${{ inputs.token }}"
              CAPTURED_GITLAB_CI="${GITLAB_CI:-}"
              CAPTURED_CI_PROJECT_ID="${CI_PROJECT_ID:-}"
              CAPTURED_CI_PIPELINE_ID="${CI_PIPELINE_ID:-}"
              CAPTURED_GITLAB_TOKEN="${GITLAB_TOKEN:-}"
              CAPTURED_CI_JOB_TOKEN="${CI_JOB_TOKEN:-}"
              
              # Create cancellation script using printf to avoid YAML heredoc issues
              printf '#!/bin/bash\n# EDAMAME Pipeline Cancellation Script\nset -e\nREASON="${1:-Policy violation detected}"\necho "=== EDAMAME Pipeline Cancellation ==="\necho "Reason: $REASON"\nGITHUB_ACTIONS="%s"\nGITHUB_RUN_ID="%s"\nGITHUB_REPOSITORY="%s"\nGITHUB_TOKEN="%s"\nGITLAB_CI="%s"\nCI_PROJECT_ID="%s"\nCI_PIPELINE_ID="%s"\nGITLAB_TOKEN="%s"\nCI_JOB_TOKEN="%s"\nif [[ -n "$GITHUB_ACTIONS" ]]; then\n  export GH_TOKEN="$GITHUB_TOKEN"\n  gh run cancel "$GITHUB_RUN_ID" --repo "$GITHUB_REPOSITORY" && echo "[OK] Cancelled" || echo "[ERROR] Failed"\nelif [[ -n "$GITLAB_CI" ]]; then\n  TOKEN="${GITLAB_TOKEN:-$CI_JOB_TOKEN}"\n  curl -s -X POST -H "PRIVATE-TOKEN: $TOKEN" "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/pipelines/${CI_PIPELINE_ID}/cancel"\nelse\n  echo "[ERROR] No CI environment detected"\n  exit 1\nfi\n' \
                "$CAPTURED_GITHUB_ACTIONS" "$CAPTURED_GITHUB_RUN_ID" "$CAPTURED_GITHUB_REPOSITORY" "$CAPTURED_GITHUB_TOKEN" \
                "$CAPTURED_GITLAB_CI" "$CAPTURED_CI_PROJECT_ID" "$CAPTURED_CI_PIPELINE_ID" "$CAPTURED_GITLAB_TOKEN" "$CAPTURED_CI_JOB_TOKEN" \
                > "$CANCEL_SCRIPT_PATH"

              chmod 700 "$CANCEL_SCRIPT_PATH"
              
              # Export the script path for the daemon to find
              export EDAMAME_CANCEL_PIPELINE_SCRIPT="$CANCEL_SCRIPT_PATH"
              
              echo "[OK] Cancellation script created and configured"
              echo "   Script path: $CANCEL_SCRIPT_PATH"
              echo "   The daemon will execute this script when violations are detected"
              echo "   The script has access to CI tokens from the original environment"
            fi

            echo "Starting EDAMAME Posture..."
            $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
            
            echo "Waiting for connection..."
            $EDAMAME_POSTURE_CMD wait-for-connection || { cd; find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"; exit 1; }
          fi
        elif [[ "${{ inputs.disconnected_mode }}" == "true" ]]; then
          echo "Starting EDAMAME Posture in disconnected mode..."
          
          # Stop any existing posture process before starting in disconnected mode
          # This handles cases where disconnected mode is called multiple times or after connected mode
          echo "Stopping any existing EDAMAME Posture process..."
          
          # Try to stop via CLI first
          $EDAMAME_POSTURE_CMD stop > /dev/null 2>&1 || true
          
          # On Linux, also ensure systemd service is stopped (in case it was started manually)
          if [[ "$RUNNER_OS" == "Linux" ]] && command -v systemctl >/dev/null 2>&1; then
            sudo systemctl stop edamame_posture.service 2>/dev/null || true
          fi
          
          # Give it a moment to fully stop
          sleep 2

          START_ARGS=(background-start-disconnected)

          if [[ "${{ inputs.network_scan }}" == "true" ]]; then
            START_ARGS+=(--network-scan)
          fi

          if [[ "${{ inputs.packet_capture }}" == "true" || ( "${{ inputs.packet_capture }}" == "auto" && "${{ inputs.network_scan }}" == "true" ) ]]; then
            START_ARGS+=(--packet-capture)
          fi

          if [[ "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--whitelist "${{ inputs.whitelist }}")
          fi

          if [[ "${{ inputs.check_whitelist }}" == "true" || "${{ inputs.whitelist }}" != "" ]]; then
            START_ARGS+=(--fail-on-whitelist)
          fi

          if [[ "${{ inputs.check_blacklist }}" == "true" ]]; then
            START_ARGS+=(--fail-on-blacklist)
          fi

          if [[ "${{ inputs.check_anomalous }}" == "true" ]]; then
            START_ARGS+=(--fail-on-anomalous)
          fi

          if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
            START_ARGS+=(--cancel-on-violation)
          fi

          if [[ "${{ inputs.include_local_traffic }}" == "true" ]]; then
            START_ARGS+=(--include-local-traffic)
          fi

          if [[ "${{ inputs.agentic_mode }}" != "disabled" && "${{ inputs.agentic_mode }}" != "" ]]; then
            START_ARGS+=(--agentic-mode "${{ inputs.agentic_mode }}")
          fi

          # Create cancellation script if cancel_on_violation is enabled
          # This allows the daemon to cancel the pipeline WITHOUT having direct access to tokens
          # The script runs in the original environment context and has access to CI variables
          if [[ "${{ inputs.cancel_on_violation }}" == "true" ]]; then
            echo "[WARNING] cancel_on_violation enabled - creating pipeline cancellation script"
            
            # Determine script path
            if [[ -n "${{ inputs.cancel_pipeline_script }}" ]]; then
              CANCEL_SCRIPT_PATH="${{ inputs.cancel_pipeline_script }}"
            else
              # Use /tmp instead of $HOME because daemon runs with sudo and has different $HOME
              CANCEL_SCRIPT_PATH="/tmp/cancel_pipeline.sh"
            fi
            
            echo "Creating cancellation script at: $CANCEL_SCRIPT_PATH"
            
            # Capture CI environment variables now (before sudo)
            # The script will have these values embedded, not rely on runtime environment
            CAPTURED_GITHUB_ACTIONS="${GITHUB_ACTIONS:-}"
            CAPTURED_GITHUB_RUN_ID="${GITHUB_RUN_ID:-}"
            CAPTURED_GITHUB_REPOSITORY="${GITHUB_REPOSITORY:-}"
            CAPTURED_GITHUB_TOKEN="${{ inputs.token }}"
            CAPTURED_GITLAB_CI="${GITLAB_CI:-}"
            CAPTURED_CI_PROJECT_ID="${CI_PROJECT_ID:-}"
            CAPTURED_CI_PIPELINE_ID="${CI_PIPELINE_ID:-}"
            CAPTURED_GITLAB_TOKEN="${GITLAB_TOKEN:-}"
            CAPTURED_CI_JOB_TOKEN="${CI_JOB_TOKEN:-}"
            
            # Create cancellation script using printf to avoid YAML heredoc issues
            printf '#!/bin/bash\n# EDAMAME Pipeline Cancellation Script\nset -e\nREASON="${1:-Policy violation detected}"\necho "=== EDAMAME Pipeline Cancellation ==="\necho "Reason: $REASON"\nGITHUB_ACTIONS="%s"\nGITHUB_RUN_ID="%s"\nGITHUB_REPOSITORY="%s"\nGITHUB_TOKEN="%s"\nGITLAB_CI="%s"\nCI_PROJECT_ID="%s"\nCI_PIPELINE_ID="%s"\nGITLAB_TOKEN="%s"\nCI_JOB_TOKEN="%s"\nif [[ -n "$GITHUB_ACTIONS" ]]; then\n  export GH_TOKEN="$GITHUB_TOKEN"\n  gh run cancel "$GITHUB_RUN_ID" --repo "$GITHUB_REPOSITORY" && echo "[OK] Cancelled" || echo "[ERROR] Failed"\nelif [[ -n "$GITLAB_CI" ]]; then\n  TOKEN="${GITLAB_TOKEN:-$CI_JOB_TOKEN}"\n  curl -s -X POST -H "PRIVATE-TOKEN: $TOKEN" "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/pipelines/${CI_PIPELINE_ID}/cancel"\nelse\n  echo "[ERROR] No CI environment detected"\n  exit 1\nfi\n' \
              "$CAPTURED_GITHUB_ACTIONS" "$CAPTURED_GITHUB_RUN_ID" "$CAPTURED_GITHUB_REPOSITORY" "$CAPTURED_GITHUB_TOKEN" \
              "$CAPTURED_GITLAB_CI" "$CAPTURED_CI_PROJECT_ID" "$CAPTURED_CI_PIPELINE_ID" "$CAPTURED_GITLAB_TOKEN" "$CAPTURED_CI_JOB_TOKEN" \
              > "$CANCEL_SCRIPT_PATH"

            chmod 700 "$CANCEL_SCRIPT_PATH"
            
            # Export the script path for the daemon to find
            export EDAMAME_CANCEL_PIPELINE_SCRIPT="$CANCEL_SCRIPT_PATH"
            
            echo "[OK] Cancellation script created and configured"
            echo "   Script path: $CANCEL_SCRIPT_PATH"
            echo "   The daemon will execute this script when violations are detected"
            echo "   The script has access to CI tokens from the original environment"
          fi

          $EDAMAME_POSTURE_CMD "${START_ARGS[@]}"
        fi
      shell: bash

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode is enabled"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "[ERROR] ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "[OK] Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "[OK] Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Calculate difference (allow small differences for deduplication/filtering)
              DIFF=$((FILE_ENDPOINT_COUNT - DAEMON_ENDPOINT_COUNT))
              # Calculate absolute value
              if [[ "$DIFF" -lt 0 ]]; then
                ABS_DIFF=$((0 - DIFF))
              else
                ABS_DIFF=$DIFF
              fi
              
              if [[ "$DAEMON_ENDPOINT_COUNT" != "$FILE_ENDPOINT_COUNT" ]]; then
                if [[ "$ABS_DIFF" -le 2 ]]; then
                  # Small difference (1-2 endpoints) - likely deduplication or filtering
                  echo ""
                  echo "[WARNING]  Warning: Small endpoint count difference (daemon may have deduplicated/filtered)"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This is likely expected behavior - daemon may deduplicate or filter invalid endpoints."
                  echo "Continuing with daemon whitelist count: $DAEMON_ENDPOINT_COUNT"
                  echo "[OK] Endpoint count verified (small difference acceptable): $DAEMON_ENDPOINT_COUNT endpoints"
                else
                  # Large difference - indicates real problem
                  echo ""
                  echo "[ERROR] ERROR: Significant endpoint count mismatch between file and daemon!"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This indicates the whitelist was not loaded correctly into the daemon."
                  echo "Augmentation will fail or produce incorrect results."
                  echo ""
                  echo "Debugging info:"
                  echo "  - File: $WHITELIST_FILE"
                  echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                  echo "  - Daemon whitelist name: $LOADED_NAME"
                  echo "  - Daemon status:"
                  $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                  exit 1
                fi
              else
                echo "[OK] Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints match exactly"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "[OK] Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "[OK] Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "[OK] Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode is enabled"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "[ERROR] ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "[OK] Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "[OK] Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Calculate difference (allow small differences for deduplication/filtering)
              DIFF=$((FILE_ENDPOINT_COUNT - DAEMON_ENDPOINT_COUNT))
              # Calculate absolute value
              if [[ "$DIFF" -lt 0 ]]; then
                ABS_DIFF=$((0 - DIFF))
              else
                ABS_DIFF=$DIFF
              fi
              
              if [[ "$DAEMON_ENDPOINT_COUNT" != "$FILE_ENDPOINT_COUNT" ]]; then
                if [[ "$ABS_DIFF" -le 2 ]]; then
                  # Small difference (1-2 endpoints) - likely deduplication or filtering
                  echo ""
                  echo "[WARNING]  Warning: Small endpoint count difference (daemon may have deduplicated/filtered)"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This is likely expected behavior - daemon may deduplicate or filter invalid endpoints."
                  echo "Continuing with daemon whitelist count: $DAEMON_ENDPOINT_COUNT"
                  echo "[OK] Endpoint count verified (small difference acceptable): $DAEMON_ENDPOINT_COUNT endpoints"
                else
                  # Large difference - indicates real problem
                  echo ""
                  echo "[ERROR] ERROR: Significant endpoint count mismatch between file and daemon!"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This indicates the whitelist was not loaded correctly into the daemon."
                  echo "Augmentation will fail or produce incorrect results."
                  echo ""
                  echo "Debugging info:"
                  echo "  - File: $WHITELIST_FILE"
                  echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                  echo "  - Daemon whitelist name: $LOADED_NAME"
                  echo "  - Daemon status:"
                  $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                  exit 1
                fi
              else
                echo "[OK] Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints match exactly"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "[OK] Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "[OK] Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "[OK] Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash

    - name: Wait for API access to be granted if requested
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        if [[ "${{ inputs.wait_for_api }}" == "true" ]]; then
          echo "Waiting for GitHub API access to be granted..."
          echo "Note: This runs AFTER the daemon has started and connected"
          echo "      so the daemon can whitelist the runner IP via EDAMAME backend"
          attempts=0
          timeout=true
          last_error=""
          
          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Testing API access..."
            
            # We use the GitHub token to access the run details API, which tests org-level IP allowlist access
            # This endpoint requires authentication even for public repos and is blocked by IP allowlists
            # Capture both stdout and stderr to see what's actually happening
            if output=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }} 2>&1); then
              timeout=false
              echo "[OK] API access granted!"
              break
            else
              exit_code=$?
              last_error="$output"
              echo "[WARNING] API call failed with exit code $exit_code"
              echo "Error output: $last_error"
              
              if [ $attempts -lt 10 ]; then
                echo "Waiting 60 seconds before retry..."
                sleep 60
              fi
            fi
          done

          # Calculate elapsed time (first attempt is immediate, subsequent attempts wait 60s each)
          if [ $attempts -gt 1 ]; then
            elapsed_time=$(( (attempts - 1) * 60 ))
          else
            elapsed_time=0
          fi
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo ""
            echo "[ERROR] Timeout occurred while waiting for API access."
            echo "Total attempts: $attempts"
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            echo "Last error: $last_error"
            echo ""
            echo "Dumping EDAMAME logs for debugging..."
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Detect auto-whitelist mode
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        
        # Check if auto-whitelist is enabled by looking for config file
        if [[ -f "auto_whitelist_config.json" ]]; then
          echo "Auto-whitelist mode detected"
          echo "AUTO_WHITELIST_ENABLED=true" >> $GITHUB_ENV
          
          # Load configuration
          ARTIFACT_NAME=$(jq -r '.artifact_name' auto_whitelist_config.json)
          THRESHOLD=$(jq -r '.stability_threshold' auto_whitelist_config.json)
          CONSECUTIVE=$(jq -r '.stability_consecutive_runs' auto_whitelist_config.json)
          MAX_ITER=$(jq -r '.max_iterations' auto_whitelist_config.json)
          
          echo "AUTO_WHITELIST_ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_THRESHOLD=$THRESHOLD" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_CONSECUTIVE=$CONSECUTIVE" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_MAX_ITER=$MAX_ITER" >> $GITHUB_ENV
          
          echo "Auto-whitelist configuration:"
          echo "  - Artifact name: $ARTIFACT_NAME"
          echo "  - Stability threshold: $THRESHOLD%"
          echo "  - Consecutive runs required: $CONSECUTIVE"
          echo "  - Max iterations: $MAX_ITER"
        else
          echo "No auto-whitelist configuration found"
          echo "AUTO_WHITELIST_ENABLED=false" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Load auto-whitelist state for dump sessions
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo "Loading auto-whitelist state..."
        echo "Current directory: $(pwd)"
        echo "Files in current directory:"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        # Check if files exist
        if [[ -f "auto_whitelist.json" && -f "auto_whitelist_iteration.txt" ]]; then
          ITERATION=$(cat auto_whitelist_iteration.txt)
          echo "Found auto-whitelist: iteration $ITERATION"
          echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Count endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "Current whitelist contains $ENDPOINT_COUNT endpoints"
          fi
          
          # Verify daemon is running and whitelist is loaded
          if [[ "$ITERATION" -gt 0 ]]; then
            echo "Verifying daemon is running and whitelist is active (iteration $ITERATION)..."
            
            # First check if daemon is responsive
            if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
              echo "ERROR: Daemon is not running or not responsive"
              echo "The daemon should be running from the setup step"
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status 2>&1 || echo "(daemon not responding)"
              exit 1
            fi
            
            # Now check whitelist
            WHITELIST_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "")
            if [[ "$WHITELIST_NAME" != "custom_whitelist" ]]; then
              echo "ERROR: Whitelist is NOT loaded in daemon"
              echo "Expected: custom_whitelist"
              echo "Got: $WHITELIST_NAME"
              echo "Whitelist must be loaded for augmentation to work correctly"
              exit 1
            fi
            echo "Daemon is running and whitelist 'custom_whitelist' is active"
          fi
        else
          echo "Warning: No auto-whitelist files found"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
        fi
      shell: bash

    - name: Download auto-whitelist artifact if in auto-whitelist mode
      if: ${{ inputs.auto_whitelist == 'true' && inputs.dump_sessions_log != 'true' }}
      run: |
        set +e  # Don't exit on error - artifact download failures are expected
        cd
        
        STATE_FILE="auto_whitelist_state.json"
        STATE_ARTIFACT_NAME="${{ inputs.auto_whitelist_state_artifact_name }}"
        echo "Attempting to download state artifact: $STATE_ARTIFACT_NAME"
        STATE_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
          --jq '.artifacts[] | select(.name == "'"$STATE_ARTIFACT_NAME"'" and .expired == false) | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' 2>&1)
        STATE_EXIT=$?
        if [[ $STATE_EXIT -ne 0 ]]; then
          if echo "$STATE_INFO" | grep -q "IP allow list enabled"; then
            echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while fetching state artifact"
            echo "Response:"
            echo "$STATE_INFO"
            exit 1
          else
            echo "[WARNING]  Failed to query state artifacts: $STATE_INFO"
            STATE_INFO=""
          fi
        else
          STATE_INFO=$(echo "$STATE_INFO" | sort -t':' -k4 | tail -1)
        fi
        if [[ -n "$STATE_INFO" ]]; then
          IFS='::' read -r STATE_ARTIFACT_ID STATE_SOURCE_RUN_ID STATE_SOURCE_RUN_NUMBER STATE_CREATED_AT <<< "$STATE_INFO"
          echo "Found state artifact ID $STATE_ARTIFACT_ID from run $STATE_SOURCE_RUN_ID (run number $STATE_SOURCE_RUN_NUMBER, created $STATE_CREATED_AT)"
          TEMP_STATE_DIR=$(mktemp -d)
          STATE_ZIP="$TEMP_STATE_DIR/state.zip"
          if gh api "repos/${{ github.repository }}/actions/artifacts/$STATE_ARTIFACT_ID/zip" > "$STATE_ZIP"; then
            unzip -q -o "$STATE_ZIP" -d "$TEMP_STATE_DIR"
            FOUND_STATE=$(find "$TEMP_STATE_DIR" -name "$STATE_FILE" -type f | head -1)
            if [[ -n "$FOUND_STATE" && -f "$FOUND_STATE" ]]; then
              cp "$FOUND_STATE" ./"$STATE_FILE"
              echo "[OK] State file downloaded"
              if command -v jq &> /dev/null; then
                LAST_RUN_ID=$(jq -r '.last_run_id // empty' "$STATE_FILE")
                LAST_ITERATION=$(jq -r '.last_iteration // empty' "$STATE_FILE")
                RECORDED_ARTIFACT=$(jq -r '.artifact_name // empty' "$STATE_FILE")
                if [[ -n "$LAST_RUN_ID" ]]; then
                  echo "Recorded last run ID: $LAST_RUN_ID (iteration: ${LAST_ITERATION:-unknown})"
                  echo "AUTO_WHITELIST_LAST_RUN_ID=$LAST_RUN_ID" >> $GITHUB_ENV
                  echo "AUTO_WHITELIST_LAST_ITERATION=${LAST_ITERATION:-}" >> $GITHUB_ENV
                fi
                if [[ -n "$RECORDED_ARTIFACT" ]]; then
                  echo "Recorded artifact name: $RECORDED_ARTIFACT"
                  echo "AUTO_WHITELIST_LAST_ARTIFACT_NAME=$RECORDED_ARTIFACT" >> $GITHUB_ENV
                fi
              fi
            else
              echo "[WARNING]  State artifact zip downloaded but $STATE_FILE not found"
            fi
          else
            echo "[WARNING]  Failed to download state artifact zip"
          fi
          rm -rf "$TEMP_STATE_DIR" 2>/dev/null || true
        else
          echo "No previous state artifact found"
        fi
        # Try to download the artifact from the previous run
        echo "Attempting to download auto-whitelist artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        # Find the most recent successful workflow run with the artifact
        # Since each workflow uses a unique artifact name, we can search across all recent runs
        ARTIFACT_FOUND=false
        MAX_ATTEMPTS=10
        CURRENT_RUN_ID=${{ github.run_id }}
        
        echo "Current run ID: $CURRENT_RUN_ID"
        echo "Looking for artifact: ${{ inputs.auto_whitelist_artifact_name }}"
        
        TARGET_RUN_ID="${AUTO_WHITELIST_LAST_RUN_ID:-}"
        TARGET_ARTIFACT_NAME="${AUTO_WHITELIST_LAST_ARTIFACT_NAME:-${{ inputs.auto_whitelist_artifact_name }}}"
        
        if [[ -n "$TARGET_RUN_ID" ]]; then
          echo "Attempting to download artifact from recorded run ID: $TARGET_RUN_ID"
          TEMP_DOWNLOAD_DIR=$(mktemp -d)
          DOWNLOAD_OUTPUT=$(gh run download "$TARGET_RUN_ID" --repo ${{ github.repository }} --name "$TARGET_ARTIFACT_NAME" --dir "$TEMP_DOWNLOAD_DIR" 2>&1)
          DOWNLOAD_EXIT=$?
          if [[ $DOWNLOAD_EXIT -eq 0 ]]; then
            FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
            if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
              cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
              find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                cp "$file" ./ 2>/dev/null || true
              done
              if [[ -f "auto_whitelist.json" ]]; then
                echo "[OK] Successfully downloaded artifact from recorded run $TARGET_RUN_ID"
                ARTIFACT_FOUND=true
              fi
            fi
          else
            echo "[WARNING]  Failed to download artifact from recorded run $TARGET_RUN_ID"
          fi
          rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
        fi
        
        if [[ "$ARTIFACT_FOUND" != "true" ]]; then
          echo "Searching for previous successful artifacts..."
          PREVIOUS_SUCCESS_FOUND=false
          ARTIFACT_INFO=$(gh api "repos/${{ github.repository }}/actions/artifacts" --paginate \
            --jq '.artifacts[] | select(.name == "'"${{ inputs.auto_whitelist_artifact_name }}"'" and .expired == false and (.workflow_run.id // 0) != '"$CURRENT_RUN_ID"') | "\(.id)::\(.workflow_run.id // 0)::\(.workflow_run.run_number // 0)::\(.created_at)"' \
            2>&1)
          API_EXIT=$?
          if [[ $API_EXIT -ne 0 ]]; then
            if echo "$ARTIFACT_INFO" | grep -q "IP allow list enabled"; then
              echo "[ERROR] ERROR: GitHub API call blocked by organization IP allow list while listing artifacts"
              echo "Response:"
              echo "$ARTIFACT_INFO"
              exit 1
            else
              echo "[WARNING]  Failed to query artifacts: $ARTIFACT_INFO"
              ARTIFACT_INFO=""
            fi
          else
            ARTIFACT_INFO=$(echo "$ARTIFACT_INFO" | sort -t':' -k4 | tail -1)
          fi
          
          if [[ -n "$ARTIFACT_INFO" ]]; then
            PREVIOUS_SUCCESS_FOUND=true
            IFS='::' read -r ARTIFACT_ID SOURCE_RUN_ID SOURCE_RUN_NUMBER CREATED_AT <<< "$ARTIFACT_INFO"
            echo "Found artifact ID $ARTIFACT_ID from run $SOURCE_RUN_ID (run number $SOURCE_RUN_NUMBER, created $CREATED_AT)"
            
            TEMP_DOWNLOAD_DIR=$(mktemp -d)
            ARTIFACT_ZIP="$TEMP_DOWNLOAD_DIR/artifact.zip"
            
            if gh api "repos/${{ github.repository }}/actions/artifacts/$ARTIFACT_ID/zip" > "$ARTIFACT_ZIP"; then
              unzip -q -o "$ARTIFACT_ZIP" -d "$TEMP_DOWNLOAD_DIR"
              FOUND_FILE=$(find "$TEMP_DOWNLOAD_DIR" -name "auto_whitelist.json" -type f | head -1)
              if [[ -n "$FOUND_FILE" && -f "$FOUND_FILE" ]]; then
                cp "$FOUND_FILE" ./auto_whitelist.json 2>/dev/null || true
                find "$TEMP_DOWNLOAD_DIR" \( -name "auto_whitelist*.txt" -o -name "auto_whitelist*.json" \) -type f | while read -r file; do
                  cp "$file" ./ 2>/dev/null || true
                done
                if [[ -f "auto_whitelist.json" ]]; then
                  echo "[OK] Successfully downloaded artifact from run $SOURCE_RUN_ID"
                  ARTIFACT_FOUND=true
                fi
              else
                echo "[WARNING]  Artifact zip downloaded but auto_whitelist.json not found"
              fi
            else
              echo "[WARNING]  Failed to download artifact zip for ID $ARTIFACT_ID"
            fi
            
            rm -rf "$TEMP_DOWNLOAD_DIR" 2>/dev/null || true
          else
            echo "No matching artifacts found (name=${{ inputs.auto_whitelist_artifact_name }})"
          fi
        fi
        
        if [[ "$ARTIFACT_FOUND" == "false" ]]; then
          echo "[INFO]  No artifact found from previous runs"
          if [[ "$PREVIOUS_SUCCESS_FOUND" == "false" ]]; then
            echo "This is expected for the first iteration"
          else
            echo "[WARNING]  No artifact found despite previous successful runs - treating as first run"
          fi
        fi

        # Note: We don't use GitHub API fallback because it's blocked by IP allow lists
        # gh run download uses GitHub token authentication which works better
        
        # Note: We don't fail-fast here even if previous runs exist without artifacts
        # because those runs might have failed before uploading artifacts
        # The daemon will simply start in listen-only mode if no artifact is found
        
        # Check if the whitelist file exists (either from gh run download or manually downloaded via actions/download-artifact)
        echo ""
        echo "=== Checking for downloaded whitelist artifact ==="
        echo "Current directory: $(pwd)"
        echo "Looking for file: auto_whitelist.json"
        ls -la auto_whitelist* 2>/dev/null || echo "No auto_whitelist* files found"
        
        if [[ -f "auto_whitelist.json" ]]; then
          echo "[OK] Whitelist file found: auto_whitelist.json"
          echo "File size: $(wc -c < auto_whitelist.json) bytes"
          
          # Read iteration count
          if [[ -f "auto_whitelist_iteration.txt" ]]; then
            ITERATION=$(cat auto_whitelist_iteration.txt)
            echo "[OK] Found iteration file: auto_whitelist_iteration.txt"
            echo "Current iteration: $ITERATION"
            echo "AUTO_WHITELIST_ITERATION=$ITERATION" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_iteration.txt not found, defaulting to iteration 1"
            echo "AUTO_WHITELIST_ITERATION=1" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_EXISTS=true" >> $GITHUB_ENV
          fi
          
          # Read consecutive stable runs count
          if [[ -f "auto_whitelist_stable_count.txt" ]]; then
            STABLE_COUNT=$(cat auto_whitelist_stable_count.txt)
            echo "Consecutive stable runs: $STABLE_COUNT"
            echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
          else
            echo "[WARNING]  Warning: auto_whitelist_stable_count.txt not found, defaulting to 0"
            echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          fi
          
          # Verify the whitelist has endpoints
          if command -v jq &> /dev/null; then
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
            echo "[OK] Downloaded whitelist contains $ENDPOINT_COUNT endpoints"
            echo "This whitelist will be loaded into the daemon in the next step"
          else
            echo "[WARNING]  Warning: jq not available, cannot count endpoints"
          fi
          echo "=== Artifact download check complete ==="
        else
          echo "[ERROR] No whitelist file found, treating as first run (listen-only mode)"
          echo "This means:"
          echo "  - No artifact was downloaded from previous runs"
          echo "  - Will initialize empty whitelist"
          echo "  - Will create initial whitelist from captured traffic"
          echo "AUTO_WHITELIST_ITERATION=0" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_EXISTS=false" >> $GITHUB_ENV
          echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
          echo "=== Artifact download check complete ==="
        fi
        echo ""
        
        # Save auto-whitelist configuration to state file
        # This configuration will be used when dump_sessions_log is called
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo "Saving auto-whitelist configuration..."
          echo "Current directory: $(pwd)"
          jq -n \
            --arg artifact "${{ inputs.auto_whitelist_artifact_name }}" \
            --arg threshold "${{ inputs.auto_whitelist_stability_threshold }}" \
            --arg consecutive "${{ inputs.auto_whitelist_stability_consecutive_runs }}" \
            --arg max_iter "${{ inputs.auto_whitelist_max_iterations }}" \
            '{
              artifact_name: $artifact,
              stability_threshold: $threshold,
              stability_consecutive_runs: $consecutive,
              max_iterations: $max_iter
            }' > auto_whitelist_config.json
          echo "[OK] Config saved to: $(pwd)/auto_whitelist_config.json"
          echo "Config contents:"
          cat auto_whitelist_config.json
        fi
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}

    - name: Apply custom whitelists if provided
      if: ${{ inputs.dump_sessions_log != 'true' }}
      run: |
        echo "=== Apply Custom Whitelists Step ==="
        echo "auto_whitelist: ${{ inputs.auto_whitelist }}"
        echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
        
        if [[ -n "${{ inputs.custom_whitelists_path }}" && "${{ inputs.create_custom_whitelists }}" != "true" && "${{ inputs.set_custom_whitelists }}" == "true" ]]; then
          cd
          if [[ -f "${{ inputs.custom_whitelists_path }}" ]]; then
            # Check if whitelist file has endpoints before loading
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Whitelist file contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Whitelist file '${{ inputs.custom_whitelists_path }}' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - The whitelist was created before any traffic was captured"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify whitelist endpoints. Proceeding anyway..."
            fi
            
            echo "Applying custom whitelists from: ${{ inputs.custom_whitelists_path }}"
            $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "${{ inputs.custom_whitelists_path }}"
            echo "Custom whitelists applied successfully"
          else
            echo "Error: Custom whitelists file not found at ${{ inputs.custom_whitelists_path }}"
            exit 1
          fi
        fi
        
        # Auto-whitelist mode: apply previous iteration's whitelist if it exists
        if [[ "${{ inputs.auto_whitelist }}" == "true" ]]; then
          echo ""
          echo "=== Auto-Whitelist Mode: Loading Artifact into Daemon ==="
          echo "Auto-whitelist mode is enabled"
          echo "AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "AUTO_WHITELIST_ITERATION: $AUTO_WHITELIST_ITERATION"
          cd
          
          # CRITICAL: Verify daemon is ready BEFORE applying whitelist
          echo "Checking daemon readiness..."
          if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
            echo "[ERROR] ERROR: Daemon is not responding!"
            echo "Cannot apply whitelist - daemon must be running and ready."
            $EDAMAME_POSTURE_CMD status || true
            exit 1
          fi
          echo "[OK] Daemon is ready"
          
          if [[ "$AUTO_WHITELIST_EXISTS" == "true" && -f "auto_whitelist.json" ]]; then
            echo ""
            echo ">>> LOADING ARTIFACT WHITELIST INTO DAEMON <<<"
            echo "Found artifact from previous iteration: $AUTO_WHITELIST_ITERATION"
            echo "This is NOT the first run - loading saved whitelist into daemon"
            
            # Use absolute path for reliability
            WHITELIST_FILE="$(pwd)/auto_whitelist.json"
            echo "Auto-whitelist mode: Applying whitelist from iteration $AUTO_WHITELIST_ITERATION to daemon"
            echo "File path: $WHITELIST_FILE"
            echo "File details: $(ls -lh "$WHITELIST_FILE")"
            
            # CRITICAL: Count endpoints in downloaded file BEFORE loading
            if command -v jq &> /dev/null; then
              FILE_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              echo "Downloaded whitelist file contains $FILE_ENDPOINT_COUNT endpoints"
              
              if [[ "$FILE_ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Auto-whitelist file 'auto_whitelist.json' is empty (no endpoints)"
                echo "Skipping whitelist load - empty whitelists would mark all sessions as non-conforming"
                echo "This can happen if no network sessions were captured in the previous iteration"
                exit 0
              fi
            else
              echo "[WARNING]  Warning: jq not available, cannot verify endpoint count"
              FILE_ENDPOINT_COUNT="unknown"
            fi
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply whitelist with error checking
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: set-custom-whitelists-from-file command FAILED!"
              echo "   Exit code: $?"
              echo "   File: $WHITELIST_FILE"
              echo "   File exists: $([ -f "$WHITELIST_FILE" ] && echo 'yes' || echo 'no')"
              echo "   File size: $(wc -c < "$WHITELIST_FILE" 2>/dev/null || echo '0') bytes"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Command executed successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              echo ""
              echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
              echo "Without it, augmentation will create fresh whitelists instead of merging."
              echo ""
              echo "Debugging info:"
              echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
              echo "  - File: $WHITELIST_FILE"
              echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
              echo "  - File first 200 chars:"
              head -c 200 "$WHITELIST_FILE" | cat -A || echo "    (cannot read file)"
              echo ""
              echo "  - Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "  - Daemon whitelist details:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            echo "[OK] Whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count matches between file and daemon
            if [[ "$FILE_ENDPOINT_COUNT" != "unknown" ]]; then
              echo "Verifying endpoint count matches between file and daemon..."
              DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
              if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
                echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
                echo "Cannot verify endpoint count - daemon may not be responding correctly"
                exit 1
              fi
              
              DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
              echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints"
              echo "File whitelist contained $FILE_ENDPOINT_COUNT endpoints"
              
              # Calculate difference (allow small differences for deduplication/filtering)
              DIFF=$((FILE_ENDPOINT_COUNT - DAEMON_ENDPOINT_COUNT))
              # Calculate absolute value
              if [[ "$DIFF" -lt 0 ]]; then
                ABS_DIFF=$((0 - DIFF))
              else
                ABS_DIFF=$DIFF
              fi
              
              if [[ "$DAEMON_ENDPOINT_COUNT" != "$FILE_ENDPOINT_COUNT" ]]; then
                if [[ "$ABS_DIFF" -le 2 ]]; then
                  # Small difference (1-2 endpoints) - likely deduplication or filtering
                  echo ""
                  echo "[WARNING]  Warning: Small endpoint count difference (daemon may have deduplicated/filtered)"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This is likely expected behavior - daemon may deduplicate or filter invalid endpoints."
                  echo "Continuing with daemon whitelist count: $DAEMON_ENDPOINT_COUNT"
                  echo "[OK] Endpoint count verified (small difference acceptable): $DAEMON_ENDPOINT_COUNT endpoints"
                else
                  # Large difference - indicates real problem
                  echo ""
                  echo "[ERROR] ERROR: Significant endpoint count mismatch between file and daemon!"
                  echo "   File endpoint count: $FILE_ENDPOINT_COUNT"
                  echo "   Daemon endpoint count: $DAEMON_ENDPOINT_COUNT"
                  echo "   Difference: $DIFF endpoints"
                  echo ""
                  echo "This indicates the whitelist was not loaded correctly into the daemon."
                  echo "Augmentation will fail or produce incorrect results."
                  echo ""
                  echo "Debugging info:"
                  echo "  - File: $WHITELIST_FILE"
                  echo "  - File size: $(wc -c < "$WHITELIST_FILE") bytes"
                  echo "  - Daemon whitelist name: $LOADED_NAME"
                  echo "  - Daemon status:"
                  $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
                  exit 1
                fi
              else
                echo "[OK] Endpoint count verified: $DAEMON_ENDPOINT_COUNT endpoints match exactly"
              fi
            fi
          else
            # First run: Initialize empty whitelist and verify it's loaded
            echo ""
            echo ">>> FIRST RUN: INITIALIZING EMPTY WHITELIST <<<"
            echo "Auto-whitelist mode: First run - initializing empty whitelist"
            echo "No artifact found from previous runs"
            echo "Will create empty whitelist and verify it's loaded into daemon"
            
            # Create empty whitelist JSON
            EMPTY_WHITELIST_FILE="$(pwd)/auto_whitelist_empty.json"
            jq -n '{
              "date": "Initial empty whitelist",
              "signature": null,
              "whitelists": [
                {
                  "name": "custom_whitelist",
                  "extends": null,
                  "endpoints": []
                }
              ]
            }' > "$EMPTY_WHITELIST_FILE"
            echo "Created empty whitelist file: $EMPTY_WHITELIST_FILE"
            
            # Check current whitelist state BEFORE loading
            BEFORE_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
            echo "Daemon whitelist BEFORE load: $BEFORE_NAME"
            
            # Apply empty whitelist
            echo "Calling: $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file \"$EMPTY_WHITELIST_FILE\""
            if ! $EDAMAME_POSTURE_CMD set-custom-whitelists-from-file "$EMPTY_WHITELIST_FILE"; then
              echo ""
              echo "[ERROR] ERROR: Failed to load empty whitelist into daemon!"
              echo "   Exit code: $?"
              echo "   File: $EMPTY_WHITELIST_FILE"
              exit 1
            fi
            echo "[OK] Empty whitelist loaded successfully"
            
            # CRITICAL: Verify it was loaded correctly
            sleep 1  # Give daemon a moment to process
            LOADED_NAME=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "unknown")
            echo "Daemon whitelist AFTER load: $LOADED_NAME"
            if [[ "$LOADED_NAME" != "custom_whitelist" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist not loaded correctly into daemon!"
              echo "   Expected: custom_whitelist"
              echo "   Got: $LOADED_NAME"
              echo "   Before load: $BEFORE_NAME"
              exit 1
            fi
            echo "[OK] Empty whitelist 'custom_whitelist' confirmed loaded in daemon"
            
            # CRITICAL: Verify endpoint count is 0 in daemon
            echo "Verifying empty whitelist has 0 endpoints in daemon..."
            DAEMON_WHITELIST_JSON=$($EDAMAME_POSTURE_CMD get-whitelists 2>/dev/null || echo "")
            if [[ -z "$DAEMON_WHITELIST_JSON" ]]; then
              echo "[ERROR] ERROR: Failed to get whitelist from daemon!"
              exit 1
            fi
            
            DAEMON_ENDPOINT_COUNT=$(echo "$DAEMON_WHITELIST_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "-1")
            echo "Daemon whitelist contains $DAEMON_ENDPOINT_COUNT endpoints (expected: 0)"
            
            if [[ "$DAEMON_ENDPOINT_COUNT" != "0" ]]; then
              echo ""
              echo "[ERROR] ERROR: Empty whitelist verification failed!"
              echo "   Expected: 0 endpoints"
              echo "   Got: $DAEMON_ENDPOINT_COUNT endpoints"
              echo ""
              echo "The empty whitelist was not loaded correctly into the daemon."
              exit 1
            fi
            echo "[OK] Empty whitelist verified: 0 endpoints confirmed"
          fi
        else
          echo "Auto-whitelist not enabled in this invocation"
        fi
      shell: bash

    - name: Augment existing custom whitelists if requested
      if: ${{ inputs.augment_custom_whitelists == 'true' }}
      run: |
        cd
        # Ensure a path is provided
        if [[ -z "${{ inputs.custom_whitelists_path }}" ]]; then
          echo "Error: augment_custom_whitelists requires custom_whitelists_path to be set."
          exit 1
        fi

        echo "Generating augmented whitelist from current sessions..."
        AUG_JSON=$($EDAMAME_POSTURE_CMD augment-custom-whitelists)

        if [[ -z "$AUG_JSON" ]]; then
          echo "Error: augment-custom-whitelists returned empty output"
          exit 1
        fi

        # Check if augmented whitelist has endpoints
        if command -v jq &> /dev/null; then
          ENDPOINT_COUNT=$(echo "$AUG_JSON" | jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' 2>/dev/null || echo "0")
          echo "Augmented whitelist contains $ENDPOINT_COUNT endpoints"
          
          if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
            echo "[WARNING]  Warning: Augmented whitelist is empty (no endpoints)"
            echo "This can happen if:"
            echo "  - No baseline whitelist was loaded before augmentation (use set_custom_whitelists: true first)"
            echo "  - No network sessions were captured yet"
            echo "  - No whitelist exceptions (non-conforming sessions) exist to add"
            echo ""
            echo "Augmentation requires:"
            echo "  1. A baseline whitelist loaded into the system (via set_custom_whitelists)"
            echo "  2. Network sessions captured"
            echo "  3. Some non-conforming sessions to add as exceptions"
            exit 1
          fi
        fi

        echo "$AUG_JSON" > "${{ inputs.custom_whitelists_path }}"
        echo "Augmented whitelist saved to: ${{ inputs.custom_whitelists_path }}"
      shell: bash

    - name: Wait for https access to the repo be granted if requested
      if: ${{ inputs.dump_sessions_log != 'true' && inputs.stop != 'true' }}
      run: |
        if [[ "${{ inputs.wait_for_https }}" == "true" ]]; then
          echo "Waiting for HTTPS access to the repository..."
          echo "Note: This runs AFTER the daemon has started and connected"
          echo "      so the daemon can whitelist the runner IP via EDAMAME backend"
          attempts=0
          timeout=true
          repo_url="https://github.com/${{ github.repository }}.git"
          last_status=""

          for i in {1..10}; do
            attempts=$((attempts + 1))
            echo "Attempt $attempts: Checking HTTPS access to the repo..."
            status_code=$(curl -o /dev/null -s -w "%{http_code}" -H "Authorization: token ${{ inputs.token }}" $repo_url)
            last_status="$status_code"

            if [[ "$status_code" == "301" || "$status_code" == "200" ]]; then
              timeout=false
              echo "[OK] HTTPS access granted (status: $status_code)!"
              break
            else
              echo "[WARNING] HTTPS access not yet granted. Status Code: $status_code"
              if [ $attempts -lt 10 ]; then
                echo "Waiting 60 seconds before retry..."
                sleep 60
              fi
            fi
          done

          # Calculate elapsed time (first attempt is immediate, subsequent attempts wait 60s each)
          if [ $attempts -gt 1 ]; then
            elapsed_time=$(( (attempts - 1) * 60 ))
          else
            elapsed_time=0
          fi
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo ""
            echo "[ERROR] Timeout occurred while waiting for HTTPS access to the repo."
            echo "Total attempts: $attempts"
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            echo "Last status code: $last_status"
            echo ""
            echo "Dumping EDAMAME logs for debugging..."
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Time taken to grant access: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
          fi
        fi
      shell: bash

    - name: Checkout the repo through the git CLI if requested
      run: |
        if [[ "${{ inputs.checkout }}" == "true" ]]; then
          timeout=true

          # Initialize the repo if it doesn't exist
          git init || true

          # Add the remote if it doesn't exist (support GHES/self-hosted via GITHUB_SERVER_URL)
          server_url="${GITHUB_SERVER_URL:-https://github.com}"
          server_url="${server_url%/}"
          if [[ "$server_url" == *"://"* ]]; then
            server_scheme="${server_url%%://*}"
            server_host_path="${server_url#*://}"
          else
            server_scheme="https"
            server_host_path="$server_url"
          fi
          remote_url="${server_scheme}://x-access-token:${{ inputs.token }}@${server_host_path}/${{ github.repository }}.git"
          if git remote | grep -q '^origin$'; then
            git remote set-url origin "$remote_url" || true
          else
            git remote add origin "$remote_url" || true
          fi
          for i in {1..10}; do
            echo "Attempt $i: Checking out the repo through the git CLI..."
            if git fetch --depth=1 origin ${{ github.ref }}; then
              branch_name=$(echo "${{ github.ref }}" | sed -e "s/^refs\/heads\///")
              if git checkout -B "$branch_name" FETCH_HEAD; then
                if [[ "${{ inputs.checkout_submodules }}" == "true" ]]; then
                  git submodule update --init --recursive
                fi
                timeout=false
                break
              fi
            else
              echo "Checkout of the repo through the git CLI failed. Waiting for 60 seconds..."
              sleep 60
            fi
          done

          elapsed_time=$((i * 60))
          elapsed_minutes=$((elapsed_time / 60))
          elapsed_seconds=$((elapsed_time % 60))

          if [ "$timeout" = true ]; then
            echo "Timeout occurred while waiting for access to the repo through the git CLI."
            echo "Total time before timeout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."
            # Dump the logs
            cd
            find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
            exit 1
          else
            echo "Checkout of the repo through the git CLI succeeded."
            echo "Time taken to checkout: ${elapsed_minutes} minutes and ${elapsed_seconds} seconds."

            # Verify the checked out commit and branch
            echo "Checked out branch: $(git rev-parse --abbrev-ref HEAD)"
            echo "Checked out commit: $(git rev-parse HEAD)"
            if [ "$(git rev-parse HEAD)" != "${{ github.sha }}" ]; then
              echo "Warning: The checked out commit does not match the expected SHA."
              echo "Expected: ${{ github.sha }}"
              echo "Actual: $(git rev-parse HEAD)"
            fi
          fi
        fi
      shell: bash

    - name: Create custom whitelists from network sessions if requested
      run: |
        if [[ "${{ inputs.create_custom_whitelists }}" == "true" ]]; then
          cd
          echo "Creating custom whitelists from active network sessions..."
          if [[ -n "${{ inputs.custom_whitelists_path }}" ]]; then
            # Save to the specified file
            $EDAMAME_POSTURE_CMD create-custom-whitelists > "${{ inputs.custom_whitelists_path }}"
            
            # Check if the created whitelist has endpoints
            if command -v jq &> /dev/null; then
              ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "${{ inputs.custom_whitelists_path }}" 2>/dev/null || echo "0")
              echo "Created whitelist contains $ENDPOINT_COUNT endpoints"
              
              if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
                echo "[WARNING]  Warning: Created whitelist is empty (no endpoints)"
                echo "This can happen if:"
                echo "  - No network sessions were captured yet (wait longer before creating whitelist)"
                echo "  - Only ingress (local-to-local) sessions exist (these are excluded from whitelists)"
                echo "  - All sessions were filtered out"
                echo "The whitelist file was created but will not be loaded automatically if empty"
              fi
            fi
            
            echo "Custom whitelists saved to: ${{ inputs.custom_whitelists_path }}"
          else
            # Just display the whitelist JSON
            $EDAMAME_POSTURE_CMD create-custom-whitelists
          fi
        fi
      shell: bash

    - name: Create or augment auto-whitelist
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        
        # Use configuration from saved state or fallback to inputs
        THRESHOLD="${AUTO_WHITELIST_THRESHOLD:-${{ inputs.auto_whitelist_stability_threshold }}}"
        CONSECUTIVE="${AUTO_WHITELIST_CONSECUTIVE:-${{ inputs.auto_whitelist_stability_consecutive_runs }}}"
        MAX_ITER="${AUTO_WHITELIST_MAX_ITER:-${{ inputs.auto_whitelist_max_iterations }}}"
        
        echo "=== Auto-whitelist Mode: Processing Iteration $AUTO_WHITELIST_ITERATION ==="
        echo "Configuration: threshold=${THRESHOLD}%, consecutive=${CONSECUTIVE}, max=${MAX_ITER}"
        
        # CRITICAL: Verify daemon is ready BEFORE checking whitelist
        echo "Checking daemon readiness before augmentation..."
        if ! $EDAMAME_POSTURE_CMD status >/dev/null 2>&1; then
          echo "[ERROR] ERROR: Daemon is not responding!"
          echo "Cannot proceed with augmentation - daemon must be running and ready."
          echo ""
          echo "Daemon status:"
          $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
          exit 1
        fi
        echo "[OK] Daemon is ready"
        
        # CRITICAL: Verify daemon state before augmentation
        echo "Checking daemon whitelist state..."
        DAEMON_WHITELIST=$($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo "none")
        echo "Daemon whitelist: $DAEMON_WHITELIST"
        
        if [[ "$DAEMON_WHITELIST" != "custom_whitelist" && "$AUTO_WHITELIST_ITERATION" -gt 0 ]]; then
          echo ""
          echo "[ERROR] ERROR: Daemon does not have custom_whitelist loaded!"
          echo "   Expected: custom_whitelist"
          echo "   Actual: $DAEMON_WHITELIST"
          echo ""
          echo "This breaks auto-whitelist - augmentation requires custom_whitelist to be loaded."
          echo "Without it, augmentation creates a fresh whitelist instead of merging with baseline."
          echo ""
          echo "The daemon should have loaded the whitelist during setup."
          echo "This error indicates the whitelist was not applied correctly."
          echo ""
          echo "Debugging info:"
          echo "  - Iteration: $AUTO_WHITELIST_ITERATION"
          echo "  - AUTO_WHITELIST_EXISTS: $AUTO_WHITELIST_EXISTS"
          echo "  - Whitelist file: $(ls -lh auto_whitelist.json 2>/dev/null || echo 'missing')"
          echo "  - Whitelist file path: $(pwd)/auto_whitelist.json"
          echo "  - File exists: $([ -f "auto_whitelist.json" ] && echo 'yes' || echo 'no')"
          echo "  - Daemon status:"
          $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
          echo ""
          echo "CRITICAL: Cannot proceed with augmentation - whitelist must be loaded during setup."
          echo "Augmentation requires custom_whitelist to be active in the daemon."
          echo "Attempting to reload now would mask the root cause of the setup failure."
          echo ""
          echo "Fix: Ensure the whitelist is successfully loaded into the daemon during setup."
          exit 1
        fi
        
        echo "[OK] Daemon has correct whitelist loaded for augmentation"
        
        # For subsequent runs, force session update before augmentation to ensure exceptions are populated
        if [[ "$AUTO_WHITELIST_EXISTS" == "true" ]]; then
          echo "Forcing session update before augmentation..."
          $EDAMAME_POSTURE_CMD get-sessions > /dev/null 2>&1 || true
          echo "Session update completed"
        fi
        
        # Create/augment whitelist from current sessions
        if [[ "$AUTO_WHITELIST_EXISTS" == "false" ]]; then
            # First run: create initial whitelist from captured traffic
            echo "First run: Creating initial whitelist from captured traffic..."
            echo "Calling: $EDAMAME_POSTURE_CMD create-custom-whitelists"
            
            if ! $EDAMAME_POSTURE_CMD create-custom-whitelists > auto_whitelist_new.json 2>&1; then
              echo ""
              echo "[ERROR] ERROR: create-custom-whitelists command FAILED!"
              echo "   Exit code: $?"
              echo "   Command output:"
              cat auto_whitelist_new.json 2>/dev/null || echo "    (no output captured)"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              exit 1
            fi
            echo "[OK] Create command executed successfully"
            
            # Save iteration count
            echo "1" > auto_whitelist_iteration.txt
            mv auto_whitelist_new.json auto_whitelist.json
            
            # Count endpoints with error handling
            ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' auto_whitelist.json 2>/dev/null || echo "0")
            echo "Initial whitelist created with $ENDPOINT_COUNT endpoints"
            
            if [[ "$ENDPOINT_COUNT" -eq 0 ]]; then
              echo "[WARNING]  Warning: Initial auto-whitelist is empty (no endpoints)"
              echo "This can happen if no network sessions were captured yet"
              echo "The whitelist will not be loaded automatically if empty"
            fi
            
            echo "AUTO_WHITELIST_STATUS=created" >> $GITHUB_ENV
            echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
          else
            # Subsequent run: augment and check stability
            # Note: augment-custom-whitelists handles empty baselines correctly by creating whitelist from exceptions
            echo "Iteration $AUTO_WHITELIST_ITERATION: Augmenting whitelist..."
            echo "Current daemon whitelist: $($EDAMAME_POSTURE_CMD get-whitelist-name 2>/dev/null || echo 'unknown')"
            echo "Calling: $EDAMAME_POSTURE_CMD augment-custom-whitelists"
            
            # Capture stdout (JSON) and stderr separately
            # Only JSON should go to the file, stderr should be logged separately
            if ! $EDAMAME_POSTURE_CMD augment-custom-whitelists > auto_whitelist_new.json 2> augment_stderr.log; then
              echo ""
              echo "[ERROR] ERROR: augment-custom-whitelists command FAILED!"
              echo "   Exit code: $?"
              echo ""
              echo "Command stderr output:"
              cat augment_stderr.log 2>/dev/null || echo "    (no stderr captured)"
              echo ""
              echo "Command stdout (JSON) output:"
              head -c 1000 auto_whitelist_new.json 2>/dev/null || echo "    (no stdout captured)"
              echo ""
              echo "Daemon status:"
              $EDAMAME_POSTURE_CMD status || echo "    (daemon not responding)"
              echo ""
              echo "Current daemon whitelist:"
              $EDAMAME_POSTURE_CMD get-whitelist-name || echo "    (command failed)"
              exit 1
            fi
            
            # Log stderr if any (for debugging)
            if [[ -s augment_stderr.log ]]; then
              echo "[WARNING] Command stderr output (non-fatal):"
              cat augment_stderr.log
            fi
            
            echo "[OK] Augment command executed successfully"
            
            # Verify output file was created
            if [[ ! -f "auto_whitelist_new.json" ]]; then
              echo "[ERROR] ERROR: augment-custom-whitelists did not create output file!"
              exit 1
            fi
            
            # CRITICAL: Validate JSON structure and clean if needed
            # augment-custom-whitelists might output non-JSON text before the JSON
            if command -v jq &> /dev/null; then
              # Check if file is valid JSON
              if ! jq . auto_whitelist_new.json >/dev/null 2>&1; then
                echo "[WARNING] Warning: Output file is not valid JSON, attempting to extract JSON..."
                # Try to extract JSON by finding the first { and using jq to parse from there
                mv auto_whitelist_new.json auto_whitelist_new.json.orig
                # Find line starting with { and extract everything from there
                # Use awk to find first line with { and print rest
                awk '/^\{/ {p=1} p' auto_whitelist_new.json.orig > auto_whitelist_new.json.tmp 2>/dev/null || {
                  # Fallback: try to extract JSON using jq's raw input
                  # jq can sometimes parse JSON even with leading text
                  jq -R 'fromjson?' auto_whitelist_new.json.orig 2>/dev/null | jq . > auto_whitelist_new.json.tmp 2>/dev/null || true
                }
                
                # Validate extracted JSON
                if jq . auto_whitelist_new.json.tmp >/dev/null 2>&1; then
                  mv auto_whitelist_new.json.tmp auto_whitelist_new.json
                  echo "[OK] Extracted valid JSON from command output"
                else
                  echo "[ERROR] ERROR: Cannot extract valid JSON from command output"
                  echo "First 1000 chars of output:"
                  head -c 1000 auto_whitelist_new.json.orig | cat -A
                  echo ""
                  echo "Attempting to show structure:"
                  head -20 auto_whitelist_new.json.orig | cat -A
                  exit 1
                fi
              else
                echo "[OK] Output file is valid JSON"
              fi
            fi
            
            # CRITICAL: Count endpoints in old and new whitelists before comparison
            if command -v jq &> /dev/null; then
              OLD_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
              NEW_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist_new.json" 2>/dev/null || echo "0")
              echo "Old whitelist (before augmentation): $OLD_ENDPOINT_COUNT endpoints"
              echo "New whitelist (after augmentation): $NEW_ENDPOINT_COUNT endpoints"
              
              if [[ "$NEW_ENDPOINT_COUNT" -eq 0 && "$OLD_ENDPOINT_COUNT" -gt 0 ]]; then
                echo ""
                echo "[ERROR] ERROR: Augmentation resulted in empty whitelist!"
                echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                echo ""
                echo "This indicates augment-custom-whitelists failed to preserve baseline endpoints."
                echo "Debugging info:"
                echo "  - Old file size: $(wc -c < auto_whitelist.json) bytes"
                echo "  - New file size: $(wc -c < auto_whitelist_new.json) bytes"
                echo "  - New file first 500 chars:"
                head -c 500 auto_whitelist_new.json | cat -A || echo "    (cannot read file)"
                echo "  - New file JSON structure:"
                jq 'keys' auto_whitelist_new.json 2>/dev/null || echo "    (cannot parse)"
                echo "  - Whitelists in new file:"
                jq '.whitelists[]?.name' auto_whitelist_new.json 2>/dev/null || echo "    (cannot parse)"
                exit 1
              fi

              if [[ "$NEW_ENDPOINT_COUNT" -lt "$OLD_ENDPOINT_COUNT" ]]; then
                ENDPOINT_DELTA=$((OLD_ENDPOINT_COUNT - NEW_ENDPOINT_COUNT))
                if [[ "$ENDPOINT_DELTA" -le 2 ]]; then
                  echo ""
                  echo "[WARNING] Warning: Endpoint count decreased slightly after augmentation"
                  echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                  echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                  echo "   Difference: -$ENDPOINT_DELTA endpoints"
                  echo "   Continuing (difference within acceptable deduplication threshold 2)"
                else
                  echo ""
                  echo "[ERROR] ERROR: Endpoint count decreased after augmentation!"
                  echo "   Old whitelist had: $OLD_ENDPOINT_COUNT endpoints"
                  echo "   New whitelist has: $NEW_ENDPOINT_COUNT endpoints"
                  echo "   Difference: -$ENDPOINT_DELTA endpoints"
                  echo ""
                  echo "Auto-whitelist must be monotonically increasing during learning."
                  echo "This indicates augment-custom-whitelists removed baseline endpoints."
                  echo ""
                  echo "Debugging info:"
                  echo "  - Old file size: $(wc -c < auto_whitelist.json) bytes"
                  echo "  - New file size: $(wc -c < auto_whitelist_new.json) bytes"
                  echo "  - Old file first 200 chars:"
                  head -c 200 auto_whitelist.json | cat -A || echo "    (cannot read file)"
                  echo "  - New file first 200 chars:"
                  head -c 200 auto_whitelist_new.json | cat -A || echo "    (cannot read file)"
                  exit 1
                fi
              fi
            fi
            
            # Compare old and new whitelists
            DIFF_PERCENT=$($EDAMAME_POSTURE_CMD compare-custom-whitelists-from-files auto_whitelist.json auto_whitelist_new.json | sed 's/%//' || echo "100")
            echo "Whitelist difference: ${DIFF_PERCENT}%"
            echo "AUTO_WHITELIST_DIFF=$DIFF_PERCENT" >> $GITHUB_ENV
            
            # Check if this iteration is stable (below threshold)
            # Use bc for floating-point comparison if available, otherwise use integer comparison
            if command -v bc &> /dev/null; then
              IS_STABLE=$(echo "$DIFF_PERCENT <= $THRESHOLD" | bc -l)
            else
              # Fallback to integer comparison (convert to int)
              DIFF_INT=${DIFF_PERCENT%.*}
              THRESHOLD_INT=${THRESHOLD%.*}
              [[ $DIFF_INT -le $THRESHOLD_INT ]] && IS_STABLE=1 || IS_STABLE=0
            fi
            
            if [[ "$IS_STABLE" == "1" ]]; then
              # Increment consecutive stable runs count
              STABLE_COUNT=$((AUTO_WHITELIST_STABLE_COUNT + 1))
              echo "$STABLE_COUNT" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=$STABLE_COUNT" >> $GITHUB_ENV
              
              echo "[OK] Whitelist is STABLE for this run (diff: ${DIFF_PERCENT}% <= threshold: ${THRESHOLD}%)"
              echo "   Consecutive stable runs: $STABLE_COUNT / $CONSECUTIVE required"
              
              # Check if we have enough consecutive stable runs
              if [[ $STABLE_COUNT -ge $CONSECUTIVE ]]; then
                echo "[SUCCESS] Whitelist is FULLY STABLE ($STABLE_COUNT consecutive runs with no changes)"
                # Update iteration and whitelist even when fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                
                # Verify final whitelist has endpoints
                if command -v jq &> /dev/null; then
                  FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                  echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
                fi
                
                echo "AUTO_WHITELIST_STATUS=stable" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "[PROGRESS] Whitelist is stable for this run, but need more consecutive confirmations"
                # Update iteration and whitelist when stable but not fully stable
                NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
                echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
                mv auto_whitelist_new.json auto_whitelist.json
                
                # Verify final whitelist has endpoints
                if command -v jq &> /dev/null; then
                  FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                  echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
                fi
                
                echo "AUTO_WHITELIST_STATUS=confirming_stability" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            else
              # Whitelist changed - reset consecutive stable count
              echo "[PROGRESS] Whitelist is EVOLVING (diff: ${DIFF_PERCENT}% > threshold: ${THRESHOLD}%)"
              echo "0" > auto_whitelist_stable_count.txt
              echo "AUTO_WHITELIST_STABLE_COUNT=0" >> $GITHUB_ENV
              
              NEXT_ITERATION=$((AUTO_WHITELIST_ITERATION + 1))
              echo "$NEXT_ITERATION" > auto_whitelist_iteration.txt
              mv auto_whitelist_new.json auto_whitelist.json
              
              # Verify final whitelist has endpoints
              if command -v jq &> /dev/null; then
                FINAL_ENDPOINT_COUNT=$(jq '[.whitelists[]? | select(.name == "custom_whitelist") | .endpoints? // [] | length] | add // 0' "auto_whitelist.json" 2>/dev/null || echo "0")
                echo "Final whitelist saved with $FINAL_ENDPOINT_COUNT endpoints"
              fi
              
              # Check if max iterations reached
              if [[ $NEXT_ITERATION -ge $MAX_ITER ]]; then
                echo "[WARNING] Maximum iterations reached ($MAX_ITER), declaring stable"
                echo "AUTO_WHITELIST_STATUS=max_iterations" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=true" >> $GITHUB_ENV
              else
                echo "AUTO_WHITELIST_STATUS=evolving" >> $GITHUB_ENV
                echo "AUTO_WHITELIST_STABLE=false" >> $GITHUB_ENV
              fi
            fi
          fi
      shell: bash
      env:
        EDAMAME_POSTURE_CMD: ${{ env.EDAMAME_POSTURE_CMD }}
        AUTO_WHITELIST_ITERATION: ${{ env.AUTO_WHITELIST_ITERATION }}
        AUTO_WHITELIST_EXISTS: ${{ env.AUTO_WHITELIST_EXISTS }}
        AUTO_WHITELIST_STABLE_COUNT: ${{ env.AUTO_WHITELIST_STABLE_COUNT }}
        AUTO_WHITELIST_THRESHOLD: ${{ env.AUTO_WHITELIST_THRESHOLD }}
        AUTO_WHITELIST_CONSECUTIVE: ${{ env.AUTO_WHITELIST_CONSECUTIVE }}
        AUTO_WHITELIST_MAX_ITER: ${{ env.AUTO_WHITELIST_MAX_ITER }}

    - name: Dump sessions log if requested
      if: ${{ inputs.dump_sessions_log == 'true' }}
      run: |
        cd
        ARGS=(get-sessions)

        # Handle whitelist exception enforcement based on auto-whitelist mode
        if [[ "$AUTO_WHITELIST_ENABLED" == "true" ]]; then
          # Auto-whitelist mode: only enforce when stable
          if [[ "$AUTO_WHITELIST_STABLE" == "true" ]]; then
            echo "[INFO] Auto-whitelist is STABLE - enforcing whitelist violations"
            echo "   Any whitelist exceptions will cause this step to fail"
            ARGS+=(--fail-on-whitelist)
          else
            echo "[INFO] Auto-whitelist is LEARNING/EVOLVING - whitelist exceptions are expected"
            echo "   New endpoints will be discovered and added to the whitelist"
            echo "   This step will NOT fail on whitelist exceptions during learning"
            # Do NOT add --fail-on-whitelist during learning
          fi
        else
          # Manual mode: respect the exit_on_whitelist_exceptions input
        if [[ "${{ inputs.exit_on_whitelist_exceptions }}" == "true" ]]; then
          ARGS+=(--fail-on-whitelist)
          fi
        fi

        if [[ "${{ inputs.exit_on_blacklisted_sessions }}" == "true" ]]; then
          ARGS+=(--fail-on-blacklist)
        fi

        if [[ "${{ inputs.exit_on_anomalous_sessions }}" == "true" ]]; then
          ARGS+=(--fail-on-anomalous)
        fi

        # Execute get-sessions command
        # During auto-whitelist learning phases, non-zero exit codes are expected
        # (non-conforming sessions are being discovered and will be added to whitelist)
        if [[ "$AUTO_WHITELIST_ENABLED" == "true" && "$AUTO_WHITELIST_STABLE" != "true" ]]; then
          # Learning phase: capture exit code but don't fail
          echo "Executing: $EDAMAME_POSTURE_CMD ${ARGS[*]}"
          set +e  # Don't exit on error during learning phase
          $EDAMAME_POSTURE_CMD "${ARGS[@]}"
          EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo ""
            echo "[INFO] Non-zero exit code ($EXIT_CODE) - this is expected during learning phase"
            echo "   Non-conforming sessions detected (ignoring during learning)"
            echo "   These sessions will be added to the whitelist via augmentation"
            echo "   This is normal behavior - whitelist is still evolving"
            echo ""
            # Don't exit - continue with augmentation
          else
            echo "[OK] No whitelist exceptions detected"
          fi
        else
          # Stable phase or manual mode: fail on errors
        $EDAMAME_POSTURE_CMD "${ARGS[@]}"
        fi
      shell: bash
      env:
        EDAMAME_POSTURE_CMD: ${{ env.EDAMAME_POSTURE_CMD }}
        AUTO_WHITELIST_ENABLED: ${{ env.AUTO_WHITELIST_ENABLED }}
        AUTO_WHITELIST_STABLE: ${{ env.AUTO_WHITELIST_STABLE }}

    - name: Display logs if requested
      run: |
        if [[ "${{ inputs.display_logs }}" == "true" ]]; then
          # Rather scan the home directory for logs in case the dameon has been killed
          cd
          #$EDAMAME_POSTURE_CMD logs
          find . \( -name "edamame_*.2*-*-*" -o -name "*_panic_*.txt" \) -exec echo "--- {} ---" \; -exec cat {} \; || echo "No logs found"
        fi
      shell: bash

    - name: Save auto-whitelist state
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        STATE_ITERATION=$(cat auto_whitelist_iteration.txt 2>/dev/null || echo "0")
        cat <<'EOF' > auto_whitelist_state.json
        {
          "last_run_id": "${GITHUB_RUN_ID}",
          "last_iteration": "__STATE_ITERATION__",
          "artifact_name": "${{ env.AUTO_WHITELIST_ARTIFACT_NAME || inputs.auto_whitelist_artifact_name }}",
          "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        sed -i "s/__STATE_ITERATION__/$STATE_ITERATION/" auto_whitelist_state.json
      shell: bash
    
    - name: Upload auto-whitelist artifact
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.AUTO_WHITELIST_ARTIFACT_NAME || inputs.auto_whitelist_artifact_name }}
        path: |
          ~/auto_whitelist.json
          ~/auto_whitelist_iteration.txt
          ~/auto_whitelist_stable_count.txt
          ~/auto_whitelist_config.json
          ~/auto_whitelist_state.json
        retention-days: 90
        overwrite: true
        if-no-files-found: warn
    
    - name: Upload auto-whitelist state artifact
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' && always() }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.auto_whitelist_state_artifact_name }}
        path: ~/auto_whitelist_state.json
        retention-days: 90
        overwrite: true
        if-no-files-found: warn
    
    - name: Display final whitelist file
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo ""
        echo "=== Final auto_whitelist.json uploaded in previous step ==="
        if command -v jq &> /dev/null; then
          jq . auto_whitelist.json || cat auto_whitelist.json
        else
          cat auto_whitelist.json
        fi
        echo "=== End of whitelist file ==="
      shell: bash

    - name: Display auto-whitelist status
      if: ${{ inputs.dump_sessions_log == 'true' && env.AUTO_WHITELIST_ENABLED == 'true' }}
      run: |
        cd
        echo ""
        echo "=== Auto-whitelist Status ==="
        echo "Iteration: $AUTO_WHITELIST_ITERATION"
        echo "Status: $AUTO_WHITELIST_STATUS"
        echo "Stable: $AUTO_WHITELIST_STABLE"
        if [[ -n "$AUTO_WHITELIST_DIFF" ]]; then
          echo "Difference: ${AUTO_WHITELIST_DIFF}%"
        fi
        # Load configuration for display
        CONSECUTIVE="${AUTO_WHITELIST_CONSECUTIVE:-${{ inputs.auto_whitelist_stability_consecutive_runs }}}"
        
        if [[ -n "$AUTO_WHITELIST_STABLE_COUNT" ]]; then
          echo "Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / $CONSECUTIVE"
        fi
        
        # Display summary with enforcement status
        if [[ "$AUTO_WHITELIST_STATUS" == "created" ]]; then
          echo ""
          echo "[INFO] This was the first run in listen-only mode."
          echo "   Whitelist exceptions are NORMAL and did NOT cause failure."
          echo "   Re-run the workflow to start refining the whitelist."
        elif [[ "$AUTO_WHITELIST_STATUS" == "evolving" ]]; then
          echo ""
          echo "[PROGRESS] Whitelist is still evolving (${AUTO_WHITELIST_DIFF}% change)."
          echo "   New endpoints were discovered and added to the whitelist."
          echo "   Whitelist exceptions are EXPECTED and did NOT cause failure."
          echo "   Consecutive stable runs reset to 0."
          echo "   Re-run the workflow to continue refinement."
        elif [[ "$AUTO_WHITELIST_STATUS" == "confirming_stability" ]]; then
          echo ""
          echo "[PROGRESS] Whitelist had no changes this run (${AUTO_WHITELIST_DIFF}%)."
          echo "   No new endpoints discovered - counting stable runs."
          echo "   Whitelist exceptions still allowed (NOT failing yet)."
          echo "   Consecutive stable runs: $AUTO_WHITELIST_STABLE_COUNT / $CONSECUTIVE"
          echo "   Re-run the workflow to confirm stability."
        elif [[ "$AUTO_WHITELIST_STATUS" == "stable" ]]; then
          echo ""
          echo "[OK] Whitelist has stabilized!"
          echo "   Achieved $AUTO_WHITELIST_STABLE_COUNT consecutive runs with no changes."
          echo "   ENFORCEMENT ENABLED: Future runs will FAIL on whitelist violations."
          echo "   Any new endpoint will be treated as a potential supply chain attack."
        elif [[ "$AUTO_WHITELIST_STATUS" == "max_iterations" ]]; then
          echo ""
          echo "[WARNING] Maximum iterations reached."
          echo "   Whitelist declared stable even though still evolving."
          echo "   ENFORCEMENT ENABLED: Future runs will FAIL on whitelist violations."
        fi
      shell: bash
      env:
        AUTO_WHITELIST_CONSECUTIVE: ${{ env.AUTO_WHITELIST_CONSECUTIVE }}

    - name: Stop EDAMAME Posture process if requested
      run: |
        if [[ "${{ inputs.stop }}" == "true" ]]; then
          cd
          echo "Stopping EDAMAME Posture process..."
          $EDAMAME_POSTURE_CMD stop
          echo "EDAMAME Posture process stopped."
        fi
      shell: bash
